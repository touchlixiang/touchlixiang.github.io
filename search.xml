<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[09 Dockerfile 私有仓库 harbor]]></title>
    <url>%2F2019%2F10%2F12%2Fdocker-harbor%2F</url>
    <content type="text"><![CDATA[Harbor 简介真正生产环境，我们无法有效的管理Docker Regisry。官方提供了收费版的Registry，社区有开源版本的Harbor。 Harbor简介:Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。 Harbor 特性 基于角色的访问控制 ：用户与Docker镜像仓库通过“项目”进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限。 镜像复制 ： 镜像可以在多个Registry实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景。 图形化用户界面 ： 用户可以通过浏览器来浏览，检索当前Docker镜像仓库，管理项目和命名空间。 AD/LDAP 支持 ： Harbor可以集成企业内部已有的AD/LDAP，用于鉴权认证管理。 审计管理 ： 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。 国际化 ： 已拥有英文、中文、德文、日文和俄文的本地化版本。更多的语言将会添加进来。 RESTful API ： RESTful API 提供给管理员对于Harbor更多的操控, 使得与其它管理软件集成变得更容易。 部署简单 ： 提供在线和离线两种安装工具， 也可以安装到vSphere平台(OVA方式)虚拟设备。 Harbor 组件 Proxy：Harbor的registry, UI, token等服务，通过一个前置的反向代理统一接收浏览器、Docker客户端的请求，并将请求转发给后端不同的服务。 Registry： 负责储存Docker镜像，并处理docker push/pull 命令。由于我们要对用户进行访问控制，即不同用户对Docker image有不同的读写权限，Registry会指向一个token服务，强制用户的每次docker pull/push请求都要携带一个合法的token, Registry会通过公钥对token 进行解密验证。 Core services： 这是Harbor的核心功能，主要提供以下服务： UI：提供图形化界面，帮助用户管理registry上的镜像（image）, 并对用户进行授权。 webhook：为了及时获取registry 上image状态变化的情况， 在Registry上配置webhook，把状态变化传递给UI模块。 token 服务：负责根据用户权限给每个docker push/pull命令签发token. Docker 客户端向Regiøstry服务发起的请求,如果不包含token，会被重定向到这里，获得token后再重新向Registry进行请求。 Database：为core services提供数据库服务，负责储存用户权限、审计日志、Docker image分组信息等数据。 Job Services：提供镜像远程复制功能，可以把本地镜像同步到其他Harbor实例中。 Log collector：为了帮助监控Harbor运行，负责收集其他组件的log，供日后进行分析。 Harbor安装1https://github.com/goharbor/harbor/releases 离线安装1234567891011121314151617# 解压安装包,修改配置文件[root@linux-node2 tools]# tar -xf harbor-offline-installer-v1.8.4-rc1.tgz [root@linux-node2 tools]# cd harbor# 修改主机名和管理员密码、数据库密码vim harbor.ymlhostname: 10.0.0.102harbor_admin_password: 123456database: password: 123456 #安装./install.sh[root@linux-node2 harbor]# vim harbor.yml [root@linux-node2 harbor]# ./install.sh 从 1.8.0 后，harbor配置文件由原先的 harbor.cfg 改为 harbor.yml hostname: 目标主机的主机名，用于访问Portal和注册表服务。它应该是目标计算机的IP地址或完全限定的域名（FQDN），例如，10.0.0.102或reg.yourdomain.com。不要使用localhost或127.0.0.1作为主机名 - 外部客户端需要访问注册表服务这里修改为我们的主机ip即可。 data_volume： 存储 harbor 数据的位置。这里可以修改为 /usr/local/workspace/harbor/data harbor_admin_password：管理员的初始密码。此密码仅在Harbor首次启动时生效。之后，将忽略此设置，并且应在Portal中设置管理员密码。请注意，默认用户名/密码为admin / Harbor12345。 12345678910111213关于端口配置：http：port：你的http的端口号https：用于访问Portal和令牌/通知服务的协议。如果启用了公证，则必须设置为https。请参阅使用HTTPS访问配置Harbor。port：https的端口号certificate：SSL证书的路径，仅在协议设置为https时应用。private_key：SSL密钥的路径，仅在协议设置为https时应用。 免https使用12345678# 配置免https# 修改 /etc/docker/daemon.json[root@linux-node2 harbor]# vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://a64eacm1.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;: [&quot;10.0.0.102&quot;]&#125; 1234567891011# 重启docker systemctl daemon-reloadsystemctl restart docker.service# 重启harbor仓库# cd 到 harbor的安装目录cd /data/tools/harbor# 执行命令docker-compose stopdocker-compose up -d 登录web12http://10.0.0.102 admin/123456 上传镜像12345678910# node1 默认docker访问register都是基于https的，需要添加信任[root@linux-node1 ~]# vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://a64eacm1.mirror.aliyuncs.com&quot;], &quot;data-root&quot;: &quot;/data/docker&quot;, &quot;insecure-registries&quot;: [&quot;10.0.0.102&quot;]&#125;[root@linux-node1 ~]# systemctl daemon-reload[root@linux-node1 ~]# systemctl restart docker.service 123456789101112131415161718192021# 在镜像服务器node1,登录harbor仓库[root@linux-node1 ~]# docker login 10.0.0.102Username: adminPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded# 修改待上传镜像的tag[root@linux-node1 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgame/shop-api latest 950dfdaa7360 3 hours ago 365MB[root@linux-node1 ~]# docker tag 950dfdaa7360 10.0.0.102/library/shop-api:v[root@linux-node1 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgame/shop-api latest 950dfdaa7360 3 hours ago 365MB10.0.0.102/library/shop-api v1 950dfdaa7360 3 hours ago 365MB... 12345# 上传镜像[root@linux-node1 ~]# docker push 10.0.0.102/library/shop-api:v1# 出现 类似下述信息 表示上传成功v1: digest: sha256:298299afc2a1251dc8cef3e251a361475a9c8b59c2d7309a5f39f3820a6ba6e7 size: 3030 下载镜像 下载该镜像的host 都必须要先登录才行,而且必须有权限 harbor可以创建新用户,做权限管理，访客权限只能下载 12345678910111213141516# 先删除本地的,再登录[root@linux-node1 ~]# docker rmi 10.0.0.102/library/shop-api:v1[root@linux-node1 ~]# docker login 10.0.0.102# 下载镜像# harbor页面上有友好提示哦~[root@linux-node1 ~]# docker pull 10.0.0.102/library/shop-api:v1v1: Pulling from library/shop-apiDigest: sha256:298299afc2a1251dc8cef3e251a361475a9c8b59c2d7309a5f39f3820a6ba6e7Status: Downloaded newer image for 10.0.0.102/library/shop-api:v110.0.0.102/library/shop-api:v1[root@linux-node1 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE10.0.0.102/library/shop-api v1 950dfdaa7360 3 hours ago 365MB... 1234567891011# 启动个容器测试[root@linux-node1 ~]# docker run -d -p 80:5000 -p 8022:22 --name web1-ssh 10.0.0.102/library/shop-api:v1[root@linux-node1 ~]# ssh 10.0.0.100 -p 8022root@10.0.0.100&apos;s password: [root@a576c0ee04f0 ~]# netstat -tnlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:5000 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 8/sshd tcp6 0 0 :::22 :::* LISTEN 8/sshd Harbor 主从同步 Harbor 还提供双机的 镜像推送功能]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08 Dockerfile 构建镜像]]></title>
    <url>%2F2019%2F10%2F12%2Fdocker-dockerfile%2F</url>
    <content type="text"><![CDATA[DockerfileDockerfile 是一个文本文件，记录了镜像构建的所有步骤。 构建镜像 由于官方提供的centos镜像有很多基础命令没有安装，所有我们自己来构建一个基础base 生产环境也可参照这种分层目录 123456789[root@linux-node1 opt]# mkdir -p /opt/Game/&#123;system,app,runtime&#125;[root@linux-node1 opt]# mkdir -p /opt/Game/system/centos[root@linux-node1 opt]# tree Game/Game/ # 项目目录├── app # 程序├── runtime # 运行环境└── system # 基础环境 └── centos # centos的基础环境 使用Dockerfile 创建自定义基础环境镜像 123456789101112131415161718[root@linux-node1 centos]# vim Dockerfile # BASE FROM centos:7# WHOMAINTAINER leo 365042337@qq.com# EPELADD epel.repo /etc/yum.repos.d/# PKGRUN yum install -y wget supervisor tree net-tools sudo vim &amp;&amp; yum clean all[root@linux-node1 centos]# ls -ltotal 8-rw-r--r--. 1 root root 183 Oct 12 10:30 Dockerfile-rw-r--r--. 1 root root 664 Oct 12 10:30 epel.repo docker build 构建镜像 1[root@linux-node1 centos]# docker build -t game/centos:7 . 镜像生成分析: 1234567891011121314151617181920212223[root@linux-node1 centos]# docker build -t game/centos:7 .Sending build context to Docker daemon 3.584kBStep 1/4 : FROM centos:7 ---&gt; 67fa590cfc1cStep 2/4 : MAINTAINER leo 365042337@qq.com ---&gt; Running in c7cd314eb180Removing intermediate container c7cd314eb180 ---&gt; 9023eddfd98cStep 3/4 : ADD epel.repo /etc/yum.repos.d/ ---&gt; fffbe0882202Step 4/4 : RUN yum install -y wget supervisor tree net-tools sudo vim &amp;&amp; yum clean all ---&gt; Running in 17e580d1346d... Complete!Loaded plugins: fastestmirror, ovlCleaning repos: base epel extras updatesCleaning up list of fastest mirrorsRemoving intermediate container 17e580d1346d ---&gt; ea065b022d5bSuccessfully built ea065b022d5bSuccessfully tagged game/centos:7 123456789101112131415161718192021222324251. 运行 docker build 命令，-t 将新镜像命名为 game/centos:7，命令末尾的 . 指明 build context 为当前目录。Docker 默认会从 build context 中查找 Dockerfile 文件，我们也可以通过 -f 参数指定 Dockerfile 的位置。2. 首先 Docker 将 build context 中的所有文件发送给 Docker daemon。build context 为镜像构建提供所需要的文件或目录Dockerfile 中的 ADD、COPY 等命令可以将 build context 中的文件添加到镜像。build context 为当前目录,该目录下的所有文件和子目录都会被发送给 Docker daemon不要将多余文件放到 build context，特别不要把 /、/usr 作为 build context，否则构建过程会相当缓慢甚至失败。3. Step 1：执行 FROM，将 centos:7 作为 base 镜像,镜像 ID 为 67fa590cfc1c。4. Step 2-4 一直执行各种配置, 包括配置文件传送,安装5. 安装成功后，将容器保存为镜像，其 ID 为 ea065b022d5b。这一步底层使用的是类似 docker commit 的命令6. 删除临时容器 17e580d1346d。7. 镜像构建成功。# 查看镜像ID 最后的镜像ID一致[root@linux-node1 centos]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgame/centos 7 ea065b022d5b 12 minutes ago 287MBcentos 7 67fa590cfc1c 7 weeks ago 202MB 查看镜像分层结构 docker history 会显示镜像的构建历史，也就是 Dockerfile 的执行过程,每一层由上至下排列 game/centos:7 镜像 是经过一层层形成的,他的最初层就是centos:7 注： 表示无法获取 IMAGE ID，通常从 Docker Hub 下载的镜像会有这个问题。 12345678[root@linux-node1 centos]# docker history game/centos:7IMAGE CREATED CREATED BY SIZE COMMENTea065b022d5b 15 minutes ago /bin/sh -c yum install -y wget supervisor tr… 84.7MB fffbe0882202 15 minutes ago /bin/sh -c #(nop) ADD file:4dab183e1e0e545b2… 664B 9023eddfd98c 15 minutes ago /bin/sh -c #(nop) MAINTAINER leo 365042337@… 0B 67fa590cfc1c 7 weeks ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B &lt;missing&gt; 7 weeks ago /bin/sh -c #(nop) LABEL org.label-schema.sc… 0B &lt;missing&gt; 7 weeks ago /bin/sh -c #(nop) ADD file:4e7247c06de9ad117… 202MB Dockerfile 常用指令123456789101112FROM # 指定基础镜像FROM centosMAINTAINER # 指定维护者信息，可以没有RUN # 在命令前面加上RUN即可 RUN yum install httpd -yADD # 复制文件，与COPY不同的是,如果 src 是归档文件（tar, zip, tgz, xz 等），文件会被自动解压到 destWORKDIR # 设置当前工作目录VOLUME # 设置卷，挂载主机目录EXPOSE # 指定对外的端口CMD # 容器启动时执行的命令CMD [“/bin/bash”],只有最后一个生效。CMD 可以被 docker run 之后的参数替换。COPY # 将文件从 build context 复制到镜像。COPY src destENV # 环境变量ENTRYPOINT # 容器启动后执行的命令,只有最后一个生效（无法被替换，CMD 或 docker run 之后的参数会被当做参数传递给 ENTRYPOINT) 运行更多的指令1234567891011121314151617[root@linux-node1 test]# vim Dockerfile # Mybusybox imagesFROM busyboxMAINTAINER leo 365042337@qq.comWORKDIR /data/testRUN touch tmpfile1COPY [&quot;tmpfile2&quot;,&quot;/data/test/&quot;]ADD [&quot;test_add.tar.gz&quot;,&quot;/data/test/&quot;]ENV WELCOME &quot;hello,welcome!&quot; 1234567# 构建前确保 build context 中存在需要的文件。[root@linux-node1 test]# echo &quot;test2&quot; &gt;&gt;tmpfile2[root@linux-node1 test]# ls -ltotal 12-rw-r--r--. 1 root root 211 Oct 12 11:14 Dockerfile-rw-r--r--. 1 root root 113 Oct 12 11:09 test_add.tar.gz-rw-r--r--. 1 root root 6 Oct 12 11:15 tmpfile2 12345678910111213141516171819202122232425262728# 构建镜像[root@linux-node1 test]# docker build -t test/mybusybox:v1 .Sending build context to Docker daemon 4.096kBStep 1/7 : FROM busybox ---&gt; 19485c79a9bbStep 2/7 : MAINTAINER leo 365042337@qq.com ---&gt; Running in 59c22052d1fdRemoving intermediate container 59c22052d1fd ---&gt; 2346b2c44a91Step 3/7 : WORKDIR /data/test ---&gt; Running in c5c969afa0fbRemoving intermediate container c5c969afa0fb ---&gt; 594b22c7a7ecStep 4/7 : RUN touch tmpfile1 ---&gt; Running in a074aa6c9484Removing intermediate container a074aa6c9484 ---&gt; d127444b2188Step 5/7 : COPY [&quot;tmpfile2&quot;,&quot;/data/test/&quot;] ---&gt; 69e842587b9fStep 6/7 : ADD [&quot;test_add.tar.gz&quot;,&quot;/data/test/&quot;] ---&gt; 5d0318483d64Step 7/7 : ENV WELCOME &quot;hello,welcome!&quot; ---&gt; Running in 86c30e33c390Removing intermediate container 86c30e33c390 ---&gt; 9c531ea5e5d5Successfully built 9c531ea5e5d5Successfully tagged test/mybusybox:v1 1234567891011121314# 运行容器，验证镜像内容:[root@linux-node1 test]# docker run -it --rm test/mybusybox:v1/data/test # lstest_add tmpfile1 tmpfile2/data/test # echo $WELCOMEhello,welcome!1. 进入容器，当前目录即为 WORKDIR。如果 WORKDIR 不存在，Docker 会自动为我们创建。2. WORKDIR 中保存了我们希望的文件和目录: - 目录 test_add：由 ADD 指令从 build context 复制的归档文件 test_add.tar.gz，已经自动解压。 - 文件 tmpfile1：由 RUN 指令创建。 - 文件 tmpfile2：由 COPY 指令从 build context 复制。3. ENV 指令定义的环境变量已经生效。 镜像命名的最佳实践 如何在多个 Docker Host 上使用镜像? 123451. 用相同的 Dockerfile 在其他 host 构建镜像。2. 将镜像上传到公共 Registry（比如 Docker Hub），Host 直接下载使用。3. 搭建私有的 Registry 供本地 Host 使用。 为镜像命名 REPOSITORY TAG 实际上一个特定镜像的名字由两部分组成：repository 和 tag , [image name] = [repository]:[tag] 如果执行 docker build 时没有指定 tag，会使用默认值 latest tag 常用于描述镜像的版本信息，可以是任意字符串 latest 其实并没有什么特殊的含义。当没指明镜像 tag 时，Docker 会使用默认值 latest，仅此而已。 虽然 Docker Hub 上很多 repository 将 latest 作为最新稳定版本的别名，但这只是一种约定，而不是强制规定。 所以我们在使用镜像时最好还是避免使用 latest，明确指定某个 tag，比如 httpd:2.3，ubuntu:xenial。 12345[root@linux-node1 test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest/mybusybox v1 9c531ea5e5d5 7 minutes ago 1.22MBgame/centos 7 ea065b022d5b 51 minutes ago 287MBnginx latest f949e7d76d63 2 weeks ago 126MB 多个 tag 可能对应的是同一个镜像 多个 tag 可能对应的是同一个镜像 假设我们现在发布了一个镜像 myimage，版本为 v1.9.1。那么我们可以给镜像打上四个 tag：1.9.1、1.9、1 和 latest。 12345678# 通过 docker tag 命令方便地给镜像打 tagdocker tag myimage-v1.9.1 myimage:1docker tag myimage-v1.9.1 myimage:1.9docker tag myimage-v1.9.1 myimage:1.9.1docker tag myimage-v1.9.1 myimage:latest 过了一段时间，我们发布了 v1.9.2。这时可以打上 1.9.2 的 tag，并将 1.9、1 和 latest 从 v1.9.1 移到 v1.9.2。 1234567docker tag myimage-v1.9.2 myimage:1docker tag myimage-v1.9.2 myimage:1.9docker tag myimage-v1.9.2 myimage:1.9.2docker tag myimage-v1.9.2 myimage:latest 这种 tag 方案使镜像的版本很直观，用户在选择非常灵活： 1234567myimage:1 始终指向 1 这个分支中最新的镜像。myimage:1.9 始终指向 1.9.x 中最新的镜像。myimage:latest 始终指向所有版本中最新的镜像。如果想使用特定版本，可以选择 myimage:1.9.1、myimage:1.9.2 或 myimage:2.0.0。 Dockerfile 的生产实践使用 game/centos:7 镜像为base镜像 搭建 python 运行环境镜像123456789101112131415[root@linux-node1 runtime]# mkdir -p /opt/Game/runtime/python-ssh[root@linux-node1 runtime]# tree /opt/Game//opt/Game/├── app├── runtime│ └── python-ssh└── system ├── centos │ ├── Dockerfile │ └── epel.repo └── test ├── Dockerfile ├── test_add.tar.gz └── tmpfile2 123456789101112131415161718# python + ssh# python运行环境镜像需要安装 python-devel python-pip openssh-clients openssl-devel openssh-server[root@linux-node1 python-ssh]# vim Dockerfile # BASEFROM game/centos:7# WHOMAINTAINER leo 365042337@qq.com# PKGRUN yum install -y python-devel python-pip openssh-clients openssl-devel openssh-server &amp;&amp; yum clean all# FOR SSHDRUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyRUN ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_keyRUN echo &quot;root:222222&quot; | chpasswd 12345678# 构建[root@linux-node1 python-ssh]# docker build -t game/centos7-python-ssh .[root@linux-node1 python-ssh]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgame/centos7-python-ssh latest 9b0a64f83274 14 seconds ago 357MBgame/centos 7 ea065b022d5b 2 hours ago 287MB... 在本地测试 python123456789101112131415161718192021# 测试程序 flask[root@linux-node1 python-ssh]# mkdir -p /opt/Game/app/shop-api[root@linux-node1 python-ssh]# cd /opt/Game/app/shop-api[root@linux-node1 shop-api]# vim app.pyfrom flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello(): return &apos;Hello World!&apos; if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, debug=True)# 安装python,运行测试程序yum install python-pip -ypip install flaskpython app.py访问:http://10.0.0.100:5000/ 添加python 服务的依赖文件1234# python pip 将会去安装包[root@linux-node1 shop-api]# vim requirements.txtflaskrequests supervisor 管理进程文件1234567891011121314151617181920212223242526272829303132333435363738注意:1. 照着案例文件写 案例文件:2. 在配置文件中的 必须配置为前台启动 ***** supervisorctl 必须要在前提启动nodaemon=true ; (start in foreground if true;default false)# 本地测试[root@linux-node1 shop-api]# yum install supervisor# 定义了两个服务 启动/opt/app.py 和 sshd[root@linux-node1 shop-api]# vim app-supervisor.ini [program:shop-api]command=/usr/bin/python2.7 /opt/app.pyprocess_name=%(program_name)sautostart=trueuser=wwwstdout_logfile=/tmp/app.logstderr_logfile=/tmp/app.error[program:sshd]command=/usr/sbin/sshd -Dprocess_name=%(program_name)sautostart=true# 将配置文件放到本地去测试执行# 添加本地www账户[root@linux-node1 shop-api]# cp app-supervisor.ini /etc/supervisord.d/[root@linux-node1 shop-api]# cp app.py /opt/[root@linux-node1 shop-api]# useradd -s /sbin/nologin -M www# 测试执行[root@linux-node1 shop-api]# supervisord -c /etc/supervisord.conf[root@linux-node1 ~]# supervisorctl statusshop-api RUNNING pid 3975, uptime 0:00:43sshd FATAL Exited too quickly (process log may have details)# 本地的sshd是存在的,shop-api正常即可,后续还需要继续学习supervisor的配置 shop-api 的Dockerfile12341. 添加启动用户2. pip安装依赖3. supervisord.conf 如果有变更也要传4. CMD 需要启动supervisord服务 12345678910111213141516171819202122232425[root@linux-node1 shop-api]# vim Dockerfile# BASE IMAGESFROM game/centos7-python-ssh# WHOMAINTAINER leo 365042337@qq.com# USER ADDRUN useradd -s /sbin/nologin -M www# ADD FILEADD app.py /opt/app.pyADD app-supervisor.ini /etc/supervisord.d/ADD requirements.txt /opt/ADD supervisord.conf /etc/supervisord.conf# PIPRUN /usr/bin/pip2.7 install -r /opt/requirements.txt# PORTEXPOSE 22 5000# CMDCMD [&quot;/usr/bin/supervisord&quot;,&quot;-c&quot;,&quot;/etc/supervisord.conf&quot;] 12345678[root@linux-node1 shop-api]# docker build -t game/shop-api .[root@linux-node1 shop-api]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgame/shop-api latest 950dfdaa7360 23 seconds ago 365MBgame/centos7-python-ssh latest 9b0a64f83274 3 hours ago 357MBgame/centos 7 ea065b022d5b 4 hours ago 287MB... 1234[root@linux-node1 shop-api]# docker run -d -p 80:5000 -p 8022:22 --name myshop-ssh game/shop-api [root@linux-node1 .ssh]# ssh 10.0.0.100 -p8022浏览器访问: http://10.0.0.100/ 需要理解123456789101112131415161718192021222324252627282930313233341. 如果没有起来的测试步骤- 在构建一个镜像 不要执行CMD[root@linux-node1 shop-api]# pwd/opt/docker/app/shop-api# CMD# CMD [&quot;/usr/bin/supervisord&quot;,&quot;-c&quot;,&quot;/etc/supervisord.conf&quot;] - 进到容器里查看服务[root@linux-node1 shop-api]# docker build -t oldboy/shop-api:v2 .[root@linux-node1 shop-api]# docker run -it --name shop-api-v2 -p 88:5000 -p 8022:22 oldboy/shop-api:v2 /bin/bash[root@3f1e55eb826d /]# supervisord -c /etc/supervisord.conf [root@3f1e55eb826d /]# supervisorctl statusshop-api RUNNING pid 19, uptime 0:00:03sshd RUNNING pid 18, uptime 0:00:032. 在配置文件中的 必须配置为前台启动 改好之后重新构建nodaemon=true ; (start in foreground if true;default false) 3. 分层的好处 1. 更快速的构建 1. 系统 2. 运行环境 3. app 2. 使用supervisor启动和管理进程 3. python 的依赖requirements.txt 4. 先尝试 把应用 用docker跑起来 再去写Dockerfile 5. 去看开源项目的 Dockerfile 6. 生产 之前一定先到虚拟机或者物理机跑一遍,然后再去 把配置文件copy过来 再去写 dockerfile]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07 Docker 手动构建镜像]]></title>
    <url>%2F2019%2F10%2F11%2Fwrite-images%2F</url>
    <content type="text"><![CDATA[123参考:https://www.cnblogs.com/wangxu01/articles/11325388.htmlhttps://www.cnblogs.com/luoahong/p/10273477.html 为什么要构建镜像 找不到现成的镜像,比如自己开发的应用程序,生产做自己的镜像 需要在镜像中加入特定的功能,比如官方镜像几乎都不提供 ssh。 两种构建镜像的方法: 手动构建镜像 docker commit 命令 Dockerfile 构建镜像文件 手动构建镜像步骤 启动基础容器安,装软件服务。 将安装好服务的容器commit提交为镜像。 启动新容器来测试新提交的镜像。 制作支持ssh远程登录的docker镜像启动基础容器,安装软件服务目的 : 以官方镜像为基础在这个基础之上 “做自己的镜像” 12345678# --privileged=true，该参数在docker容器运行时，让系统拥有真正的root权限# /usr/sbin/init：初始容器里的CENTOS，用于启动dbus-daemon。[root@linux-node1 ~]# docker run --privileged=true -d -p 1022:22 --name mycentos centos:7 /usr/sbin/init[root@linux-node1 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES017da954e8d4 centos:7 &quot;/usr/sbin/init&quot; 11 seconds ago Up 10 seconds 0.0.0.0:1022-&gt;22/tcp mycentos 安装软件 openssh-server12345678910111213141516171819[root@linux-node1 ~]# ./docker_in.sh mycentos[root@017da954e8d4 /]# yum install openssh-server -y[root@017da954e8d4 /]# systemctl start sshd[root@017da954e8d4 /]# systemctl status sshd● sshd.service - OpenSSH server daemon Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled) Active: active (running) since Fri 2019-10-11 08:37:27 UTC; 6s ago Docs: man:sshd(8) man:sshd_config(5) Main PID: 200 (sshd) CGroup: /docker/017da954e8d47f86c0db7116fd90b0a7ee5da7e1150ea1a89442d1c59cb6d7ec/system.slice/sshd.service └─200 /usr/sbin/sshd -D ‣ 200 /usr/sbin/sshd -DOct 11 08:37:27 017da954e8d4 systemd[1]: Starting OpenSSH server daemon...Oct 11 08:37:27 017da954e8d4 sshd[200]: Server listening on 0.0.0.0 port 22.Oct 11 08:37:27 017da954e8d4 sshd[200]: Server listening on :: port 22.Oct 11 08:37:27 017da954e8d4 systemd[1]: Started OpenSSH server daemon. 1234567[root@017da954e8d4 /]# yum install net-tools -y[root@017da954e8d4 /]# netstat -tnlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 200/sshd tcp6 0 0 :::22 :::* LISTEN 200/sshd 设置远程登录密码123[root@017da954e8d4 /]# echo 123456|passwd --stdin rootChanging password for user root.passwd: all authentication tokens updated successfully. 测试远程访问1234# 在创建容器的时候 我们绑定了本地的 1022端口哦~[root@linux-node1 tools]# ssh 10.0.0.100 -p1022root@10.0.0.100&apos;s password: Last login: Fri Oct 11 08:43:05 2019 from 10.0.0.100 commit 提交为镜像12345678910# 提交本地镜像# commit -m &quot;centos7-ssh&quot; # 添加注释# mycentos # 容器名# test/mycentos-7-ssh # 仓库名称/镜像:版本 不加版本号就是latest 最后的版本[root@linux-node1 tools]# docker commit -m &quot;centos7-ssh&quot; mycentos test/mycentos-7-ssh[root@linux-node1 tools]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest/mycentos-7-ssh latest db3993e49556 About a minute ago 278MB... 使用新镜像 启动新容器 注意事项: 记得一定要在启动容器的后面加上 /usr/sbin/sshd -D 不加默认是 /bin/bash 1[root@linux-node1 tools]# docker run -d --name mycentos7 -p 2022:22 test/mycentos-7-ssh /usr/sbin/sshd -D 连接测试 20221234[root@linux-node1 ~]# ssh 10.0.0.100 -p 2022root@10.0.0.100&apos;s password: Last login: Fri Oct 11 09:01:24 2019 from 10.0.0.100[root@33b52a8d8adb ~]# 基于centos7的ssh+Nginx镜像启动基础容器1[root@linux-node1 ~]# docker run --privileged=true -d -p 80:80 --name centos-7-ssh-nginx centos:7 /usr/sbin/init 配置yum源安装 Nginx和sshd1234567891011121314[root@linux-node1 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3d804a17f13b centos:7 &quot;/usr/sbin/init&quot; 34 seconds ago Up 33 seconds 0.0.0.0:80-&gt;80/tcp centos-7-ssh-nginx[root@linux-node1 ~]# ./docker_in.sh 3d804a17f13b[root@3d804a17f13b /]# cd /etc/yum.repos.d/[root@3d804a17f13b yum.repos.d]# mkdir bak ; mv *.repo bak/[root@3d804a17f13b yum.repos.d]# curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo[root@3d804a17f13b yum.repos.d]# rpm -ivh https://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm[root@3d804a17f13b yum.repos.d]# lsbak CentOS-Base.repo epel.repo epel-testing.repo 1234yum install net-tools -y yum install nginx -yyum install openssh-server -yecho 123456|passwd --stdin root 启动服务123456789[root@3d804a17f13b yum.repos.d]# systemctl start nginx[root@3d804a17f13b yum.repos.d]# systemctl start sshd[root@3d804a17f13b yum.repos.d]# netstat -lntpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 292/nginx: master p tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 319/sshd tcp6 0 0 :::80 :::* LISTEN 292/nginx: master p tcp6 0 0 :::22 :::* LISTEN 319/sshd 1测试web访问 http://10.0.0.100/ 编写容器启动脚本12345678910[root@361b22a52b62 /]# vi init.sh#!/bin/bashsource /etc/profilesystemctl start nginxsystemctl status nginx &gt;&gt; /tmp/nginx.logsystemctl start sshd[root@361b22a52b62 /]# chmod 755 /init.sh commit提交为镜像123456[root@linux-node1 ~]# docker commit -m &quot;My CentOS7-ssh-nginx&quot; centos-7-ssh-nginx test/mycentos-7-ssh-nginx:v1[root@linux-node1 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest/mycentos-7-ssh-nginx v1 60ed5f7aebf2 3 seconds ago 377MB... 启动新容器1[root@linux-node1 ~]# docker run --privileged=true -d -p 8080:80 -p 2222:22 --name we1 test/mycentos-7-ssh-nginx:v1 /usr/sbin/init init.sh 123# 如果服务无法启动 还是需要之前的超管权限步骤[root@05068b99ded6 tmp]# systemctl start nginxFailed to get D-Bus connection: Operation not permitted]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06 Docker 数据管理]]></title>
    <url>%2F2019%2F10%2F11%2Fdocker-base06%2F</url>
    <content type="text"><![CDATA[生产环境中使用Docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。 容器中管理数据主要有两种方式: 123456数据卷（Data Volumes）： - 容器内数据直接映射到本地主机环境； - 如何在容器内创建数据卷，并且把本地的目录或文件挂载到容器内的数据卷中。数据卷容器（Data Volume Containers）： - 使用特定容器维护数据卷。 - 如何使用数据卷容器在容器和主机、容器和容器之间共享数据，并实现数据的备份和恢复。 数据卷的使用 数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似Linux 的mount挂载 12345数据卷的特性: - 数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便； - 对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作； - 对数据卷的更新不会影响镜像，解耦了应用和数据； - 卷会一直存在，直到没有容器使用，可以安全地卸载它。 创建数据卷 在用docker run 命令的时候，使用 -v 标记可以在容器内创建一个数据卷。多次重复使用 -v 标记可以创建多个数据卷。 用户可以将一些程序或数据放到本地目录中，然后在容器内运行和使用。 另外，本地目录的路径必须是绝对路径，如果目录不存在,Docker会自动创建。 12-v /data -v src:dst # 挂载本地目录到容器上 123456789101112131415161718192021222324252627282930311. 准备好host挂载目录和里面的文件[root@linux-node1 tools]# mkdir -p /data/tools[root@linux-node1 tools]# ls -ltotal 232-rw-r--r--. 1 root root 15329 Nov 8 2018 2000.png-rw-r--r--. 1 root root 51562 Nov 8 2018 21.js-rw-r--r--. 1 root root 254 Nov 8 2018 icon.pngdrwxr-xr-x. 2 root root 96 Nov 8 2018 img-rw-r--r--. 1 root root 3049 Nov 8 2018 index.html-rw-r--r--. 1 root root 63008 Nov 8 2018 sound1.mp3-rw-r--r--. 1 root root 91725 Oct 11 10:22 xiaoniaofeifei.zip2. 开始挂载[root@linux-node1 tools]# docker run -it --name mycentos -v /data/tools/:/data/tools centos:7[root@ec7228193572 /]# cd /data/tools/[root@ec7228193572 tools]# ls2000.png 21.js icon.png img index.html sound1.mp3 xiaoniaofeifei.zip3. 测试host添加一个文件[root@linux-node1 tools]# echo &quot;hello leo&quot; &gt;&gt; leo.html[root@ec7228193572 tools]# ls -l...-rw-r--r--. 1 root root 10 Oct 11 02:28 leo.html...4. 测试在容器上删除该文件[root@ec7228193572 tools]# rm -f leo.html [root@linux-node1 tools]# ls -l leo.html # 已删除5. 如果我们删除了本地的tools 那么容器上的tools里面的数据将不存在[root@linux-node1 data]# rm -rf tools/ 很方便的在你进行数据修改的时候，直接修改本地文件就行了，容器直接就会同步了 提前都建好目录，再挂载上去，容器down没关系，数据都在指定的目录下 1234567891. docker 挂载数据卷的默认权限是读写(rw) ,我们也可以改权限[root@linux-node1 data]# docker run -it --name mycentos2 -v /data/tools/:/data/tools/:ro centos:7[root@d45deb896445 /]# cd /data/tools/[root@d45deb896445 tools]# touch hehetouch: cannot touch &apos;hehe&apos;: Read-only file system2. 也可以只挂载本地主机的单个文件到容器中作为数据卷(强烈不推荐，生产也很少用，可忽略)[root@linux-node1 ~]# docker run --rm -it -v /root/.bash_history:/.bash_history centos:7 /bin/bashroot@3ac18de44b62:/# cat .bash_history Docker 安装 Nginx 并使用数据卷管理拉取官方镜像1.16.11[root@linux-node1 data]# docker pull nginx:1.16.1 查看镜像123[root@linux-node1 data]# docker images nginx:1.16.1REPOSITORY TAG IMAGE ID CREATED SIZEnginx 1.16.1 0dac5b41d811 4 weeks ago 126MB 使用 NGINX 默认的配置来启动一个 Nginx 容器实例12345[root@linux-node1 data]# docker run -d -p 8000:80 --name web1 nginx:1.16.1- --name: 容器名web1- -p: 端口映射80- -d: 容器在后台运行- nginx: 123[root@linux-node1 data]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa41b970bfceb nginx1.16.1 &quot;nginx -g &apos;daemon of…&quot; 5 seconds ago Up 3 seconds 0.0.0.0:80-&gt;80/tcp web1 在浏览器中打开 http://10.0.0.100:8000/ 使用容器卷管理 nginx121. 创建目录[root@linux-node1 data]# mkdir -p /data/nginx/&#123;log,conf,www&#125; 123456782. 拷贝容器内 Nginx 默认配置文件到本地当前目录下的 conf 目录[root@linux-node1 data]# docker cp web1:/etc/nginx/nginx.conf /data/nginx/conf[root@linux-node1 data]# cd /data/nginx/-rw-r--r--. 1 root root 643 Sep 24 22:49 nginx.conf - www: 目录将映射为 nginx 容器配置的虚拟目录。 - logs: 目录将映射为 nginx 容器的日志目录。 - conf: 目录里的配置文件将映射为 nginx 容器的配置文件。 1234563. 启动挂载目录[root@linux-node1 nginx]# docker run -d -p 80:80 --name web2 -v /data/nginx/conf/nginx.conf:/etc/nginx/conf/nginx.conf -v /data/nginx/www:/usr/share/nginx/html -v /data/nginx/log/:/var/log/nginx nginx1.16.1- nginx文件 /data/nginx/conf/nginx.conf --&gt; /etc/nginx/conf/nginx.conf- nginx目录 /data/nginx/www --&gt; /usr/share/nginx/html- nginx日志 /data/nginx/log/ --&gt; /var/log/nginx 123456789104. 进入host的首页目录 上传测试文件[root@linux-node1 www]# ls -ltotal 232-rw-r--r--. 1 root root 15329 Nov 8 2018 2000.png-rw-r--r--. 1 root root 51562 Nov 8 2018 21.js-rw-r--r--. 1 root root 254 Nov 8 2018 icon.pngdrwxr-xr-x. 2 root root 96 Nov 8 2018 img-rw-r--r--. 1 root root 3049 Nov 8 2018 index.html-rw-r--r--. 1 root root 63008 Nov 8 2018 sound1.mp3-rw-r--r--. 1 root root 91725 Oct 11 11:16 xiaoniaofeifei.zip 15. 测试访问页面 123456786. 相关命令- 如果要重新载入 NGINX 可以使用以下命令发送 HUP 信号到容器：docker kill -s HUP container-name[root@linux-node1 www]# docker kill -s HUP web2- 重启 NGINX 容器命令：docker restart container-name[root@linux-node1 www]# docker restart web2 1234567. 查看日志 # 可以去看host的log目录下的日志[root@linux-node1 log]# ls -ltotal 8-rw-r--r--. 1 root root 3224 Oct 11 11:20 access.log-rw-r--r--. 1 root root 732 Oct 11 11:20 error.log 测试修改代码 修改host上首页的title标题 12[root@linux-node1 www]# vim index.html &lt;title&gt;docker-nginx-test&lt;/title&gt; 多端口映射 基于多端口多站点 80是主页，81端口是游戏，在host上写一个81的配置文件挂载上去 12345678910111213[root@linux-node1 conf]# pwd/data/nginx/conf[root@linux-node1 conf]# cat 81.game.confserver&#123; root /opt; listen 81;&#125;[root@linux-node1 conf]# ls -ltotal 8-rw-r--r--. 1 root root 40 Oct 11 11:39 81.game.conf-rw-r--r--. 1 root root 643 Sep 24 22:49 nginx.conf 123456789# 启动容器并挂载配置# 挂载81的配置文件到 /etc/nginx/conf.d/下让主配置文件iincludedocker run -d -p 80:80 -p 81:81 --name web3-v /data/nginx/conf/81.game.conf:/etc/nginx/conf.d/81.game.conf-v /data/nginx/www/:/opt -v /data/nginx/log/:/var/log/nginx nginx:1.16.1[root@linux-node1 conf]# docker run -d -p 80:80 -p 81:81 --name web3 -v /data/nginx/conf/81.game.conf:/etc/nginx/conf.d/81.game.conf -v /data/nginx/www/:/opt -v /data/nginx/log/:/var/log/nginx nginx:1.16.1 12345# 日志查看[root@linux-node1 log]# tailf access.log 10.0.0.1 - - [11/Oct/2019:04:00:40 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot; &quot;-&quot;10.0.0.1 - - [11/Oct/2019:04:00:41 +0000] &quot;GET /img/p2l.jpg HTTP/1.1&quot; 404 555 &quot;http://10.0.0.100:81/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot; &quot;-&quot; 数据卷容器 如果数据在需要在多个容器之间共享，最简单的方式是使用数据卷容器。 数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。 不管数据卷容器是否运行 都可以访问到 –volumes-from volumes-from 启动一个容器挂载一个目录,其他的容器都不用挂载了,直接–volumes-from 这个容器 12345678910111213141516[root@linux-node1 ~]# docker run -it --name volume_test -v /data/tools/:/data/tools centos:7# 新建的容器 --volumes-from volume_test# 即使数据卷容器没有运行,数据也可以被访问[root@linux-node1 ~]# docker run -it --name game_test --volumes-from volume_test centos:7 /bin/bash[root@9b7b28b2f5a5 /]# cd /data/tools/[root@9b7b28b2f5a5 tools]# lsweb1.tar[root@9b7b28b2f5a5 tools]# touch game_test.log[root@linux-node1 tools]# lsgame_test.log web1.tar# 有些数据在多个容器之间共享,就可以使用数据卷容器# 单个容器挂载 然后其他的都用容器卷# 只要有容器卷使用这个目录就无法删除 总结 现在我们有数据层（镜像层和容器层）和 volume 都可以用来存放数据，具体使用的时候要怎样选择呢？ 考虑下面几个场景： 1234567- Database 软件 vs Database 数据- Web 应用 vs 应用产生的日志- 数据分析软件 vs input/output 数据- Apache Server vs 静态 HTML 文件 相信大家会做出这样的选择： 123前者放在数据层中。因为这部分内容是无状态的，应该作为镜像的一部分。后者放在 Data Volume 中。这是需要持久化的数据，并且应该与镜像分开存放。 如何使用 12345-v /data/nginx/www:/usr/share/nginx/html这与 linux mount 命令的行为是一致的-v 的格式为 &lt;host path&gt;:&lt;container path&gt;。/usr/share/nginx/html 就是 nginx 存放静态文件的地方。原有数据会被隐藏起来，取而代之的是 /data/nginx/www 中的数据 1234即使容器销毁,数据也还在，mount的是 host 文件系统中的数据，只是借给容器用用，哪能随便就删了啊mount 时还可以指定数据的读写权限，默认是可读可写，可指定为只读除了mount 目录，还可以单独指定一个文件使用mount 单个文件的场景是：只需要向容器添加文件，不希望覆盖整个目录。 1234使用场景:1. 可以将源代码目录 mount 到容器中，在 host 中修改代码就能看到应用的实时效果2. mysql 容器的数据放在 共享目录 里，这样 host 可以方便地备份和迁移数据3. 实现了容器与 host 的解耦]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05 Docker 容器的端口映射]]></title>
    <url>%2F2019%2F10%2F10%2Fdocker-base05%2F</url>
    <content type="text"><![CDATA[容器端口映射 docker的端口映射，能保证在外部网络 访问 同一设备上不同容器时候 不会因为端口问题产生冲突。 docker 可将容器对外提供服务的端口映射到 host 的某个端口，外网通过该端口访问容器。 容器启动时通过-p参数映射端口： 12345-p hostPort:containerPort # 0.0.0.0:80-p ip:hostPort:containerPort # 指定宿主机IP地址,例如192.168.0.136:80,多个容器都想使用80端口，添加多个IP-p ip::containerPort # 随机端口 ，32768端口，内核参数决定的net.ipv4.ip_local_port_range = 32768 60999-p hostPort:containerPort:udp # udp -p 81:80 –p 443:443 # 指定多个 指定端口1234[root@linux-node1 ~]# docker run -d -p 80:80 --name web1 nginx:1.16.18eee8d6ffc1580a2f80e4472ed51990af6c525a1d2734cac216f07b9ed816650[root@linux-node1 ~]# netstat -tnlp|grep 80tcp6 0 0 :::80 :::* LISTEN 1774/docker-proxy 多端口绑定123456[root@linux-node1 ~]# docker run -d -p 443:443 -p 82:80 --name web2 nginx:1.16.1[root@linux-node1 ~]# netstat -tnlp|grep dockertcp6 0 0 :::80 :::* LISTEN 1774/docker-proxy tcp6 0 0 :::82 :::* LISTEN 1969/docker-proxy tcp6 0 0 :::443 :::* LISTEN 1957/docker-proxy 随机[root@linux-node1 ~]# docker run -d -P –name web3 nginx:1.16.1 123456[root@linux-node1 ~]# netstat -tnlp|grep dockertcp6 0 0 :::5000 :::* LISTEN 2397/docker-proxy tcp6 0 0 :::80 :::* LISTEN 1774/docker-proxy tcp6 0 0 :::82 :::* LISTEN 1969/docker-proxy tcp6 0 0 :::443 :::* LISTEN 1957/docker-proxy tcp6 0 0 :::32768 :::* LISTEN 2517/docker-proxy 映射到指定的协议 tcp 或 udp1docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04 Docker 容器管理]]></title>
    <url>%2F2019%2F10%2F10%2Fdocker-base03%2F</url>
    <content type="text"><![CDATA[启动容器 docker run docker 的容器是镜像的一个运行实例。 docker 镜像是只读文件，而容器则带有运行时的可读写层，而且容器中的应用进程处于运行状态。 docker run ：创建一个新的容器并运行一个命令 123456789101112docker run [OPTIONS] IMAGE [COMMAND] [ARG...]-t ：打开一个终端，像使用交换机一样使用容器-i：交互式访问--name：容器名字--network：指定网络--rm：容器一停，自动删除-d：剥离与当前终端的关系；否则会一直占据着终端-p：端口映射，将容器内服务的端口映射在宿主机的指定端口-p &lt;container port&gt;-p &lt;hostport&gt;:&lt;container port&gt;-p &lt;hostip&gt;:&lt;hostport&gt;:&lt;container port&gt; 123456789101112# 如果不执行命令,那么容器使用的镜像名 在最后# 如果docker run 本地没有镜像，那么他会帮你pull下来 1. 下载 centos:7镜像[root@linux-node1 ~]# docker pull centos:72. 运行centos:7 镜像[root@linux-node1 ~]# docker run -it --rm --name mycentos centos:7 /bin/bash[root@593621d0b6cc /]# cat /etc/redhat-release CentOS Linux release 7.6.1810 (Core) [root@593621d0b6cc /]# uname -r3.10.0-327.el7.x86_64 查看运行的容器 docker ps123[root@linux-node1 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd9ba7d5f9d22 centos:7 &quot;/bin/bash&quot; 8 seconds ago Up 7 seconds mycentos 显示所有 -a123456789# 现在执行exit 就退出bash 容器也跟着退出了,因为进程结束了,容器也结束了[root@linux-node1 ~]# docker run -it --name mycentos centos:7 /bin/bash[root@0dc9c214c2c9 /]# exitexit[root@linux-node1 ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0dc9c214c2c9 centos:7 &quot;/bin/bash&quot; 5 seconds ago Exited (0) 2 seconds ago mycentos 显示ID -q12[root@linux-node1 ~]# docker ps -aq0dc9c214c2c9 启动容器 docker start12345678910[root@linux-node1 ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0dc9c214c2c9 centos:7 &quot;/bin/bash&quot; 5 seconds ago Exited (0) 2 seconds ago mycentos[root@linux-node1 ~]# docker start mycentosmycentos[root@linux-node1 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0dc9c214c2c9 centos:7 &quot;/bin/bash&quot; 11 minutes ago Up 2 seconds mycentos 查看容器的详细信息 docker inspect1234567# 查看所有[root@linux-node1 ~]# docker inspect mycentos[root@linux-node1 ~]# docker inspect mycentos|grep IPAddress# 查看容器的pid 可以用于nsenter进入容器[root@linux-node1 ~]# docker inspect -f &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; 0dc9c214c2c92525 查看容器运行情况 docker top123[root@linux-node1 ~]# docker top 0dc9c214c2c9UID PID PPID C STIME TTY TIME CMDroot 2525 2508 0 10:30 pts/0 00:00:00 /bin/bas 停止容器 docker stop12345678910[root@linux-node1 ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0dc9c214c2c9 centos:7 &quot;/bin/bash&quot; 27 minutes ago Up 16 minutes mycentos[root@linux-node1 ~]# docker stop mycentomycentos[root@linux-node1 ~]# docker ps -aCONTAINER ID IMGE COMMAND CREATED STATUS PORTS NAMES0dc9c214c2c9 centos:7 &quot;/bin/bash&quot; 27 minutes ago Exited (137) 4 seconds ago mycento 删除容器 docker rm先关闭容器，再删除容器 123[root@linux-node1 ~]# docker stop mycentos[root@linux-node1 ~]# docker rm mycentos[root@linux-node1 ~]# docker ps -a 12# 强制删除容器[root@linux-node1 ~]# docker rm -f mycentos 批量删除容器生产环境谨慎使用 12345# 只删除关闭状态的[root@linux-node1 ~]# docker rm $(docker ps -qa)# #强制删除全部，包括启动中的[root@linux-node1 ~]# docker rm -f $(docker ps -aq) 进入容器 进入容器的三种方法:attach(不推荐)、exec、 123* 和虚拟机不同 你不能进去 再执行新的东西,因为docker的理念和虚拟机不同* docker的理念是 再创建一个容器 也不能修改一个容器 * 不可变基础环境 --&gt; 环境必须一致 attach 进入到存活的容器中 如果再开一个窗口进来，操作是同步的，就像远程控制，单用户模式 exit 就会推出, 生产不会使用这个命令 1234[root@linux-node1 ~]# docker start mycentosmycentos[root@linux-node1 ~]# docker attach mycentos[root@45fce97e86cc /]# exec 对运行的容器执行指定命令 不想进入,让容器执行命令并返回结果 1234567 -d：在后台运行命令 -e：设置环境变量 -i：交互式 -t：打开一个终端 -u：用户名或UID暂时退出容器：ctrl+p，ctrl+q回到容器：docker attach id或name 1234[root@linux-node1 ~]# docker exec mycentos ps -auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.1 0.0 11824 1700 pts/0 Ss+ 03:02 0:00 /bin/bashroot 14 0.0 0.0 51744 1724 ? Rs 03:02 0:00 ps -aux 退出并不停止 docker crtl 先p 再q 1234567# 交互式进入容器 -it[root@linux-node1 ~]# docker exec -it mycentos /bin/bash# 如果不想退出 就结束容器&gt;&gt;&gt; crtl 先p 再q[root@linux-node1 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES45fce97e86cc centos:7 &quot;/bin/bash&quot; 6 minutes ago Up 3 minutes mycentos nsenter nsenter 生产使用 即使exit 也不会关闭容器 12345678910111213141516171819202122232425262728293031323334353637381. 安装[root@linux-node1 ~]# yum install -y util-linux - nsenter : ns (namespace) 进入到命名空间 - docker 的实现 : Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心命名空间（namespaces） - 需要容器进程的pid2. 获取容器的PID,容器需要是启动状态,否则获取为0[root@linux-node1 ~]# docker inspect -f &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; mycentos36653. nsenter 进入[root@linux-node1 ~]# nsenter -t 3665 -m -u -i -n -p /bin/bash[root@45fce97e86cc /]# ps -auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 11824 1700 pts/0 Ss+ 03:02 0:00 /bin/bashroot 24 0.0 0.0 11824 1696 pts/1 Ss+ 03:04 0:00 /bin/bashroot 118 0.0 0.0 15256 2020 pts/0 S 03:20 0:00 /bin/bashroot 127 0.0 0.0 55176 1872 pts/0 R+ 03:20 0:00 ps -aux4. 进入容器脚本[root@linux-node1 ~]# vim docker_in.sh #!/bin/bash# Use nsenter to access dockerdocker_in()&#123; NAME_ID=$1 PID=$(docker inspect -f &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; $NAME_ID) nsenter -t $PID -m -u -i -n -p /bin/bash echo $PID&#125;docker_in $15. 脚本权限并执行[root@linux-node1 ~]# chmod +x docker_in.sh [root@linux-node1 ~]# ./docker_in.sh mycentos[root@45fce97e86cc /]# 查看日志 docker logs12345678910111213141516171. 启动一个nginx:1.4的容器# 根据镜像名称（tag指定版本）拉取镜像# alpine版本：构建容器小镜像的发型版本[root@linux-node1 ~]# docker pull nginx:1.14-alpine2. 启动nginx容器[root@linux-node1 ~]# docker run --name web1 -d -p 80:80 nginx:1.14-alpine16ced725c5f998f7a59b98731ba74305f2e3adc96449410ecfef20b8c51749443. 浏览器访问访问 http://10.0.0.1004. curl访问[root@linux-node1 ~]# docker logs web15. 查看日志[root@linux-node1 ~]# docker logs web1 copy容器文件 docker cp 该命令支持在容器和主机之间复制文件。 12-a， -archive： 打包模式， 复制⽂件会带有原始的uid/gid信息；-L， -follow-link： 跟随软连接。 当原路径为软连接时， 默认只复制链接信息， 使⽤该选项会复制链接的⽬标内容。 123456# 服务器向容器copy文件[root@linux-node1 ~]# docker cp /root/docker_in.sh mycentos:/tmp[root@linux-node1 ~]# ./docker_in.sh mycentos[root@45fce97e86cc /]# cd /tmp/[root@45fce97e86cc tmp]# lsdocker_in.sh ks-script-rnBCJB yum.log 123456789# copy容器的文件下来[root@linux-node1 ~]# docker cp web1:/etc/nginx/nginx.conf .[root@linux-node1 ~]# ls -ltotal 126796-rw-------. 1 root root 1239 Sep 30 17:27 anaconda-ks.cfg-rwxr-xr-x. 1 root root 196 Oct 9 14:01 docker_in.sh-rw-------. 1 root root 129824768 Oct 10 08:34 nginx:1.16.tar-rw-rw-r--. 1 root root 643 Apr 10 2019 nginx.co 查看端口映射 docker port12[root@linux-node1 ~]# docker port web180/tcp -&gt; 0.0.0.0:80 容器的导入和导出导出容器1234# 导出后的容器就可以直接复制到其他机器上导入运行了[root@linux-node1 ~]# docker export -o web1.tar web1[root@linux-node1 ~]# ls -lh web1.tar -rw-------. 1 root root 17M Oct 10 11:46 web1.tar 导入容器1234567[root@linux-node1 ~]# docker import web1.tar test/nginx:1.6.testsha256:482793b910f56b65c0dbb36c4424cca923765ecd3d052c30a0db70c185bd6571[root@linux-node1 ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES16ced725c5f9 nginx:1.14-alpine &quot;nginx -g &apos;daemon of…&quot; 15 minutes ago Up 15 minutes 0.0.0.0:80-&gt;80/tcp web145fce97e86cc centos:7 &quot;/bin/bash&quot; 47 minutes ago Up 45 minutes mycentos 总结容器的使用操作 docker run 参数 镜像名 执行命令 进入容器的三种方 一图总结对容器的操作命令:]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 Docker 镜像管理]]></title>
    <url>%2F2019%2F10%2F09%2Fdocker-base02%2F</url>
    <content type="text"><![CDATA[搜索镜像 docker search docker search : 从Docker Hub查找镜像 OPTIONS说明： 12345--automated :只列出 automated build类型的镜像；--no-trunc :显示完整的镜像描述；-s :列出收藏数不小于指定值的镜像。 搜索所有nginx相关的镜像 12345[root@linux-node1 ~]# docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 12036 [OK] ... 搜索结果解释 123456789NAME:镜像名称DESCRIPTION:镜像说明OFFICIAL:是否docker官方发布STARS:点赞数量AUTOMATED:是否是自动构建的 获取镜像 docker pull docker pull : 从镜像仓库中拉取或者更新指定镜像 1234567891011# 不指定版本默认为最新版，只写名字默认在官方拉取[root@linux-node1 docker]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxb8f262c62ec6: Pull complete e9218e8f93b1: Pull complete 7acba7289aa3: Pull complete Digest: sha256:aeded0f2a861747f43a01cf1018cf9efe2bdd02afd57d2b11fcc7fcadc16ccd1Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest 12345678910# 拉取指定版本[root@linux-node1 docker]# docker pull nginx:1.16.11.16.1: Pulling from library/nginxb8f262c62ec6: Already exists 00b0a9251451: Pull complete 7cc4a8bdb72c: Pull complete Digest: sha256:0d0af9bc6ca2db780b532a522a885bef7fcaddd52d11817fc4cb6a3ead3eacc0Status: Downloaded newer image for nginx:1.16.1docker.io/library/nginx:1.16.1 查看镜像 docker images docker images : 列出本地镜像 OPTIONS说明： 1234567891011-a :列出本地所有的镜像；--digests :显示镜像的摘要信息；-f :显示满足条件的镜像；--format :指定返回值的模板文件；--no-trunc :显示完整的镜像信息；-q :只显示镜像ID。 1234[root@linux-node1 docker]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f949e7d76d63 2 weeks ago 126MBnginx 1.16.1 0dac5b41d811 3 weeks ago 126MB 123456789REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小 导出镜像 docker image save123[root@linux-node1 ~]# docker save -o nginx:1.16.tar nginx:1.16.1[root@linux-node1 ~]# lsanaconda-ks.cfg docker_in.sh nginx:1.16.tar 删除镜像 docker rmi12345678910111213141516171819# docker rmi IMAGE[IMAGE...] IMAGE可以为标签或ID# 当该镜像存在容器时，不能删除镜像，但可以加上 -f 选项强制删除，同时也删除容器。[root@linux-node1 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f949e7d76d63 2 weeks ago 126MBnginx 1.16.1 0dac5b41d811 3 weeks ago 126MB[root@linux-node1 ~]# docker rmi 0dac5b41d811Untagged: nginx:1.16.1Untagged: nginx@sha256:0d0af9bc6ca2db780b532a522a885bef7fcaddd52d11817fc4cb6a3ead3eacc0Deleted: sha256:0dac5b41d811ca6e1bfe68d31bec5fb1f5c37485b741674619a1a2a3dec5cc0eDeleted: sha256:e9aa30f728ac61d63293f77283681af6d7191aa9bd2326ce3f56839bbf4aa001Deleted: sha256:c32f482f1fd81bc84657ff0fb85a0a62ab3223f835875930e1e9658f57768c2e[root@linux-node1 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f949e7d76d63 2 weeks ago 126MB 清理镜像 docker prune prune 命令用来删除不再使用的 docker 对象。 123456789101112131415161718# 生产环境要谨慎使用# 删除所有未被 tag 标记和未被容器使用的镜像:docker image prune# 删除所有未被容器使用的镜像:docker image prune -a# 删除所有停止运行的容器:docker container prune# 删除所有未被挂载的卷:docker volume prune# 删除所有网络:docker network prune# 删除 docker 所有资源:docker system prune 导入镜像 docker image load123456789[root@linux-node1 ~]# docker load --input nginx\:1.16.tar 2db44bce66cd: Loading layer [==================================================&gt;] 72.48MB/72.48MB2d62b975fbed: Loading layer [==================================================&gt;] 57.32MB/57.32MB520ed35c2642: Loading layer [==================================================&gt;] 3.584kB/3.584kBLoaded image: nginx:1.16.1[root@linux-node1 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx 1.16.1 0dac5b41d811 3 weeks ago 126MB 查看镜像详细信息 docker inspect inspect 命令来查看镜像的详细信息：docker [image] inspect 1234567# 查看镜像所有详细信息[root@linux-node1 docker]# docker inspect nginx# 查看其中一项[root@linux-node1 docker]# docker inspect -f &#123;&#123;&quot;.Created&quot;&#125;&#125; nginx2019-09-24T23:33:17.034191345Z]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F07%2Fdocker-install%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[01 Docker 简介]]></title>
    <url>%2F2019%2F10%2F07%2Fdocker-base01%2F</url>
    <content type="text"><![CDATA[Docker 简介1234# 官方文档https://www.runoob.com/docker/docker-tutorial.htmlDocker 官网：http://www.docker.comGithub Docker 源码：https://github.com/docker/docker Docker是Docker.lnc公司(前dotCloud,PaaS市场老牌提供商)开源的一个基于LXC技术之上构建的Container容器引擎,源代码托管在Github上,基于Go语言并遵从Apache2.0协议开源。 Docker是通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离,所以Docker容器在运行时,不需要类似虚拟机（VM）额外的操作系统开销,提高资源利用率。 123451. kvm解决了硬件和操作系统之间的依赖。2. docker解决了软件和操作系统环境之间的依赖，能够让独立服务或应用程序在不同的环境中，得到相同的运行结果。3. docker容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。开发人员在自己笔记本上创建并测试好的容器，无需任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上运行。4. Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。 Docker 的三大理念 构建,运输,随处运行 Build,Ship and Run any App,Angwhere Docker 的应用场景12341. Web 应用的自动化打包和发布。2. 自动化测试和持续集成、发布。3. 在服务型环境中部署和调整数据库或其他的后台应用。4. 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 Docker 的优点12345678910111、简化程序： - Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。 Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。 方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。2、避免选择恐惧症： - 如果你有选择恐惧症，还是资深患者。那么你可以使用 Docker 打包你的纠结！比如 Docker 镜像； Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。 比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。 3、节省开支： - 一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。 Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。 Docker 能做什么 Docker依赖“写时复制”(copy-on-write)模型,修改应用程序非常迅速,“随心所致,代码即改” 简化配置 123这是Docker公司宣传的Docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在 不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。 代码流水线（Code Pipeline）管理 12前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。 提高开发效率 123456789这就带来了一些额外的好处：Docker能提升开发者的开发效率。如果你想看一个详细一点的例子，可以参考Aater在DevOpsDays Austin 2014 大会或者是DockerCon上的演讲。不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为 开发环境的机器加内存，而现在Docker可以轻易的让几十个服务在Docker中跑起来。 隔离应用 1有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等 整合服务器 123正如通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。 调试能力 123Docker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在《Docker拯救世界》的文章中找到这一点的例证。 多租户环境 12345另外一个Docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的 例子是为IoT（译者注：物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。 快速部署 12345在虚拟机之前，引入新的硬件资源需要消耗几天的时间。Docker的虚拟化技术将这个时间降到了几分钟，Docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。这正是Google和Facebook都看重的特性。你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用Docker并进行有效的资源分配可以提高资源的利用率。 小结:一句话说明docker的本质就是: 低开销（系统文件、内存 共用）的虚拟机 Docker 改变了什么123456789面向产品：产品交付面向开发：简化环境配置面向测试：多版本测试面向运维：环境一致面向架构：自动化扩容（微服务）]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器技术简介]]></title>
    <url>%2F2019%2F10%2F07%2Fdocker-base%2F</url>
    <content type="text"><![CDATA[容器简介 容器是在隔离的环境运行的一个进程，如果进程停止，容器就会销毁。隔离的环境拥有自己的文件系统，ip地址，主机名等。 容器是一种轻量级操作系统层面的虚拟机，它为应用软件及其依赖组件提供了一个资源独立的运行环境。应用软件所依赖的组件会被打包成一个可重用的镜像，镜像运行环境并不会与主操作系统共享内存、CPU和硬盘空间，由此也保证了容器内部的进程与容器外部进程的独立关系。 容器与虚拟化的区别 管理程序虚拟化(hypervisor virtualization,HV) 通过中间层将一台或多台独立懂得虚拟机运行于物理硬件之上。 容器(Containers) 运行在操作系统内核之上的用户空间。 12345简单解释，虚拟机运行在操作系统上，而docker是直接运行在应用上。所以docker无法提供一个像VMware那样完全的隔离，甚至到很多地方都没有进行隔离，比如说用户空间。这里可以解释一下,如果你用的是centos5版本那你就别想安装docker了，如果是centos6的你可以看一眼。因为内核版本比较低，但是如果使用乌班图就可以，因为乌班图的内核更新的比较快。如果公司服务器是centos5和centos6 用docker就需要升级内核，相对比较麻烦. Docker 和 KVM 的对比12KVM 和 Docker 的对比:https://www.qstack.com.cn/archives/148.html 1234567891011121314151617181920212223242526272829301. 虚拟化技术对比： - KVM全虚拟化,需要模拟各种硬件,跑在宿主机之上。 - Xen, VMware半虚拟化,直接跑在硬件上。 - docker严格来说不算是虚拟化技术(操作系统虚拟化),只是进程隔离和资源限制。 2. 占用内容资源对比: - KVM虚拟机一般会独占一段内存，即使闲置，其他虚拟机也无法使用。 - 容器可以只有一个内存上限，没有下限。如果它只使用1MB内存，那么它只占用宿主机1MB内存。宿主机可以将富余内存作为他用。3. 实例的内核对比: - kvm虚拟机内核 无需与宿主机一致 - docker实例内核和宿主机 内核一致 4. 操作系统支持度对比: - kvm支持多种操作系统，除了linux，还支持windows，uninx、solaris等 - docker只支持linux 5. 启动一个实例需要的时间对比: # lxc容器技术将操作系统抽象到了一个新的高度。 # 直接从init启动，省去了硬件自检、grub引导、加载内核、加载驱动等传统启动项目，因此启动飞速。 - docker:秒级 - kvm:分钟级别 6. 镜像模板占用空间对比: - kvm:占用空间大,G级别 - docker:占用空间小,M级别综合来说: - kvm资源隔离比docker更高,kvm支持的操作系统类型更多 - docker比kvm更省资源,可以提供非常接近宿主机的性能 容器更省资源1234561. 容器由于省去了操作系统,整个层级更简化,容器可以在单台服务器上运行更多的应用。2. 虚拟化技术针对每个虚拟机的资源分配是固定的。 - 如下图,三个虚拟机在一台计算机上运行，该计算机配备48 GB内存、12核处理器和3TB磁盘存储空间， - 每个虚拟机被分配了16 GB内存、4核和1TB存储空间，如果其中一个虚拟机使用的内存从不超过1GB，只存储100MB的文件系统， - 该虚拟机仍占用4GB内存和整整1TB的存储空间，仍是造成了大量的资源浪费。 - 而容器则是以共享方式使用主机上的内存、处理器和存储空间。 容器实现秒级启动1231. 虚拟机包含了完整的操作系统环境,同时还提供了对操作系统的控制支持。因此，虚拟机的规模较大，通常会达到数个G。2. 在运行应用前,虚拟机需要预先花费几分钟来引导操作系统,然后才能初始化和运行应用程序。3. 容器则规模较小，一般只有数个M，容器通常可以实现秒级启动。 Docker 与 OpenStack区别 百花齐放的容器技术 虽然 docker 把容器技术推向了巅峰，但容器技术却不是从 docker 诞生的。 实际上，容器技术连新技术都算不上，因为它的诞生和使用确实有些年头了。 下面的一串名称肯能有的你都没有听说过，但它们的确都是容器技术的应用： 1234567891011Chroot JailFreeBSD JailsLinux VServerSolaris ContainersOpenVZProcess ContainersLXCWardenLMCTFYDockerRKT 123456789101112131415161718192021222324252627282930313233341、Chroot Jail就是我们常见的 chroot 命令的用法。它在 1979 年的时候就出现了，被认为是最早的容器化技术之一。它可以把一个进程的文件系统隔离起来。2、The FreeBSD JailFreebsd Jail 实现了操作系统级别的虚拟化，它是操作系统级别虚拟化技术的先驱之一。3、Linux VServer使用添加到 Linux 内核的系统级别的虚拟化功能实现的专用虚拟服务器。4、Solaris Containers它也是操作系统级别的虚拟化技术，专为 X86 和 SPARC 系统设计。Solaris 容器是系统资源控制和通过 &quot;区域&quot; 提供边界隔离的组合。5、OpenVZOpenVZ 是一种 Linux 中操作系统级别的虚拟化技术。 它允许创建多个安全隔离的 Linux 容器，即 VPS。6、Process ContainersProcess 容器由 Google 的工程师开发，一般被称为 cgroups。7、LXCLXC 又叫 Linux 容器，这也是一种操作系统级别的虚拟化技术，允许使用单个 Linux 内核在宿主机上运行多个独立的系统。8、Warden在最初阶段，Warden 使用 LXC 作为容器运行时。 如今已被 CloudFoundy 取代。9、LMCTFYLMCTY 是 Let me contain that for you 的缩写。它是 Google 的容器技术栈的开源版本。Google 的工程师一直在与 docker 的 libertainer 团队合作，并将 libertainer 的核心概念进行抽象并移植到此项目中。该项目的进展不明，估计会被 libcontainer 取代。10、DockerDocker 是一个可以将应用程序及其依赖打包到几乎可以在任何服务器上运行的容器的工具。11、RKTRKT 是 Rocket 的缩写，它是一个专注于安全和开放标准的应用程序容器引擎。 在什么场景需要容器 如果你遇到以下场景，推荐使用容器： 1234567891011121314151. 部署无状态服务，同虚拟机互补使用，实现隔离性2. 如果要部署有状态服务，需要对里面的应用十分的了解3. 作为持续集成的重要工具，可以顺利在开发，测试，生产之间迁移4. 适合部署跨云，跨Region，跨数据中心，混合云场景下的应用部署和弹性伸缩5. 以容器作为应用的交付物，保持环境一致性，树立不可变更基础设施的理念6. 运行进程基本的任务类型的程序7. 用于管理变更，变更频繁的应用使用容器镜像和版本号，轻量级方便的多8. 使用容器一定要管理好应用，进行health check和容错的设计 容器有哪些优点12345678910111213141516171819202122231. 敏捷开发：容器技术最大的优势在于其快速的生成效率，轻量级的打包方式使其具有更好的性能和更小的规模。2. 快速开发：容器解决了应用程序的平台依赖和平台冲突问题，从而帮助开发人员更快地开发程序。每个容器可被看作为一个微服务，因而可以单独进行升级，而不必担心同步问题。3. 版本管理：容器中的镜像可被单独管理，由此可以追踪、记录、生成不同的容器版本，进而分析容器版本的差异。4. 计算环境可移植：容器封装了与应用相关的依赖组件及操作系统信息，由此减轻了应用在不同计算环境下的配置需求。例如，同一个镜像可应用于Windows或Linux环境，并适用于开发、测试、部署等阶段。5. 标准化：容器通常基于开放标准而设计，因而容器在主流Linux系统及Windows系统上都是适用的。6. 安全性：容器间的进程以及容器内外的进程是相互独立的。因此，每个容器的升级或修改对其它容器都是没有影响的。7. 弹性伸缩：由于容器单元间相互独立，由统一的编排工具管理，且编排工具具备发现容器节点的功能，所以容器的弹性扩容可以在短时间内自动完成；同时，由于每个容器均为独立的个体，容器调用的资源和容器的使用由编排工具管理，所以减少某一容器节点不影响整个容器系统的使用。8. 高可用：与弹性伸缩类似，在某一容器节点出现故障时，容器编排工具能够及时发现节点的变化，并根据外部请求情况及时作出调整，不影响整个容器系统的使用，实现系统的高可用。9. 管理便利：容器技术可通过简单的命令行，完成对单一容器的管理，完成对镜像的快速打包和迁移；同时也能通过Kubernetes、Swarm等工具，实现对大规模容器集群的管理。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 基础]]></title>
    <url>%2F2019%2F09%2F30%2Fsaltstack-base%2F</url>
    <content type="text"><![CDATA[简介简单介绍 一个配置管理系统，能够维护预定义状态的远程节点。(比如，确保指定的软件被安装，指定的服务在运行) 一个分布式远程执行系统，用来在远程节点（可以是单个节点，也可以是任意规则挑选出来的节点）上执行命令和查询数据。 开发其的目的是为:远程执行提供最好的解决方案，并使远程执行变得更好，更快，更简单。 SaltStack是使用Python语言开发的，同时提供Rest API方便二次开发以及和其它平台进行集成。 参考学习123https://www.cnblogs.com/wangxu01/tag/saltstack/https://github.com/unixhothttps://github.com/unixhot/saltbook-code/tree/master/salt/pro 常用网址• 官方网站：http://www.saltstack.com• 官方文档：http://docs.saltstack.com• GitHub：https://github.com/saltstack• 中国SaltStack⽤户组：http://www.saltstack.cn 四大功能 配置管理 远程执行 云管理 事件驱动 基础架构• Saltstack基于C/S架构 – 服务端:Master – 客户端:Minion • 可以实现传统处理方式,即:客户端发送请求给服务器,服务器收到请求后处理请求,再将结果返回 • 也可以使用消息队列中的发布与订阅(pub/sub)服务模式 工作原理 SaltStack 采用 C/S模式，server端就是salt的master，client端就是minion。 minion与master之间通过ZeroMQ消息队列通信。 minion上线后先与master端联系，把自己的pub key发过去，这时master端通过salt-key -L命令就会看到minion的key，接受该minion-key后，也就是master与minion已经互信 master可以发送任何指令让minion执行了，salt有很多可执行模块，比如说cmd模块，在安装minion的时候已经自带了，它们通常位于你的python库中，locate salt | grep /usr/ 可以看到salt自带的所有东西。 这些模块是python写成的文件，里面会有好多函数，如cmd.run，当我们执行salt ‘*’ cmd.run ‘uptime’的时候，master下发任务匹配到的minion上去，minion执行模块函数，并返回结果。master监听4505和4506端口，4505对应的是ZMQ的PUB system，用来发送消息，4506对应的是REP system是来接受消息的。 运行流程 Salt stack的Master与Minion之间通过ZeroMq进行消息传递，使用了ZeroMq的发布-订阅模式，连接方式包括tcp，ipc salt命令，将cmd.run ls命令从salt.client.LocalClient.cmd_cli发布到master，获取一个Jobid，根据jobid获取命令执行结果。 master接收到命令后，将要执行的命令发送给客户端minion。 minion从消息总线上接收到要处理的命令，交给minion._handle_aes处理 minion._handle_aes发起一个本地线程调用cmdmod执行ls命令。线程执行完ls后，调用minion._return_pub方法，将执行结果通过消息总线返回给master master接收到客户端返回的结果，调用master._handle_aes方法，将结果写的文件中。 salt.client.LocalClient.cmd_cli通过轮询获取Job执行结果，将结果输出到终端。 通信端口master端：4505,4506minion端：4506 工作方式 Local Master/Minion Salt SSH 最传统的运行方式还是C/S模式，管理端安装Master，被管理节点上安装Minion客户端 安装和配置实验环境• CentOS6 10.0.0.200 linux-node1 master/minion• CentOS6 10.0.0.201 linux-node2 minion 关闭 Selinux12345678910111213141516171819202122查看selinux状态[root@linux-node2]# sestatusSELinux status: enabledSELinuxfs mount: /sys/fs/selinuxSELinux root directory: /etc/selinuxLoaded policy name: targetedCurrent mode: permissiveMode from config file: enforcingPolicy MLS status: enabledPolicy deny_unknown status: allowedMax kernel policy version: 28[root@linux-node2 minion]# getengetenforce getent [root@linux-node2]# getenforce Permissive# 临时关闭[root@linux-node2]# setenforce 0# 永久关闭可以修改配置文件/etc/selinux/config,将其中SELINUX设置为disabled。 安装123456789curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repocurl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo* For RHEL/CentOS 6: 需要python2.7以上版本rpm -ivh http://repo.saltstack.com/yum/redhat/salt-repo-latest.el6.noarch.rpm* For RHEL/CentOS 7:yum install https://repo.saltstack.com/yum/redhat/salt-repo-latest.el7.noarch.rpm Salt Master安装1[root@linux-node1 yum.repos.d]# yum install -y salt-master salt-minion Salt Minion安装1[root@linux-node2 ~]# yum install -y salt-minion 启动 salt-master1234systemctl start salt-mastersystemctl enable salt-master ps -ef | grep salt-master|grep –v grepsystemctl status salt-master 查看目录12345678910111213[root@linux-node1 salt]# pwd/etc/salt[root@linux-node1 salt]# tree pki/pki/├── master│ ├── master.pem # 启动后的密钥│ ├── master.pub # 启动后的公钥 │ ├── minions│ ├── minions_autosign│ ├── minions_denied│ ├── minions_pre│ └── minions_rejected└── minion 客户端修改配置文件123456789# 修改minion配置文件:告诉master是谁# 两台客户端一起修改# 配置文件里不能敲tab键# 78 ID 该参数告诉master &quot;我是谁&quot;，如果不配，默认是主机名 [root@linux-node1 salt]# vim minion 16 master: 10.0.0.250 [root@linux-node2 ~]# sed -i &apos;s#\#master: salt#master: 10.0.0.250#g&apos; /etc/salt/minion 启动 salt-minion123systemctl start salt-minionsystemctl enable salt-minionsystemctl status salt-minion 查看客户端目录1234567# 客户端启动后创建自己的公钥和私钥[root@linux-node2 ~]# tree /etc/salt/pki/etc/salt/pki├── master└── minion ├── minion.pem # 启动后的密钥 └── minion.pub # 启动后的公钥 1234# 客户端ID文件# 如果之后要修改ID值,还需要再重新启动之前删除该文件[root@linux-node2 salt]# cat /etc/salt/minion_idlinux-node2 配置认证 salt-key 在启动minion后,会将自己的公钥发送给master 1234567891011[root@linux-node1 pki]# tree /etc/salt/pki/master/etc/salt/pki/master├── master.pem├── master.pub├── minions├── minions_autosign├── minions_denied├── minions_pre│ ├── linux-node1 # 通过ID命名│ └── linux-node2 # 通过ID命名└── minions_rejected 通过命令同意公钥,让 master 管理 minions 123456789# 查看minion salt-key -L[root@linux-node1 pki]# salt-key -LAccepted Keys:Denied Keys:Unaccepted Keys:linux-node1linux-node2Rejected Keys: 12345salt-key -A # 同意所有minionsalt-key -a linux-node1 -y # 同意指定的nodesalt-key -D # 拒绝,删除salt-key -d linux-node1 123456789101112131415161718192021222324[root@linux-node1 pki]# salt-key -LAccepted Keys:Denied Keys:Unaccepted Keys:linux-node1linux-node2Rejected Keys:[root@linux-node1 pki]# salt-key -AThe following keys are going to be accepted:Unaccepted Keys:linux-node1linux-node2Proceed? [n/Y] y Key for minion linux-node1 accepted.Key for minion linux-node2 accepted.[root@linux-node1 pki]# salt-keyAccepted Keys:linux-node1linux-node2Denied Keys:Unaccepted Keys:Rejected Keys: 查看 minion 目录,master 会把公钥发过来 12345678910111213141516[root@linux-node1 pki]# tree /etc/salt/pki//etc/salt/pki/├── master│ ├── master.pem│ ├── master.pub│ ├── minions│ │ ├── linux-node1│ │ └── linux-node2│ ├── minions_autosign│ ├── minions_denied│ ├── minions_pre│ └── minions_rejected└── minion ├── minion_master.pub # master 把公钥发过来了，双向的交换了密钥 ├── minion.pem └── minion.pub 查看 master目录,原来是在 minions_pre 现在到了minions，说明master可以管理 12345678910111213141516[root@linux-node1 pki]# tree /etc/salt/pki//etc/salt/pki/├── master│ ├── master.pem│ ├── master.pub│ ├── minions # 原来是在 minions_pre│ │ ├── linux-node1│ │ └── linux-node2│ ├── minions_autosign│ ├── minions_denied│ ├── minions_pre│ └── minions_rejected└── minion ├── minion_master.pub ├── minion.pem └── minion.pub 验证通信12345678# 返回true为正常 # * 代表所有，单引号为转义 [root@linux-node1 pki]# salt &apos;*&apos; test.pinglinux-node2: Truelinux-node1: True 12345678# 如果出现salt &apos;*&apos; test.ping出错Minion did not return. [Not connected]# 解决这种错误，需要删除minion端的key，重新认证。rm -rf /etc/salt/pki/minion/minion_master.pubrm -rf /etc/salt/pki/minion/# 重启minion端systemctl restart salt-minion# 一定要记得初始化环境要关闭SEXLINUX 12345# 单独验证# 实际上所有的minion 都收到了 但是只有 node2返回了结果[root@linux-node1 pki]# salt &apos;linux-node2&apos; test.pinglinux-node2: True 查看端口 服务端与客户端发送消息 通过 消息队列 zeromq 所有的minion 都连接到 slat的 4505端口上 1234567# master [root@linux-node1 pki]# netstat -tnlpProto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:4505 0.0.0.0:* LISTEN 1470/python tcp 0 0 0.0.0.0:4506 0.0.0.0:* LISTEN 1476/python ... 123456789# -n 不做域名解析# -i 检查所有和4505所有的连接[root@linux-node1 pki]# lsof -n -i:4505COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsalt-mast 1470 root 16u IPv4 20545 0t0 TCP *:4505 (LISTEN)salt-mast 1470 root 18u IPv4 39421 0t0 TCP 10.0.0.250:4505-&gt;10.0.0.250:58670 (ESTABLISHED)salt-mast 1470 root 19u IPv4 39477 0t0 TCP 10.0.0.250:4505-&gt;10.0.0.251:45200 (ESTABLISHED)salt-mini 7502 root 27u IPv4 39420 0t0 TCP 10.0.0.250:58670-&gt;10.0.0.250:4505 (ESTABLISHED) 1234# 返回消息 发送给4506[root@linux-node1 pki]# lsof -n -i:4506COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsalt-mast 1476 root 24u IPv4 20569 0t0 TCP *:4506 (LISTEN) 端口开启123# master使用两个端口和minion通信，要确保这两个端口通信正常。# 4505 publish_port 消息发布系统端口# 4506 ret_port 客户端与服务端通信端口 1234# 可以关闭掉防火墙，或者将端口添加至INPUT链表。# iptables链表规则是自上而下，这里插入在REJECT ALL之前。 iptables -I INPUT 5 -p tcp --dport 4505 -j ACCEPT -m comment --comment &quot;salt_publish_port&quot;iptables -I INPUT 5 -p tcp --dport 4506 -j ACCEPT -m comment --comment &quot;salt_ret_port&quot; 普通用户使用saltstack修改minion_ID123456停止minion服务salt-key –d minion_id 删除minion IDminion端rm –f /etc/salt/minion_idminion端 rm –rf /etc/salt/pki/修改配置文件id启动minion Salt 远程执行命令基础语法 执行salt的基本语法： 1salt &apos;&lt;target&gt;&apos; &lt;function&gt; [arguments] 1234567# 在所有客户端上执行uptime命令# cmd.run[root@linux-node1 ~]# salt &apos;*&apos; cmd.run &apos;uptime&apos;linux-node1: 18:02:09 up 17 min, 1 user, load average: 0.01, 0.05, 0.12linux-node2: 18:02:09 up 17 min, 1 user, load average: 0.00, 0.02, 0.06 选择目标1https://docs.saltstack.com/en/latest/topics/targeting/index.html 和 minion_ID 相关的 通配符 12salt &apos;*&apos; test.versionsalt &apos;linux-node*&apos; test.ping 正则 1[root@linux-node1 base]# salt -E &apos;linux-node(1|2)&apos; test.ping 列表 1234567salt -L &apos;linux-node1,linux-node2&apos; test.version# top file: 所有匹配目标的方式，都可以用到top file里面来指定目标。base: &apos;web1-(prod|devel)&apos;: - match: pcre - webserver minion ID设置方案：IP地址、根据业务来进行设置 12345redis-node1 # redis第一个节点redis04 # 集群game01 # 业务线 和 minion_ID 无关的 GRAINS匹配 1salt -G &apos;os:CentOS&apos; test.version IP地址 1salt -S 10.0.0.0/24 test.version 批处理 123slat并发改成串行 每次自行10个salt &apos;*&apos; -b 10 test.versiosalt -G &apos;os:RedHat&apos; --batch-size 25% apache.signal restart #一次处理25% 执行模块 远程执行三大组件 1231. 选择目标:通配符、正则、list2. 返回:job cache3. 执行模块:network、service、state 1234虚拟模块:针对不同的操作系统 调用不同的方法通过yum默认安装salt所有模块存放路径 /usr/lib/python2.7/site-packages/salt/modules（centos 7）https://www.unixhot.com/docs/saltstack/ref/modules/all/index.html#all-salt-moduleshttps://www.unixhot.com/docs/saltstack/ref/modules/all/salt.modules.service.html#module-salt.modules.service network 123salt &apos;*&apos; network.active_tcpsalt &apos;*&apos; network.arpsalt &apos;*&apos; network.connect archlinux.org 8 service 123# 如果所有的服务器都是统一的操作系统 比如CentOS7 那么可以使用cmd.run 执行命令# 如果 既有7也有6 那么就使用service模块，他底层封装好了帮我们,针对不同的系统,调用不同的命salt &apos;*&apos; service.get_all state 1234567https://www.unixhot.com/docs/saltstack/ref/modules/all/salt.modules.state.html#module-salt.modules.statesalt &apos;*&apos; state.show_top1. 执行模块和状态模块本质区别: 1. 执行模块上来就执行 2. 状态模块先看你有没有,没有就帮你执行salt &apos;*&apos; state.single pkg.installed name=vi 123456789# 常用salt &apos;*&apos; network.active_tcp # 列出所有主机运行的tcp连接salt &apos;*&apos; network.arp # 列出所有主机arpsalt &apos;*&apos; service.available sshd # 列出所有主机sshdsalt &apos;*&apos; service.get_all # 列出所有主机的所有运行服务salt &apos;*&apos; service.status sshd # 列出所有主机sshd运行状态salt-cp &apos;*&apos; /etc/hosts /tmp/test # 将master上/etc/hosts文件拷贝到所有主机的/tmp/testsalt &apos;*&apos; state.show_top # 查看topsalt &apos;*&apos; state.single pkg.installed name=lsof # 所有主机安装lsof Salt 配置管理YAMLYAML 是一个可读性高，用来表达数据序列化的格式。在使用YANL编辑配置文件时，需要注意: 格式: 两个空格缩进 冒号后面要后空格 - 代表列表, - 后面有空格 数据结构可以用类似大纲的缩排方式呈现，结构通过缩进来表示，连续的项目通过减号“-”来表示，map结构里面的key/value对用冒号“:”来分隔。 样例如下：123456789101112131415house: family: name: Doe parents: - John - Jane children: - Paul - Mark - Simone address: number: 34 street: Main Street city: Nowheretown zipcode: 1234 Salt 状态管理 什么叫状态管理状态是对minion的一种描述和定义，管理人员可以不关心具体部署任务时如何完成的，只需要描述minion要达到什么状态，底层由salt的状态模块来完成功能 创建状态配置文件目录 告诉 master 状态文件放在哪个位置 1234567891011121314# 编辑master配置文件# 搜索: /file_roots # base基础环境 dev开发环境 test测试环境 prod生产环境[root@linux-node1 ~]# vim /etc/salt/masterfile_roots: base: - /srv/salt dev: - /srv/salt/base test: - /srv/salt/dev prod: - /srv/salt/prod 创建目录 1234567[root@linux-node1 ~]# mkdir -p /srv/salt/&#123;base,dev,test,prod&#125;[root@linux-node1 ~]# tree /srv/salt//srv/salt/├── base # 必须有├── dev # 开发环境├── prod # 生产环境└── test # 测试环境 重启master,改完配置就要重启 1234567[root@linux-node1 ~]# systemctl restart salt-master[root@linux-node1 ~]# systemctl status salt-master[root@linux-node1 ~]# salt &apos;*&apos; test.pinglinux-node2: Truelinux-node1: True 查看日志 123vim /etc/salt/masterlog_level: debug [root@linux-node1 salt]# tail /var/log/salt/master 简单状态管理 自动化安装apache并启动 编写状态文件需要注意 123所有的状态文件 都需要以.sls结尾 --&gt; Salt State所有文件名小写所有主机名都用-,不许用_下划线,因为DNS解析不支持_,主机名也都小写 CentOS7 服务管理 12345678910111213141.启动、终止、重启systemctl start httpd.service #启动systemctl stop httpd.service #停止systemctl restart httpd.service #重启2.设置开机启动/关闭systemctl enable httpd.service #开机启动systemctl disable httpd.service #开机不启动3.检查httpd状态systemctl status httpd.service4.查看服务开机启动列表systemctl list-unit-files; apache.sls1234567891011[root@linux-node1 base]# cd /srv/salt/base/[root@linux-node1 base]# vim apache.slsapache-install: # 唯一表示ID pkg.installed: # pkg状态模块,installed方法 - name: httpd # installed方法参数,这台机器安装http,如果有什么也不做,没有就安装apache-service: # 唯一表示ID service.running: # service状态模块.running方法 - name: httpd # 保证http处于运行状态,运行啥也不做,没有就起来 - enable: True # 开机自动启动,等于当前状态 yum install httpd | systemctl start|enable httpd 12345678910[root@linux-node1 base]# vim apache.slsapache-install: pkg.installed: - name: httpdapache-service: service.running: - name: httpd - enable: True 单独执行1234# salt '*' state.sls apache# state(状态执行模块).sls(方法)# 去base下找 apache.sls 文件 并执行这个状态 # .sls(省略) 1234# 去node2看看是否在yum安装httpd[root@linux-node2 ~]# ps aux | grep yumroot 1829 0.0 2.3 322532 23896 ? R 18:57 0:00 /usr/bin/python /usr/bin/yum --quiet --assumeyes check-update --setopt=autocheck_running_kernel=falseroot 1833 0.0 0.0 112712 956 pts/0 R+ 18:57 0:00 grep --color=auto yum 查看node1的执行状态 12345678# 需要关注的执行状态ID: apache-service # 状态IDResult: True # 返回结果Changes: # 变化Succeeded: 2 (changed=2) # 成功2个,改变2个Failed: 0Total states run: 2 # 总共运行了2 查看node2上的服务和端口状态 可以将node2的httpd关闭 再执行测试 1[root@linux-node2 ~]# systemctl stop httpd 123使用彩色输出时，颜色代码如下：green表示成功，red表示失败，blue表示更改和成功以及yellow表示预期的将来配置更改。状态管理,就算你卸载了httpd,再执行都会帮你安装并启动 分类 分类所有的sls文件都存放在base目录下,在生产项目中会相当难找到,所以需要根据软件的功能进行目录分类 123456789101112# 创建分类目录[root@linux-node1 base]# mkdir -p &#123;sql,web,nosql,monitor&#125;[root@linux-node1 base]# mv apache.sls web/[root@linux-node1 base]# tree.├── monitor├── nosql├── sql└── web └── apache.sls 多级目录执行 12# base是基准目录[root@linux-node1 base]# salt '*' state.sls web.apache 高级状态管理 top.sls 编辑top.sls如果我们有很多的sls文件,但是这些文件只能单独执行,如果批量执行呢?这个时候我们可以使用top.sls,他相当于任务编排 1234[root@linux-node1 base]# vim /etc/salt/master/top.sls# 打开注释state_top: top.sls 1234567# top.sls默认放在base环境下[root@linux-node1 base]# vim /srv/salt/base/top.slsbase: # 执行环境 'linux-node1': # minion_id - web.apache # 要执行的状态 'linux-node2': - web.apache 1234567[root@linux-node1 base]# vim /srv/salt/base/top.slsbase: 'linux-node1': - web.apache 'linux-node2': - web.apache 执行 12345[root@linux-node1 base]# salt '*' state.highstate# 高级状态根据ID单独执行[root@linux-node1 base]# salt 'linux-node1' state.highstate# 高级状态,salt默认会去base下找top.sls,读取编排,哪个minion执行什么状态# 如果80端口被nginx服务占用,记得要先关闭,salt无法帮你关闭不是要求的工作状态 常用的状态模块 服务的基本要求: 安装、配置、启动 pkg 功能:管理软件包状态 常用方法: 1234• pkg.installed # 确保软件包已安装. 如果没有安装就安装• pkg.latest # 确保软件包是最新版本, 如果不是, 升级• pkg.remove # 确保软件包已卸载, 如果之前已安装, 卸载• pkg.purge # 除remove外, 也会删除其配置文件 官方文档： https://docs.saltstack.cn/ref/states/all/index.html https://docs.saltstack.cn/ref/states/all/salt.states.pkg.html#module-salt.states.pkg 1234# pkg是虚拟模块,在CentOS上调用 yum安装# 正确的写法是 先找一台机器,yum安装看看需要哪些包,然后再写# 一个ID下面只允许一个状态执行一次# pkgs:要从软件存储库安装的软件包列表 12345678910lamp-install: pkg.installed: - pkgs: - httpd - php - php-pdo - php-mysql - php-cli - php-common - mysql file 功能:管理文件状态 常用方法: 123• file.managed # 保证文件存在并且为对应的状态• file.recurse # 保证目录存在并且为对应状态• file.absent # 确保文件不存在, 如果存在就删除 官方文档： https://docs.saltstack.cn/ref/states/all/salt.states.file.html#module-salt.states.file 1234name # 在客户端的位置source # 源目录base/web/ 会把源目录下的文件,替换放过去,也支持ftp和http下载# 以后都以 source 的文件为准了,所有的位置都在一个地方改# 不一样的配置如何设置呢? 1234567891011121314151617181920212223apache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://web/files/httpd.conf - user: root - group: root - mode: 644php-config: file.managed: - name: /etc/php.ini - source: salt://web/files/php.ini - user: root - group: root - mode: 644mysql-config: file.managed: - name: /etc/my.cnf - source: salt://web/files/my.cnf - user: root - group: root - mode: 644 12345678910111213141516# 其他模块方法file.copy /etc/nginx/nginx.conf /home/zhanqi/nginx.conf # 文件复制file.get_sum /home/zhanqi/nginx.conf md5 # 文件md5校验file.chown /home/zhanqi/nginx.conf zhanqi zhanqi # 修改文件所属用户以及组file.set_mode /home/zhanqi/nginx.conf 755 # 修改文件权限file.mkdir /home/zhanqi/testdir # 创建目录file.remove /home/zhanqi/testdir # 移除目录file.append /home/zhanqi/nginx.conf 'add_header "Access-Control-Allow-Origin" "*";' # 追加内容到文件file.recurse # 下发目录 service 功能:管理服务状态 常用方法: 1234• service.running # 确保服务处于运行状态,如果没有行就启动• service.enabled # 确保服务开机启动• service.disabled # 确保服务开机不启动启动• service.dead # 确保服务当前没有运行,如果运行就停止 官方文档： https://docs.saltstack.cn/ref/states/all/salt.states.service.html#module-salt.states.service 123456789httpd-service: service.running: - name: httpd - enable: Truemariadb-service: service.running: - name: mariadb - enable: True 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 执行成功日志[root@linux-node1 web]# salt 'linux-node2' state.sls web.lamplinux-node2:---------- ID: lamp-install Function: pkg.installed Result: True Comment: All specified packages are already installed Started: 09:09:40.109789 Duration: 664.41 ms Changes: ---------- ID: apache-config Function: file.managed Name: /etc/httpd/conf/httpd.conf Result: True Comment: File /etc/httpd/conf/httpd.conf is in the correct state Started: 09:09:40.776230 Duration: 18.621 ms Changes: ---------- ID: php-config Function: file.managed Name: /etc/php.ini Result: True Comment: File /etc/php.ini is in the correct state Started: 09:09:40.795022 Duration: 9.828 ms Changes: ---------- ID: mysql-config Function: file.managed Name: /etc/my.cnf Result: True Comment: File /etc/my.cnf is in the correct state Started: 09:09:40.805020 Duration: 8.337 ms Changes: ---------- ID: httpd-service Function: service.running Name: httpd Result: True Comment: The service httpd is already running Started: 09:09:40.814034 Duration: 32.034 ms Changes: ---------- ID: mariadb-service Function: service.running Name: mariadb Result: True Comment: Service mariadb has been enabled, and is running Started: 09:09:40.846290 Duration: 4801.984 ms Changes: ---------- mariadb: TrueSummary for linux-node2 salt缓存 123456789101112131415[root@linux-node1 salt]# cd /var/cache/salt/minion/[root@linux-node1 minion]# tree.├── accumulator├── extmods├── files│ └── base│ ├── lamp.sls│ ├── top.sls│ └── web│ └── apache.sls├── highstate.cache.p├── module_refresh├── proc└── sls.p 状态间关系file.recurse 管理多个配置文件 功能: 通过主目录上的子目录递归，并将所述子目录复制到指定的路径 12345httpd管理多个配置文件:1. 管理conf.d/*.conf2. 先看Include目录[root@linux-node2 etc]# vim /etc/httpd/conf/httpd.confInclude conf.modules.d/*.conf 12345678910111213141516171819[root@linux-node1 files]# pwd/srv/salt/base/web/files[root@linux-node1 files]# mkdir -p apache-conf.d[root@linux-node1 files]# cd apache-conf.d/[root@linux-node1 apache-conf.d]# cp /etc/httpd/conf.d/* ./[root@linux-node1 apache-conf.d]# touch leo.conf[root@linux-node1 apache-conf.d]# tree.├── autoindex.conf├── leo.conf├── php.conf├── README├── userdir.conf└── welcome.conf0 directories, 6 files 添加管理语句 12345678910[root@linux-node1 web]# vim lamp.sls apache-conf: file.recurse: - name: /etc/httpd/conf.d - source: salt://web/files/apache-conf.d /etc/profile: file.append: - text: - "#Redis_PATH=''" watch 和 watch_in 处理状态之间的关系 功能 如果我的配置文件变更,服务就自动reload 12• watch # 我关注某个状态• watch_in # 我被某个状态关注 1234# file 是要监控的状态模块 apache-conf 是状态的ID# apache-config 文件 更新就重启# 增加了 reload: True watch会执行reload# 服务不支持reload 比如mysql 那就不要加,mysql动态改参数 set 1234567httpd-service: service.running: - name: httpd - enable: True - reload: True - watch: - file: apache-config 文件的状态被关注 wacth # 服务关注什么 watch_in # 文件被什么所关注 目录有更新 就执行重启 123456apache-conf: file.recurse: - name: /etc/httpd/conf.d - source: salt://web/files/apache-conf.d - watch_in: - service: httpd-service require和 require_in依赖某个状态 功能: 比如安装某个软件没有成功,就不往下走了 12• require # 我依赖某个状态• require_in # 我被某个状态依赖 lamp-install 如果安装不成功,就不会向下执行 123456789apache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://web/files/httpd.conf - user: root - group: root - mode: 644 - require: - pkg: lamp-install unless 状态判断添加info.php页面12345678910[root@linux-node2 conf]# cd /var/www/html/[root@linux-node2 html]# mkdir admin[root@linux-node2 html]# cd admin/[root@linux-node2 admin]# vim info.php&lt;?phpphpinfo();?&gt;# 访问http://10.0.0.251/admin/info.php 访问admin的时候输入用户名和密码1234567891011121314151617181920212223[root@linux-node2 admin]# vim /etc/httpd/conf/httpd.conf &lt;Directory "/var/www"&gt; AllowOverride None # Allow open access: Require all granted&lt;/Directory&gt;&lt;Directory "/var/www/html/admin"&gt; Options Indexes FollowSymLinks AllowOverride All Order allow,deny Allow from all AuthName "sys" AuthType Basic AuthUserFile /etc/httpd/conf/httppwd_file require user admin&lt;/Directory&gt;[root@linux-node2 admin]# systemctl restart httpd# 访问http://10.0.0.251/admin/info.php 修改状态文件123456789101112[root@linux-node1 web]# vim /srv/salt/base/web/files/httpd.conf&lt;Directory "/var/www/html/admin"&gt; Options Indexes FollowSymLinks AllowOverride All Order allow,deny Allow from all AuthName "sys" AuthType Basic AuthUserFile /etc/httpd/conf/httppwd_file require user admin&lt;/Directory 12345# 保证要有用到的命令[root@linux-node2 admin]# whereis htpasswdhtpasswd: /usr/bin/htpasswd /usr/share/man/man1/htpasswd.1.gz[root@linux-node2 admin]# rpm -qf /usr/bin/htpasswdhttpd-tools-2.4.6-90.el7.centos.x86_64 状态判断 unless123# 很多命令只需要执行一次,unless 通过判断 0 和 1 # 包httpd-tools 被下面的cmd.run使用,如果包不安装成功,下面的命令也不执行,因为apache-auth只有一个 cmd# unless 如果条件为真0,那么cmd.run就不执行 12345678apache-auth: pkg.installed: - name: httpd-tools - require_in: - cmd: apache-auth cmd.run: - name: /usr/bin/htpasswd -bc /etc/httpd/conf/httppwd_file admin admin - unless: test -f /etc/httpd/conf/httppwd_file 1234567# 执行测试[root@linux-node1 web]# salt 'linux-node2' state.sls web.lamp test=True[root@linux-node1 web]# salt 'linux-node2' state.sls web.lamp#访问:http://10.0.0.251/admin/info.phpadmin/admin lamp.sls 最终版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273[root@linux-node1 web]# vim lamp.sls lamp-install: pkg.installed: - pkgs: - httpd - php - php-pdo - php-mysql - php-cli - php-common - mariadb - mariadb-serverapache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://web/files/httpd.conf - user: root - group: root - mode: 644 - require: - pkg: lamp-installapache-conf: file.recurse: - name: /etc/httpd/conf.d - source: salt://web/files/apache-conf.d - watch_in: - service: httpd-serviceapache-auth: pkg.installed: - name: httpd-tools - require_in: - cmd: apache-auth cmd.run: - name: /usr/bin/htpasswd -bc /etc/httpd/conf/httppwd_file admin admin - unless: test -f /etc/httpd/conf/httppwd_file/etc/profile: file.append: - text: - "#Redis_PATH=''"php-config: file.managed: - name: /etc/php.ini - source: salt://web/files/php.ini - user: root - group: root - mode: 644mysql-config: file.managed: - name: /etc/my.cnf - source: salt://web/files/my.cnf - user: root - group: root - mode: 644httpd-service: service.running: - name: httpd - enable: True - reload: True - watch: - file: apache-configmariadb-service: service.running: - name: mariadb - enable: True 源码安装 Tomcat和 JDK 需求:判断minion有没有安装jdk和tomcat，没有就分别源码安装，并以普通用户启动。 上传软件包12345678[root@linux-node1 tools]# pwd/srv/salt/base/web/tools[root@linux-node1 tools]# tree.├── apache-tomcat-8.0.27.tar.gz└── jdk-8u60-linux-x64.tar.gz0 directories, 2 files 12345# 安装执行步骤将安装包传递到指定的目录解压添加环境变量启动服务 编写 tomcat.sls1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[root@linux-node1 web]# mkdir tools[root@linux-node1 web]# vim tomcat.sls jdk-install: file.managed: - name: /data/tools/jdk-8u60-linux-x64.tar.gz - source: salt://web/tools/jdk-8u60-linux-x64.tar.gz - user: root - group: root - made: 755 cmd.run: - name: cd /data/tools/ &amp;&amp; tar -zxf jdk-8u60-linux-x64.tar.gz &amp;&amp; chown -R root:root jdk1.8.0_60 &amp;&amp; mv jdk1.8.0_60 /data/ &amp;&amp; ln -s /data/jdk1.8.0_60 /data/jdk - require: - file: jdk-install - unless: test -L /data/jdk &amp;&amp; test -d /data/jdk1.8.0_60jdk-config: file.append: - name: /etc/profile - text: - '#JDK-ENV:' - JAVA_HOME=/data/jdk - PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH - CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar - export PATH JAVA_HOME CLASSPATH cmd.run: - name: source /etc/profile - require: - file: jdk-config - unless: source /etc/profile &amp;&amp; java -versiontomcat-install: file.managed: - name: /data/tools/apache-tomcat-8.0.27.tar.gz - source: salt://web/tools/apache-tomcat-8.0.27.tar.gz - user: root - group: root - made: 755 cmd.run: - name: cd /data/tools/ &amp;&amp; tar -zxf apache-tomcat-8.0.27.tar.gz &amp;&amp; chown -R root:root apache-tomcat-8.0.27 &amp;&amp; mv apache-tomcat-8.0.27 /data/ &amp;&amp; ln -s /data/apache-tomcat-8.0.27 /data/tomcat - require: - file: tomcat-install - unless: test -L /data/tomcat &amp;&amp; test -d /data/apache-tomcat-8.0.27tomcat-start: cmd.run: - name: source /etc/profile &amp;&amp; /bin/bash /data/tomcat/bin/startup.sh - require: - file: tomcat-install - unless: ps -ef | grep tomcat|grep -v 'grep' grains 和 pillar 数据收集 grains 收集静态数据Grains是saltstack的组件，用于收集salt-minion在启动时候的信息，又称为静态信息。Grains是服务器的一系列粒子信息，也就是服务器的一系列物理，软件环境信息。在执行salt的sls时候可以根据Grains信息的不同对服务器进行匹配分组，例如可以根据系统是centos服务器跟系统是redhat环境的安装不同的软件包。 功能: 负责minion第一次启动的时候采集的静态数据，可以用在salt的模块和其他组件中。每次的minion启动（重启）的时候都会采集。 收集资产信息,信息查询 静态数据，当Minion启动的时候收集的MInion本地的相关信息。（包含操作系统版本、内核版本、CPU、内存、硬盘、设备型号等）备注：不重启minion，这些信息数据是不会改变的。 123Grains可以在state系统中使用,用于配置管理模块Grains可以target中使用,在用来匹配Minion,比如匹配操作系统使用-G选项Grains可以用于信息查询,Grains保存着收集到的客户端的详细信息 目标选择123456789# grains 匹配所有CentOS的机器 执行test.ping [root@linux-node1 ~]# salt -G 'os:CentOS' test.ping # grains[root@linux-node1 ~]# salt -G 'os:CentOS' cmd.run "date"linux-node1: Wed Oct 2 21:31:14 CST 2019linux-node2: Wed Oct 2 20:59:05 CST 2019 信息采集1234salt 'linux-node2' grains.ls # 列出ID为linux-node2的主机,grains的所有keysalt 'linux-node2' grains.items # 列出主机的详细信息,可用于资产管理salt '*' grains.item os # 列出所有主机的系统版本salt '*' grains.item fqdn_ip4 # 列出所有主机的IP地址 12345678910111213# 需要配置好 vim /etc/hosts 主机名与IP解析cat /etc/salt/minion_idcat /etc/hosts[root@linux-node1 ~]# salt &apos;*&apos; grains.item fqdn_ip4linux-node1: ---------- fqdn_ip4: - 10.0.0.250linux-node2: ---------- fqdn_ip4: - 10.0.0.251 jinja2 模板12345文档：http://docs.jinkan.org/docs/jinja2/Jinja2的应用场景：针对不同的操作系统安装软件，针对不同的cpu数量、内存等动态生成软件的配置文件，都需要Jinja2以及Grains和pillar的辅助Jinja2是一个强大的python模板引擎，他的设计思想来源于Django的模板引擎，并扩展了其语法和一系列强大的功能。其中最显著的一个是增加了沙箱执行功能和可选的自动转义功能，这对大多应用的安全性来说是非常重要的。jinja模板包含 变量 或 表达式，两种分隔符: &#123;% ... %&#125; 和 &#123;&#123; ... &#125;&#125; 。前者用于执行诸如 for 循环 或赋值的语句，后者把表达式的结果打印到模板上。salt中如何使用jinja2：https://docs.saltstack.com/en/latest/topics/jinja/index.html 使用 jinja2 和 grains 修改配置文件httpd 本机IP:PORT 1234567891011121314[root@linux-node1 web]# vim lamp.sls apache-config: file.managed: - name: /etc/httpd/conf/httpd.conf - source: salt://web/files/httpd.conf - user: root - group: root - mode: 644 - template: jinja - defaults: PORT: 9090 IPADDR: &#123;&#123; grains[&apos;fqdn_ip4&apos;][0] &#125;&#125; - require: - pkg: lamp-install 1234[root@linux-node1 web]# vim files/httpd.conf/80#Listen 12.34.56.78:80Listen &#123;&#123; IPADDR &#125;&#125;:&#123;&#123; PORT &#125;&#125; 123[root@linux-node1 web]# salt &apos;linux-node2&apos; state.sls web.lamp# 验证访问:http://10.0.0.251:9090/ 日常管理生产建议12345678910111213141516171819202122232425261. 不建议使用salt的FILE模块进行代码部署 1. 命令编排的状态管理: 压缩包, file.managed cmd.run 执行部署2. 配置管理,不建议使用salt管理项目的配置文件 1. 分层管理,salt只管理应用服务,例如Nginx Tomcat Apache 2. 开发的配置文件 不管 3. 如果你有固定的文件服务器,可以使用 source: salt:// http:// ftp://4. SLS版本化 1. 创建一个git项目 2. 找一个测试环境,编写SLS, 测试git commit &amp;&amp; git push到版本仓库 3. 生产环境git pull 测试,全部执行 4. 保留操作记录 5. 完整可控:谁 什么时间 干了什么 输出是什么 5. 使用Master Job Cache 保存job的输出到SQL 1. 保存在 [root@linux-node1 web]# cd /var/cache/salt/master/jobs/ 2. 保存时长: ***** 默认24小时 vim /etc/salt/master Set the number of hours to keep old job information in the job cache: #keep_jobs: 24 include 功能:有时候我们写了很多的sls文件,这些文件可以被复用 备份1[root@linux-node1 salt]# zip -r base.zip base/ 复制lamp中安装部分,写到httpd.sls里面12345678910111213[root@linux-node1 web]# vim httpd.slslamp-install: pkg.installed: - pkgs: - httpd - php - php-pdo - php-mysql - php-cli - php-common - mariadb - mariadb-server 123456# 修改lamp.sls,引入[root@linux-node1 web]# vim lamp.sls include: - web.httpd... 12# 执行[root@linux-node1 web]# salt &apos;linux-node2&apos; state.sls web.lamp test=True 常用命令12345678910111213141516# 查看状态salt-run manage.status# 查看版本salt-run manage.versions# 测试salt &apos;*&apos; state.sls web.tomcat test=true# 修改minion_id1. 停止minion服务2. salt-key -d minion_id 删除 minion 3. rm -f /etc/salt/minion_id4. rm -rf /etc/salt/pki5. 修改配置文件ID6. 启动minio 无 master 架构123456789101112131415161718192021222324252627282930313233343536371. salt本地管理2. masterless架构 1. 没有master,相当于单机使用 2. salt 本地来执行 3. 在node1测试 1. 修改配置文件 [root@CentOS7 ~]# vim /etc/salt/minion /file_client #file_client: remote 修改成 file_client: local 2.把file_root 加进来到node1的minion配置 file_roots: base: - /srv/salt/base dev: - /srv/salt/dev test: - /srv/salt/test prod: - /srv/salt/prod 3. 关闭minion服务 [root@linux-node1 web]# systemctl stop salt-minion4. 执行状态 salt-call [root@linux-node1 web]# salt-call --local state.sls web.tomcat # --local 在本地 5. 用于单台服务器安装软件执行 1. 网络不允许上外网,只能本地安装 2. 安装saltstack 3. 把状态文件解压 4. 执行命令 5. 查看安装状态 日志入库 job cache12job cache:https://docs.saltstack.com/en/latest/ref/returners/all/salt.returners.mysql.html#module-salt.returners.mysql 安装mysql，建库建表12345678910[root@linux-node1 base]# yum -y install mariadb mariadb-server mariadb-client[root@linux-node1 base]# systemctl start mariadb[root@linux-node1 base]# systemctl enable mariadb# 初始化[root@linux-node1 base]# mysql_secure_installation# 创建用户MariaDB [(none)]&gt; grant all on salt.* to salt@10.0.0.250 identified by 'salt';MariaDB [(none)]&gt; flush privileges; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 建库建表语句CREATE DATABASE `salt` DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;USE `salt`;---- Table structure for table `jids`--DROP TABLE IF EXISTS `jids`;CREATE TABLE `jids` ( `jid` varchar(255) NOT NULL, `load` mediumtext NOT NULL, UNIQUE KEY `jid` (`jid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE INDEX jid ON jids(jid) USING BTREE;---- Table structure for table `salt_returns`--DROP TABLE IF EXISTS `salt_returns`;CREATE TABLE `salt_returns` ( `fun` varchar(50) NOT NULL, `jid` varchar(255) NOT NULL, `return` mediumtext NOT NULL, `id` varchar(255) NOT NULL, `success` varchar(10) NOT NULL, `full_ret` mediumtext NOT NULL, `alter_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP, KEY `id` (`id`), KEY `jid` (`jid`), KEY `fun` (`fun`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;---- Table structure for table `salt_events`--DROP TABLE IF EXISTS `salt_events`;CREATE TABLE `salt_events` (`id` BIGINT NOT NULL AUTO_INCREMENT,`tag` varchar(255) NOT NULL,`data` mediumtext NOT NULL,`alter_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,`master_id` varchar(255) NOT NULL,PRIMARY KEY (`id`),KEY `tag` (`tag`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 123456789101112[root@linux-node1 base]# mysql -h 10.0.0.250 -usalt -psaltMariaDB [(none)]&gt; use saltMariaDB [salt]&gt; show tables;+----------------+| Tables_in_salt |+----------------+| jids || salt_events || salt_returns |+----------------+3 rows in set (0.00 sec) 安装 MySQL-python1[root@linux-node1 base]# yum install -y MySQL-python 配置 master123456789[root@linux-node1 base]# vim /etc/salt/master# 在文档最底下添加master_job_cache: mysqlmysql.host: &apos;10.0.0.250&apos;mysql.user: &apos;salt&apos;mysql.pass: &apos;salt&apos;mysql.db: &apos;salt&apos;mysql.port: 3306 12# 重启服务[root@linux-node1 base]# systemctl restart salt-master 执行 test.ping 查看cache 是否入库123456789[root@linux-node1 base]# salt &apos;*&apos; test.pinglinux-node1: Truelinux-node2: True[root@linux-node1 base]# mysql -h 10.0.0.250 -usalt -psaltMariaDB [(none)]&gt; use saltMariaDB [salt]&gt; select * from salt_returns\G; 12345# 显示 jid 执行[root@linux-node1 base]# salt &apos;*&apos; cmd.run &apos;w&apos; -vExecuting job with jid 20191006000128231437MariaDB [salt]&gt; select * from salt_returns where jid = &apos;20191006000128231437&apos;\G; kill salt 正在执行的任务12https://www.cnblogs.com/shhnwangjian/p/6048891.htmlhttps://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.saltutil.html#module-salt.modules.saltutil 12345678salt &apos;*&apos; saltutil.running # 查看正在运行的任务，找到jidsalt &apos;*&apos; saltutil.kill_job jid # 根据jid杀掉任务salt &apos;*&apos; saltutil.clear_cache # 清除minion缓存备注：1）正在执行的salt任务，job id会存在minion端的/var/cache/salt/minion/proc目录下2）正在执行的salt任务，根据上面master cache的配置，Job的路径/var/cache/salt/master/jobs目录下 二次开发建议1231. master job cache 将所有的job输出保存到mysql2. 如果做管理平台，可以将user_id 和 jid 关联3. 使用List做目标选择 案例实战 zabbix-agent定义安装目录1[root@linux-node1 base]# mkdir -p init zabbix logstash init epel源创建目录获取yum文件12[root@linux-node1 base]# mkdir -p /srv/salt/base/init/files[root@linux-node1 files]# wget http://mirrors.aliyun.com/repo/epel-7.repo 编写 yum-repo.sls123456789[root@linux-node1 init]# vim yum-repo.slsepel-7.repo: file.managed: - name: /etc/yum.repos.d/epel-7.repo: - source: salt://init/files/epel-7.repo - user: root - group: root - mode: 644 zabbix-agent模拟安装123[root@linux-node1 files]# yum list|grep zabbix[root@linux-node1 files]# yum list|grep zabbix30-agent[root@linux-node1 files]# yum install -y zabbix30-agent 模板文件123456[root@linux-node1 file]# mkdir -p /srv/salt/base/zabbix/file[root@linux-node1 file]# cp /etc/zabbix/zabbix_agentd.conf ./[root@linux-node1 file]# vim zabbix_agentd.conf Server=&#123;&#123; SERVER_IP &#125;&#125;Hostname=&#123;&#123; AGENT_HOSTNAME &#125;&#125; 测试获取主机名123456789[root@linux-node1 file]# salt &apos;*&apos; grains.item fqdnlinux-node1: ---------- fqdn: linux-node1linux-node2: ---------- fqdn: linux-node2 编写 zabbix-agent.sls123456789101112131415161718192021222324252627282930313233343536373839404142[root@linux-node1 zabbix]# cd /srv/salt/base/zabbix/[root@linux-node1 zabbix]# vim zabbix-agent.slsinclude: - init.yum-repo # 引入epel源zabbix-agent: pkg.installed: - name: zabbix30-agent - require: - file: epel-7.repo # 依赖 file.managed: - name: /etc/zabbix_agentd.conf - source: salt://zabbix/files/zabbix_agentd.conf - user: root - group: root - mode: 644 - require: - pkg: zabbix-agent - template: jinja - defaults: SERVER_IP: 10.0.0.250 AGENT_HOSTNAME: &#123;&#123; grains[&apos;fqdn&apos;] &#125;&#125; - require: - pkg: zabbix-agent # 依赖,pkg安装后才能执行 service.running: - name: zabbix-agent - enable: True - watch: - pkg: zabbix-agent - file: zabbix-agent # 文件有变化就重启zabbix_agent.conf.d: file.directory: - name: /etc/zabbix_agent.conf.d - watch_in: - service: zabbix-agent # 目录有变化了就重启 - require: - file: zabbix-agent # 依赖,需要安装和文件都执行才能执行 - pkg: zabbix-agent 123[root@linux-node1 zabbix]# salt &apos;linux-node2&apos; state.sls zabbix.zabbix-agent test=True[root@linux-node1 zabbix]# salt &apos;linux-node2&apos; state.sls zabbix.zabbix-agent[root@linux-node1 zabbix]# salt &apos;linux-node2&apos; cmd.run &apos;netstat -tnlp&apos; 编译安装 redis创建目录123456789101112[root@linux-node1 redis]# mkdir -p /srv/salt/prod/modules/&#123;apache,haproxy,keepalived,mysql,redis&#125;[root@linux-node1 prod]# tree.└── modules ├── apache ├── haproxy ├── keepalived ├── mysql └── redis ├── files │ └── redis-4.0.14.tar.gz └── redis-install.sls 编辑基础安装文件1234567891011121314[root@linux-node1 redis]# vim redis-install.sls redis-source.install: file.managed: - name: /data/tools/redis-4.0.14.tar.gz - source: salt://modules/redis/files/redis-4.0.14.tar.gz - user: root - group: root - mode: 644 cmd.run: - name: cd /data/tools/ &amp;&amp; tar xzf redis-4.0.14.tar.gz &amp;&amp; cd redis-4.0.14 &amp;&amp; make &gt;&gt;/dev/null &amp;&amp; make install &gt;&gt;/dev/null &amp;&amp; mv /data/tools/redis-4.0.14 /data/redis - require: - file: redis-source.install - unless: test -d /data/redis || test -d /data/redis_7006 redis安装 根据需求进行安装,可以使单机、主从也可以是集群 只需要导入基础的安装,再进行相应的配置启动就可以了 实现创建好目录和基础配置文件,做好模板 123[root@linux-node1 redis]# mkdir -p /srv/salt/prod/redis/files# 清理注释并改名[root@linux-node1 files]# egrep -v &apos;#|^$&apos; /root/redis.conf &gt;/srv/salt/prod/redis/files/redis-7006.conf 1234567891011# 模板 比如单机安装的时候我们选择7006为端口[root@linux-node1 files]# vim redis-7006.conf bind 0.0.0.0port &#123;&#123; PORT &#125;&#125;daemonize yespidfile /data/redis_&#123;&#123; PORT &#125;&#125;/redis_&#123;&#123; PORT &#125;&#125;.pidlogfile /data/redis_&#123;&#123; PORT &#125;&#125;/logs/redis_&#123;&#123; PORT &#125;&#125;.logdbfilename dump_&#123;&#123; PORT &#125;&#125;.rdbdir /data/redis_&#123;&#123; PORT &#125;&#125;/datarequirepass 123456 123456789101112131415161718192021222324252627[root@linux-node1 redis]# vim redis-server.sls include: - modules.redis.redis-installredis-init: cmd.run: - name: cd /data &amp;&amp; mv redis redis_7006 &amp;&amp; mkdir -p /data/redis_7006/&#123;conf,logs,data&#125; - unless: test -d /data/redis_7006 - require: - cmd: redis-source.installredis-server: file.managed: - name: /data/redis_7006/conf/redis-7006.conf - source: salt://redis/files/redis-7006.conf - user: root - group: root - mode: 755 - template: jinja - defaults: PORT: 7006 cmd.run: - name: redis-server /data/redis_7006/conf/redis-7006.conf - require: - file: redis-server - unless: ps -ef | grep redis|grep -v &apos;grep&apos; 123# 测试执行[root@linux-node1 prod]# salt &apos;linux-node2&apos; state.sls redis.redis-server saltenv=prod test=True[root@linux-node1 prod]# salt &apos;linux-node2&apos; state.sls redis.redis-server saltenv=prod 123456789101112131415[root@linux-node1 prod]# tree.├── modules # 基础软件安装模块│ ├── apache│ ├── haproxy│ ├── keepalived│ ├── mysql│ └── redis│ ├── files│ │ └── redis-4.0.14.tar.gz│ └── redis-install.sls # 只有安装软件，也可以加上源码安装└── redis # 需求模块 ├── files │ └── redis-7006.conf └── redis-server.sls # inclued 安装即可 配置文件 启动 参考学习12https://github.com/unixhothttps://github.com/unixhot/saltbook-code/tree/master/salt/pro salt-ssh12341.salt-ssh 是 0.17.0 新引入的一个功能，不需要minion对客户端进行管理，也不需要master。2.salt-ssh 支持salt大部分的功能：如 grains、modules、state 等3.salt-ssh 没有使用ZeroMQ的通信架构，执行是串行模式类似 paramiko、pssh、ansible 这类的工具 123没有minion如何使用salt,通过salt-ssh实际上就是把salt基础的 放在客户端的/tmp 然后在本地执行，执行完成后删除写个脚本 发到客户端 执行 将结果返回 12345678910111213141516171819202122232425262728salt-ssh需要一个名单系统来确定哪些执行目标，Salt的0.17.0版本中salt-ssh引入roster系统roster系统编译成了一个数据结构，包含了targets，这些targets是一个目标系统主机列表和或如连接到这些targets# target的信息 host: # 远端主机的ip地址或者dns域名 user: # 登录的用户 passwd: # 用户密码,如果不使用此选项，则默认使用秘钥方式# 可选的部分 port: # ssh端口 sudo: # 可以通过sudo tty: # 如果设置了sudo，设置这个参数为true priv: # ssh秘钥的文件路径 timeout: # 当建立链接时等待响应时间的秒数 minion_opts: # minion的位置路径 thin_dir: # target系统的存储目录，默认是/tmp/salt-&lt;hash&gt; cmd_umask: # 使用salt-call命令的umask值 安装1234# 没有minion如何使用salt,通过salt-ssh,客户端关闭minionsystemctl stop salt-minion# 安装salt-ssh,master也是要有的,客户端需要支持ssh,python也要统一版本,生产 = python虚拟环境yum install -y salt-ssh 123456789101112# 定义配置主机: salt-ssh是串行,没有C/S 快liunx-node1: host: 10.0.0.251 user: root password: 222222 port: 22CentOS7: host: 10.0.0.252 user: root password: 222222 port: 2 执行123[root@linux-node1 salt]# salt-ssh &apos;*&apos; test.ping -i [root@linux-node1 salt]# salt-ssh &apos;*&apos; -r &apos;w&apos;[root@linux-node1 salt]# man salt-ss 总结12345678910111.salt-ssh 是在salt基础上打了一个python包上传到客户端的默认tmp目录下 在客户端上面解压并执行返回结果,最后删除tmp上传的临时文件2.salt-minion方法是salt-mater先执行语法验证，验证通过后发送到minion minion收到Msater的状态文件默认保存在/var/cache/salt/minion 注意：也有时候salt-master语法验证通过，在minion上可能因为环境问题会执行失败3.salt-ssh和salt-minion可以共存，salt-minion不依赖于ssh服务 salt-api 使用条件：1）https调用，或者需要生成证书 2）配置文件 3）使用PAM验证 4）启动salt-api12https://www.unixhot.com/docs/saltstack/topics/api.htmlhttps://www.unixhot.com/docs/saltstack/ref/netapi/all/salt.netapi.rest_cherrypy.html#a-rest-api-for-salt 安装123[root@linux-node1 salt]# yum install -y salt-api[root@linux-node1 salt]# rpm -qa|grep cherrypython-cherrypy-3.2.2-4.el7.noarch 生成证书1234[root@linux-node1 salt]# yum install pyOpenSSL -y[root@linux-node1 salt]# salt-call --local tls.create_self_signed_cert[ERROR ] You should upgrade pyOpenSSL to at least 0.14.1 to enable the use of X509 extensionslocal: Created Private Key: &quot;/etc/pki/tls/certs/localhost.key.&quot; Created Certificate: &quot;/etc/pki/tls/certs/localhost.crt.&quot; 编辑配置文件:12345678910111213141516171819202122[root@linux-node1 salt]# vim master # Include a config file from some other path:include: master.d/*.conf[root@linux-node1 salt]# mkdir master.d[root@linux-node1 master.d]# vim api.confrest_cherrypy: host: 10.0.0.251 port: 8000 ssl_crt: /etc/pki/tls/certs/localhost.crt ssl_key: /etc/pki/tls/certs/localhost.key[root@linux-node1 redis-cluster]# useradd -M -s /sbin/nologin saltapi[root@linux-node1 redis-cluster]# echo &quot;saltapi&quot; | passwd saltapi --stdin[root@linux-node1 master.d]# vim auth.conexternal_auth: pam: saltapi: - .* - &apos;@wheel&apos; - &apos;@runner&apos; - &apos;@jobs 12345[root@linux-node1 master.d]# systemctl restart salt-master[root@linux-node1 master.d]# systemctl start salt-api[root@linux-node1 master.d]# netstat -tnlp|grep 8000tcp 0 0 10.0.0.251:8000 0.0.0.0:* LISTEN 6866/python 12345curl -sSk https://10.0.0.251:8000/login \-H &apos;Accept: application/x-yaml&apos; \-d username=&apos;saltapi&apos; \-d password=&apos;saltapi&apos; \-d eauth=&apos;pam&apos; 12345678910111213141516[root@linux-node1 master.d]# curl -sSk https://10.0.0.251:8000/login \&gt; -H &apos;Accept: application/x-yaml&apos; \&gt; -d username=&apos;saltapi&apos; \&gt; -d password=&apos;saltapi&apos; \&gt; -d eauth=&apos;pam&apos;return:- eauth: pam expire: 1570315348.575254 perms: - .* - &apos;@wheel&apos; - &apos;@runner&apos; - &apos;@jobs&apos; start: 1570272148.575253 token: 596b2306cc374d7c2f228bee381cfa80031d2fd6 user: saltapi 123456789101112131415161718[root@linux-node1 master.d]# systemctl restart salt-minioncurl -sSk https://10.0.0.251:8000 \ -H &apos;Accept: application/x-yaml&apos; \ -H &apos;X-Auth-Token: 596b2306cc374d7c2f228bee381cfa80031d2fd6&apos;\ -d client=local \ -d tgt=&apos;*&apos; \ -d fun=test.ping [root@linux-node1 master.d]# curl -sSk https://10.0.0.251:8000 \&gt; -H &apos;Accept: application/x-yaml&apos; \&gt; -H &apos;X-Auth-Token: 596b2306cc374d7c2f228bee381cfa80031d2fd6&apos;\&gt; -d client=local \&gt; -d tgt=&apos;*&apos; \&gt; -d fun=test.pingreturn:- CentOS7: true linux-node1.example.com: true Master高可用多master1https://www.unixhot.com/docs/saltstack/topics/tutorials/multimaster.html 12345678master 配置文件相同master file_roots 一样同步master的公钥和私钥minion 配置文件都是双机systemctl restart salt-minionnode2 做认证 salt-key -A别忘记安装MySQL-python 还有 mysql的登录授权给node2grant all on salt.* to salt@10.0.0.252 identified by &apos;salt&apos;]]></content>
      <categories>
        <category>SaltStack</category>
      </categories>
      <tags>
        <tag>salt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django ORM]]></title>
    <url>%2F2019%2F09%2F27%2Fdjango-orm%2F</url>
    <content type="text"><![CDATA[Django ORM系统ORM介绍对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中 ORM的优势ORM解决的主要问题是对象和关系的映射。它通常把一个类和一个表一一对应，类的每个实例对应表中的一条记录，类的每个属性对应表中的每个字段。ORM提供了对数据库的映射，不用直接编写SQL代码，只需像操作对象一样从数据库操作数据。让软件开发人员专注于业务逻辑的处理，提高了开发效率。 ORM的劣势ORM的缺点是会在一定程度上牺牲程序的执行效率。ORM用多了SQL语句就不会写了，关系数据库相关技能退化… ORM的总结ORM只是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。但我们不能指望某个工具能一劳永逸地解决所有问题，一些特殊问题还是需要特殊处理的。但是在整个软件开发过程中需要特殊处理的情况应该都是很少的，否则所谓的工具也就失去了它存在的意义。 Django中的ORMDjango项目如何使用ORM连接MySQL 手动创建数据库 1CREATE DATABASE mybook CHARSET utf8 在settings.py里面配置数据库信息(告诉Django连接哪一个数据库) 1234567891011121314151617DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'mybook', 'HOST': '10.0.0.200', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', &#125;, 'test':&#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'test', 'HOST': '10.0.0.200', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', &#125;&#125; 在项目下的init.py文件中,告诉Django用pymysql代替MySQLdb连接数据库 12import pymysqlpymysql.install_as_MySQLdb( 在app/models.py 中定义类，类一定要继承models.Model 123class Book(models.Model): id = models.AutoField(primary_key=True) title = models.CharField(max_length=32 执行两条命令: 123451. 在哪执行: 在项目的根目录(有manage.py文件的目录):2. 命令: python manage.py makemigrations --&gt; 将models.py文件中的改动记录在app/migrations 目录下 python manage.py migrate --&gt; 将改动翻译成SQL语句，去数据库中执行 Model在Django中model是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表， 基本情况： 每个模型都是一个Python类，它是django.db.models.Model的子类。 模型的每个属性都代表一个数据库字段。综上所述，Django为您提供了一个自动生成的数据库访问API，详询官方文档链接。 快速入门下面这个例子定义了一个 Person 模型，包含 first_name 和 last_name。 12345from django.db import modelsclass Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) first_name 和 last_name 是模型的字段。每个字段被指定为一个类属性，每个属性映射到一个数据库列。12345CREATE TABLE myapp_person ( "id" serial NOT NULL PRIMARY KEY, "first_name" varchar(30) NOT NULL, "last_name" varchar(30) NOT NULL); 一些说明： 表myapp_person的名称是自动生成的，如果你要自定义表名，需要在model的Meta类中指定 db_table 参数，强烈建议使用小写表名，特别是使用MySQL作为后端数据库时。 id字段是自动添加的，如果你想要指定自定义主键，只需在其中一个字段中指定 primary_key=True 即可。如果Django发现你已经明确地设置了Field.primary_key，它将不会添加自动ID列。 本示例中的CREATE TABLE SQL使用PostgreSQL语法进行格式化，但值得注意的是，Django会根据配置文件中指定的数据库后端类型来生成相应的SQL语句。 Django支持MySQL5.5及更高版本。 表与表之间的关系 一对多(出版社和书) 外键:publisher = models.ForeignKey(to=’Publisher’) 在数据库里有没有publisher这个字段？数据库实际生成的是 publisher_id ,Django默认加上_i 多对多(作者和书) 多对多关联:from Django.db import modelsbooks = models.ManyToManyField(to=’Book’)多对多在数据库中，是通过第三章表建立的关 增删改查操作 单表增删改查: 1234567891011121314增: from app01 import models models.Publisher.objects.create(name=&quot;新街口出版社&quot;)查: models.Publisher.objects.get(id=1) models.Publisher.objects.get((name=&quot;新街口出版社&quot;))删: models.Publisher.objects.get(id=1).delete() 改: obj = models.Publisher.objects.get(id=1) obj.name = &quot;西单出版社&quot; obj.save() 外键的增删改查: 12345678增、删、查同上book_obj = models.Book.objects.get(id=1)# book_obj.Publisher 是什么? 和这本书关联的出版社对象 ***** book_obj.Publisher.id # id book_obj.Publisher.name # 名称# book_obj.Publisher_id 是什么? 和这本书关联的出版社ID 多对多操作: 1234561. 查询id为1的作者都写过哪些书: author_obj = models.Author.objects.get(id=1) author_obj.books.all() --&gt; 好我这个作者关联的所有的书籍对象 2. 想给作者绑定多本书 author_obj = models.Author.objects.get(id=1) author_obj.books.set([1,2,3]) --&gt; 把ID是1,2,3的书和我这个作者关联上 Django ORM 常用字段和参数1234567891011121314AutoFieldint自增列，必须填入参数 primary_key=True。当model中如果没有自增列，则自动会创建一个列名为id的列。IntegerField一个整数类型,范围在 -2147483648 to 2147483647。CharField字符类型，必须提供max_length参数， max_length表示字符长度。DateField日期字段，日期格式 YYYY-MM-DD，相当于Python中的datetime.date()实例。DateTimeField日期时间字段，格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]，相当于Python中的datetime.datetime()实例。 基础使用1234567891011121314151617181920212223242526272829303132333435# models.pyclass FixedCharField(models.Field): """ 自定义的char类型的字段类 """ def __init__(self, max_length, *args, **kwargs): super().__init__(max_length=max_length, *args, **kwargs) self.length = max_length def db_type(self, connection): """ 限定生成数据库表的字段类型为char，长度为length指定的值 """ return 'char(%s)' % self.lengthclass Game_assets(models.Model): id = models.AutoField(primary_key=True) address = models.CharField(max_length=64,unique=True) port = models.IntegerField() user = models.CharField(max_length=64) password = models.CharField(max_length=64) name = FixedCharField(max_length=64,default='game_admin') # char(64) # 时间字段独有: # DatetimeField、DateField、TimeField这个三个时间字段，都可以设置如下属性。 # auto_now_add # 配置auto_now_add = True，创建数据记录的时候会把当前时间添加到数据库。 # auto_now # 配置上auto_now = True，每次更新数据记录的时候会更新该字段。 create_time = models.DateField(auto_now_add=True) update_time = models.DateTimeField(auto_now = True) 1234567891011121314# Create TableCREATE TABLE `app02_game_assets` ( `id` int(11) NOT NULL AUTO_INCREMENT, `address` varchar(64) NOT NULL, `port` int(11) NOT NULL, `user` varchar(64) NOT NULL, `password` varchar(64) NOT NULL, `create_time` date NOT NULL, `update_time` datetime(6) NOT NULL, `name` char(64) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `app02_game_assets_address_276ba0ac_uniq` (`address`)) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 12&gt;&gt;&gt; from app02 import models&gt;&gt;&gt; models.Game_assets.objects.create(address='10.0.0.204',port='3306',user='root',password='123456',name='leo') 字段参数123456null：用于表示某个字段可以为空。unique：如果设置为unique=True 则该字段在此表中必须是唯一的 。db_index：如果db_index=True 则代表着为此字段设置数据库索引。default：为该字段设置默认值。auto_now_add：配置auto_now_add=True，创建数据记录的时候会把当前时间添加到数据库。auto_now：配置上auto_now=True，每次更新数据记录的时候会更新该字段。 ORM 操作基础操作,必知必会13条:all 查询所有结果12345678910111213import osif __name__ == '__main__': os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ORM_test.settings") import django django.setup() from app01 import models ret = models.Person.objects.all() print(ret) # &lt;QuerySet [&lt;Person: &lt;Penson object:leo&gt;&gt;, &lt;Person: &lt;Penson object:lex&gt;&gt;, # &lt;Person: &lt;Penson object:rubin&gt;&gt;, &lt;Person: &lt;Penson object:夜雨&gt;&gt;]&gt; filter 筛选123456789# 它包含了与所给筛选条件相匹配的对象# filterret = models.Person.objects.filter(id=1)print(ret) # &lt;QuerySet [&lt;Person: &lt;Penson object:leo&gt;&gt;]&gt; 返回查询的结果集，将结果放在 QuerySet对象(列表)print(ret[0]) # &lt;Penson object:leo&gt; 根据索引取得对象# filter id &gt; 1的数据ret = models.Person.objects.filter(id=100)print(ret) # 如果查询不到结果,将返回一个&lt;QuerySet [] get 筛选1234567# get查询# 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。# 如果查询条件不存在,报错ret = models.Person.objects.get(id=1)# ret = models.Person.objects.get(name='夜雨')print(ret) # &lt;Penson object:leo&gt; 具体的对象 exclude 筛选不匹配12345# exclude 它包含了与所给筛选条件不匹配的对象ret = models.Person.objects.exclude(id=1)print(ret) # 返回不匹配的对象ret = models.Person.objectsexclude(id=100)print(ret) # 不存在就返回所有 values 返回可迭代的字典序列123# values 返回一个QuerySet对象,里面都是字典,不写字段名默认查询所有字段ret = models.Person.objects.values("name","birthday")print(ret values_list 返回可迭代的元组序列123# values_list 返回一个QuerySet对象,里面都是元祖ret = models.Person.objects.values_list("name","birthday")print(ret order_by 按照指定的字段排序123# ret = models.Person.objects.all() # ordering = "birthday"ret = models.Person.objects.all().order_by("id")print(ret reverse 对一个有序的QuerySet 反向排序12345# 通常都使用order_by,不使用meta# 通常只能在具有已定义顺序的QuerySet上调用(在model类的Meta中指定ordering或调用order_by()方法)# ret = models.Person.objects.all().reverse() # ordering = "birthday"ret = models.Person.objects.all().order_by("birthday").reverse()print(ret) distinct 从返回结果中剔除重复纪录count 返回QuerySet对象中对象的数量12ret = models.Person.objects.all().count()print(ret) first 返回QuerySet第一个对象12ret = models.Person.objects.all().first()print(ret) last 返回QuerySet最后一个对象12ret = models.Person.objects.all().last()print(ret) exists 判断表里是否有数据12ret = models.Person.objects.all().exists()print(ret) # True 单表的双下划线查询123456789101112131415161718192021222324252627282930313233343536373839404142434445# 单表查询的 双下划线方法# 大于和小于# 查询ID &gt; 1 and ID &lt; 4ret = models.Person.objects.filter(id__gt=1,id__lt=4)print(ret) # &lt;QuerySet [&lt;Person: &lt;Penson object:lex&gt;&gt;, &lt;Person: &lt;Penson object:rubin&gt;&gt;]&gt;# in 在...范围# 查询id在[1,3,5]中的结果ret = models.Person.objects.filter(id__in=[1,3,5])print(ret) # &lt;QuerySet [&lt;Person: &lt;Penson object:leo&gt;&gt;, &lt;Person: &lt;Penson object:rubin&gt;&gt;]&gt;# not in 不在...范围# 查询id不在[1,3,5]中的结果ret = models.Person.objects.exclude(id__in=[1, 3, 5])print(ret) # &lt;QuerySet [&lt;Person: &lt;Penson object:lex&gt;&gt;, &lt;Person: &lt;Penson object:夜雨&gt;&gt;]&gt;# contains 检索,模糊查询# 获取name字段包含"l"的结果ret = models.Person.objects.filter(name__contains='l')print(ret)ret = models.Person.objects.filter(name__contains='夜')print(ret) # &lt;QuerySet [&lt;Person: &lt;Penson object:leo&gt;&gt;, &lt;Person: &lt;Penson object:lex&gt;&gt;]&gt;# icontains 英文检索print('icontains'.center(80,'*'))# 英文检索ret = models.Person.objects.filter(name__icontains='l')print(ret)ret = models.Person.objects.filter(name__icontains='夜')print(ret)# range 范围查询# 判断ID值在哪个范围之内 SQL语句中的between and 1&lt;= &lt;=3ret = models.Person.objects.filter(id__range=[1,3])print(ret)# 类似的还有：startswith，istartswith, endswith, iendswith # 日期和时间字段可以有以下写法ret = models.Person.objects.filter(birthday__year=2018)print(ret)ret = models.Person.objects.filter(birthday__month=9)print(ret) ForeignKey操作外键的 正向查询 和 反向查询 先看外键在哪张表里 从有外键字段的表 查询 正向查询,反之 叫做反向查询 正向查询12345678# 基于对象 跨表查询book_obj = models.Book.objects.first()ret = book_obj.publisher # 和这本书关联的出版社对象print(ret, type(ret)) # 西单出版社 &lt;class 'app01.models.Publisher'&gt;# 对象.属性ret = book_obj.publisher.nameprint(ret,type(ret)) # 西单出版社 &lt;class 'str'&gt; 123456# 双下划线 跨表查询# 查询ID是1的书的出版社名称# __双下划线就表示 跨了一张表ret = models.Book.objects.filter(id=1).values("publisher__name")# ret = models.Book.objects.filter(id=1).values_list("publisher__name")print(ret) # &lt;QuerySet [&#123;'publisher__name': '西单出版社'&#125;]&gt; 反向查询1234567891011121314# 基于对象 跨表查询# 第一个出版社出版了什么书publisher_obj = models.Publisher.objects.first() # 得到一个具体的对象# 关联表名小写 + _set# ret = publisher_obj.book_set.all()# models里面的 related_name 参数可以代替关联表名小写 + _set# related_name="books" 反向查询是用来代替 book_set# publisher = models.ForeignKey(to='Publisher',related_name="books")ret = publisher_obj.books.all()# models里面的 related_query_name= 是直接代替表名,用的不多print(ret) # &lt;QuerySet [&lt;Book: Python&gt;, &lt;Book: CSS&gt;]&gt; 1234# 双下划线 跨表查询# 使用filter得到的QuerySet对象 才可以 values_list() 和 values()ret = models.Publisher.objects.filter(id=1).values_list("books__title")print(ret) # &lt;QuerySet [('Python',), ('CSS',)]&gt; 12345678910111213141516# models.py 外键表配置class Book(models.Model): id = models.AutoField(primary_key=True) title = models.CharField(max_length=32) # 外键: # related_name="books" 反向查询是用来代替 book_set publisher = models.ForeignKey( to='Publisher', on_delete=models.CASCADE, # 删除关联数据时,应该怎么处理，默认级联操作,Django2.0要写上 related_name="books", # 反向查询的时候 用来代替 表名_set related_query_name="books" # 反向双下划线跨表查询用来代替表名 ) def __str__(self): return self.title Django终端打印SQL语句12345678910111213141516171819# ORM操作 查看具体的SQL语句# 在Django项目的settings.py文件中配置LOGGING = &#123; 'version': 1, 'disable_existing_loggers': False, 'handlers': &#123; 'console':&#123; 'level':'DEBUG', 'class':'logging.StreamHandler', &#125;, &#125;, 'loggers': &#123; 'django.db.backends': &#123; 'handlers': ['console'], 'propagate': True, 'level':'DEBUG', &#125;, &#125;&#125; 多对多查询“关联管理器”是在一对多或者多对多的关联上下文中使用的管理器。 它存在于下面两种情况： 外键关系的反向查询 多对多关联关系 简单来说就是当 点后面的对象 可能存在多个的时候就可以使用以下的方法。 123456789# 多对多# 获取作者对象author_obj = models.Author.objects.first()pint(author_obj.name) # Leo# 查询leo都出版了哪些书ret = author_obj.books.all()print(type(author_obj.books)) # ManyRelatedManager 关联管理类对象print(ret) # &lt;QuerySet [&lt;Book: Python&gt;]&gt; 123456# 1. create# 通过作者创建一本书,会自动保存不用提交# 两部操作:# 在关联表里添加关系#在书籍表里添加了一本新书author_obj.books.create(title="番茄物语",publisher_id=2) 123456789101112# 2. add# 给leo添加一本 id=5 的书book_obj = models.Book.objects.get(id=5)author_obj.books.add(book_obj)# 添加多个book_objs = models.Book.objects.filter(id__gt=5)author_obj.books.add(*book_objs) # 要把列表打散再传进去print(*book_objs)# 直接添加IDauthor_obj.books.add(8) 1234567# revome# 从leo关联的书 把 做饭大全删除掉book_obj = models.Book.objects.get(title='做饭大全')author_obj.books.remove(book_obj)# 直接删除IDauthor_obj.books.remove(5 1234567891011# clear# 清空# 把作者ID是2的 所有图书一起删除author_obj = models.Author.objects.get(id=2)author_obj.books.clear()# 额外补充,外键的反向操作# 找到ID是1的 出版社publisher_obj = models.Publisher.objects.get(id=1)# object has no attribute 'clear' 当这个外键可以为空时,才能够clearpublisher_obj.books.clear( 12对于所有类型的关联字段，add()、create()、remove()和clear(),set()都会马上更新数据库。换句话说，在关联的任何一端，都不需要再调用save()方法。 聚合查询和分组查询123456789101112131415# 聚合 aggregatefrom django.db.models import Avg, Sum, Max, Min, Countret = models.Book.objects.all().aggregate(Avg("price"))print(ret)ret = models.Book.objects.all().aggregate(price_avg = Avg("price"))print(ret) # &#123;'price_avg': 50.0&#125;# 多个参数ret = models.Book.objects.all().aggregate( price_avg = Avg("price"), price_max = Max("price"), price_min = Min("price"),)print(ret) # &#123;'price_avg': 50.0, 'price_max': Decimal('80.00'), 'price_min': Decimal('20.00')&#125;print(ret.get("price_max"),type(ret.get("price_max"))) # 80.00 &lt;class 'decimal.Decimal'&gt; 123456789101112131415161718# 分组 annotate# group by# 统计每一本书的作者个数book_list = models.Book.objects.all().annotate(author_num=Count("author"))for book in book_list : print("书名:",book.title,"作者数量:",book.author_num)# 查询作者数量大于1的书ret = models.Book.objects.all().annotate(author_num=Count("author")).filter(author_num__gt=1)print(ret)# 查询各个作者出的书的总价格ret = models.Author.objects.all().annotate(price_sum=Sum("books__price")).values_list("name","price_sum")print(ret)ret = models.Author.objects.all().annotate(price_sum=Sum("books__price"))for i in ret: print(i,i.name,i.price_sum) F查询和Q查询1234567891011121314151617181920212223242526# 价格大于9.9的书ret = models.Book.objects.all().filter(price__gt=9.9)print(ret)# 两个字段的值做比较 使用F查询# 字段之间做加减# 增加两个字段 : 卖书的数量 和 库存数# 库存数 大于 卖出数的 所有数from django.db.models import Fret = models.Book.objects.filter(kucun__gt=F("maichu"))print(ret) # &lt;QuerySet [&lt;Book: Python&gt;, &lt;Book: 做饭大全&gt;, &lt;Book: 宇宙大全&gt;]&gt;# 刷单,把每一本书的卖出数都乘以3# obj = models.Book.objects.first()# obj.maichu = 1000 * 3# obj.save()# 具体的对象没有update方法,QureySet对象才有# models.Book.objects.update(maichu=F("maichu") / 100)# 把所有书名后面加上(第一版)# 修改char字段咋办？from django.db.models.functions import Concatfrom django.db.models import Value# models.Book.objects.all().update(title=Concat(F("title"), Value("("), Value("第一版"), Value(")"))) 1234567891011121314# Q查询# 卖出数大于1000，并且 价格小于100的书# ret = models.Book.objects.filter(maichu__gt=1000,price__lt=100)# print(ret)# 卖出数大于5000，或者 价格小于100的书from django.db.models import Qret = models.Book.objects.filter(Q(maichu__gt=1000) | Q(price__lt=100))print(ret)# 书名里 包含 "大全"的书# Q查询和字段查询同时存在时,字典查询需要放在Q查询的后面ret2 = models.Book.objects.filter(Q(maichu__gt=1000) | Q(price__lt=100),title__contains="大全")print(ret2 在Python脚本中调用Django环境1234567891011import osif __name__ == '__main__': os.environ.setdefault("DJANGO_SETTINGS_MODULE", "BMS.settings") import django django.setup() from app01 import models books = models.Book.objects.all() print(books) 返回对象和QuerySet1234567# 返回QuerySet对象的方法有all()filter()exclude()order_by()reverse()distinct() 123# 特殊的QuerySet values() # 返回一个可迭代的字典序列values_list() # 返回一个可迭代的元祖序列 1234# 返回具体对象的get()first()last() 12# 返回布尔值的方法有：exists() 12# 返回数字的方法有count() 练习单标双下划线1234567891011121314151617181920212223# 获取id大于1 且 小于5的书籍book_list = models.Book.objects.filter(id__gt=1,id__lt=5)print(book_list)# 获取id等于1、2、3的数据book_list = models.Book.objects.filter(id__in=[1,2,3])print(book_list)# 获取id不等于1、2、3的数据book_list = models.Book.objects.exclude(id__in=[1,2,3])print(book_list)# 获取title字段包含"大全"的书籍book_list = models.Book.objects.filter(title__contains="大全")print(book_list)# id范围是1到3的书book_list = models.Book.objects.filter(id__range=[1,3])print(book_list)# 查询人员生日是09月的author_list= models.Person.objects.filter(birthday__month=9)print(author_list) 正向查询123456789101112131415161718192021222324# 正向查询# 获取书籍ID为5的出版社名称# 对象查找（跨表）# 对象.关联字段.属性book_obj = models.Book.objects.get(id=5)print(book_obj.publisher.name)# 字段查找（跨表）# 关联字段__字段ret = models.Book.objects.filter(id=5).values_list("publisher__name")print(ret) # &lt;QuerySet [('新街口出版社',)]&gt;# 反向查询# 获取id=2的出版社 出版的所有书籍# 对象查找 obj.表名_setpub_obj = models.Publisher.objects.get(id=2)ret = pub_obj.books.all().values_list("title") # 找到id=2这个出版社所有的书print(ret) # &lt;QuerySet [('Linux',), ('番茄物语',), ('做饭大全',), ('新西兰攻略',)]&gt;# 字段查找# 表名__字段ret = models.Publisher.objects.filter(id=2).values_list("books__title")print(ret) # &lt;QuerySet [('Linux',), ('番茄物语',), ('做饭大全',), ('新西兰攻略',)]]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 进阶]]></title>
    <url>%2F2019%2F09%2F08%2Fdjango-plus%2F</url>
    <content type="text"><![CDATA[MVC框架 和 MTV框架MVC,全名是Model View Controller，是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型(Model)、视图(View) 和 控制器(Controller)，具有耦合性低、重用性高、生命周期成本低等优点。 Django的 MTV模式Django框架的设计模式借鉴了MVC框架的思想，也是分成三部分，来降低各个部分之间的耦合性。Django框架的不同之处在于它拆分的三部分为：Model（模型）、Template（模板）和 View（视图），也就是MTV框架。 123Model(模型)：负责业务对象与数据库的对象(ORM)Template(模版)：负责如何把页面展示给用户View(视图)：负责业务逻辑，并在适当的时候调用Model和Template 介绍Django框架时,可以说: Django框架类似MCV模式，不同的是他的模式成为MTV模式。此外，Django还有一个urls分发器，它的作用是将一个个URL的页面请求分发给不同的view处理，view再调用相应的Model和Template Django 模板系统常用语法1231. 只需要记两种特殊符号：&#123;&#123; &#125;&#125;和 &#123;% %&#125;2. 变量相关的用&#123;&#123; &#125;&#125;，逻辑相关的用&#123;% %&#125;。 变量123456789101112在Django的模板语言中按此语法使用：&#123;&#123; 变量名 &#125;&#125;当模版引擎遇到一个变量，它将计算这个变量，然后用结果替换掉它本身。 变量的命名包括任何字母数字以及下划线 (&quot;_&quot;)的组合。 变量名称中不能有空格或标点符号。# 点（.）在模板语言中有特殊的含义。当模版系统遇到点(&quot;.&quot;)，它将以这样的顺序查询：字典查询（Dictionary lookup）属性或方法查询（Attribute or method lookup）数字索引查询（Numeric index lookup）# 注意事项：如果计算结果的值是可调用的，它将被无参数的调用。调用的结果将成为模版的值。如果使用的变量不存在， 模版系统将插入 string_if_invalid 选项的值， 它被默认设置为&apos;&apos; (空字符串) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243# views中的变量的例子:# 模板语言测试例子class Person: def __init__(self,name,age): self.name = name self.age = age def __str__(self): return "&lt;Object &#123;&#125; name&gt;" .format(self.name) def dream(self): return "梦想" def __unicode__(self): return "打印的对象 Python2 调用这个" def t_test(request): name = "leo" age = 28 name_list = ["leo", "lex", "rubin"] name_dict = &#123;"first_name": "leo", "last_name": "Lex"&#125; # 实例化类 p1 = Person("雷尼",18) p2 = Person("加纳",18) # 列表类 p_list = [p1,p2] return render( request, 't_test.html', &#123; "name": name, "age": age, "name_list": name_list, "name_dict": name_dict, "person":p1, "p_list":p_list, &#125; ) 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--模板中支持的写法：--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;模板语言测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;传值:字符、数字、列表、字典&lt;/p&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; age &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name_list &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name_dict &#125;&#125;&lt;/p&gt;&#123;#不传值不显示#&#125;&lt;p&gt;传送不存在的变量: &#123;&#123; null &#125;&#125;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;传值:类对象,类列表&lt;/p&gt;&lt;p&gt;&#123;&#123; person &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; person.name &#125;&#125;&lt;/p&gt;&#123;#模板语言里,方法不要加括号(),只能调用不带参数的方法#&#125;&lt;p&gt;&#123;&#123; person.dream &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; p_list.0 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; p_list.1.name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; p_list.1.dream &#125;&#125;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;字典&lt;/p&gt;&lt;!--如果字典中有一个key叫做items,字典key的优先级,要大于方法items的优先级--&gt;&lt;p&gt;&#123;&#123; name_dict.first_name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name_dict.last_name &#125;&#125;&lt;/p&gt;&#123;% for k,v in name_dict.items %&#125; &#123;&#123; k &#125;&#125; : &#123;&#123; v &#125;&#125;&#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; Filters（过滤器）1234在Django的模板语言中，通过使用 过滤器 来改变变量的显示。过滤器的语法： &#123;&#123; value|filter_name:参数 &#125;&#125;使用管道符&quot;|&quot;来应用过滤器。例如：&#123;&#123; name|lower &#125;&#125;会将name变量应用lower过滤器之后再显示它的值。lower在这里的作用是将文本全都变成小写。 123456注意事项：过滤器支持“链式”操作。即一个过滤器的输出作为另一个过滤器的输入。过滤器可以接受参数，例如：&#123;&#123; sss|truncatewords:30 &#125;&#125;，这将显示sss的前30个词。过滤器参数包含空格的话，必须用引号包裹起来。比如使用逗号和空格去连接一个列表中的元素，如：&#123;&#123; list|join:&apos;, &apos; &#125;&#125;&apos;|&apos;左右没有空格没有空格没有空格 Django的模板语言中提供了大约六十个内置过滤器。 default如果一个变量是false或者为空，使用给定的默认值。 否则，使用变量的值。 12&lt;!--如果value没有传值或者值为空的话就显示nothing--&gt;&lt;p&gt;传送不存在的变量: &#123;&#123; null|default:"没有传值" &#125;&#125;&lt;/p&gt; length返回值的长度，作用于字符串和列表。 1234&lt;!--返回value的长度，如 value=['a', 'b', 'c', 'd']的话，就显示4--&gt;&lt;p&gt;&#123;&#123; name|length &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name_list|length &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name_dict|length &#125;&#125;&lt;/p&gt; filesizeformat将值格式化为一个 “人类可读的” 文件尺寸 （例如 ‘13 KB’, ‘4.1 MB’, ‘102 bytes’, 等等）。例如： 12&lt;!-- 如果 value 是 123456789，输出将会是 117.7 MB。--&gt;&lt;p&gt;&#123;&#123; file_size|filesizeformat &#125;&#125;&lt;/p&gt; slice切片 1&#123;&#123;value|slice:"2:-1"&#125;&#125; date格式化 12&#123;&#123; value|date:"Y-m-d H:i:s"&#125;&#125;&lt;p&gt;&#123;&#123; now_time|date:"Y-m-d H:i:s" &#125;&#125;&lt;/p&gt; safe12345Django的模板中会对HTML标签和JS等语法标签进行自动转义，原因显而易见，这样是为了安全。但是有的时候我们可能不希望这些HTML元素被转义，比如我们做一个内容管理系统，后台添加的文章中是经过修饰的，这些修饰可能是通过一个类似于FCKeditor编辑加注了HTML修饰符的文本，如果自动转义的话显示的就是保护HTML标签的源文件。为了在Django中关闭HTML的自动转义有两种方式，如果是一个单独的变量我们可以通过过滤器“|safe”的方式告诉Django这段代码是安全的不必转义。 1234&#123;#多用于文章评论时,放入的html连接或者其他恶意如死循环代码XSS攻击,跨站脚本攻击,做安全效验转义#&#125;&#123;#评论一定不要加save,就让其成为文本即可#&#125;&lt;p&gt;a标签 &#123;&#123; a_html|safe &#125;&#125;&lt;/p&gt;&lt;p&gt;script签: &#123;&#123; script_html &#125;&#125;&lt;/p&gt; truncatecharstruncatechars 如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“…”）结尾。参数：截断的字符数 1&lt;p&gt;&#123;&#123; p_str|truncatechars:5 &#125;&#125;&lt;/p&gt; 自定义filter12345自定义过滤器只是带有一个或两个参数的Python函数:变量（输入）的值 - -不一定是一个字符串参数的值 - 这可以有一个默认值，或完全省略例如，在过滤器&#123;&#123;var | foo:&apos;bar&apos;&#125;&#125;中，过滤器foo将传递变量var和参数“bar”。 自定义filter代码文件摆放位置： 1234567app01/ __init__.py models.py templatetags/ # 在app01下面新建一个package package:templatetags __init__.py app01_filters.py # 建一个存放自定义filter的文件 views.py 编写自定义filter 1234567891011121314151617from django import template# 注册器register = template.Library()@register.filter(name="come_on")def come_on(arg): return "&#123;&#125; you got it!" .format(arg)@register.filter(name="addstr")def addstr(arg,arg2): """ :param arg: 第一个参数永远是管道符|，前面的那个变量 :param arg2: 后面的参数，冒号后面引号里面的变量 :return: """ return "&#123;&#125; &#123;&#125; you got it!" .format(arg,arg2) 使用自定义filter需要重启项目加载 123456789&lt;hr&gt;&#123;# 自定义filter #&#125;&#123;# 先导入我们自定义filter那个文件 #&#125;&#123;# 需要重启项目加载 #&#125;&#123;% load app01_filters %&#125;&#123;# 使用我们自定义的filter #&#125;&lt;p&gt;&#123;&#123; name|come_on &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name|addstr:"加油兄弟" &#125;&#125;&lt;/p&gt; Tagsfor循环普通for循环 12345&lt;ul&gt;&#123;% for user in user_list %&#125; &lt;li&gt;&#123;&#123; user.name &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; for循环可用的一些参数： 12345&lt;p&gt;for 循环 &#123;% for name in name_list %&#125; &lt;li&gt;&#123;&#123; forloop.counter &#125;&#125; &#123;&#123; name &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/p&gt; for … empty 1234&#123;% for book in book_list %&#125;&#123;% empty %&#125; &lt;p&gt;暂时没有数据&lt;/p&gt;&#123;% endfor %&#125; 双层for循环 12345678910&lt;p&gt;双层for循环&lt;/p&gt;&#123;% for li in name2_list %&#125; &#123;&#123; li &#125;&#125; &#123;&#123; forloop.counter &#125;&#125; &#123;% for name in li %&#125; &#123;&#123; name &#125;&#125; &#123;&#123; forloop.counter &#125;&#125; &#123;&#123; forloop.parentloop.counter &#125;&#125; &#123;% endfor %&#125;&#123;% endfor %&#125; if判断if,elif和elseif语句支持 and 、or、==、&gt;、&lt;、!=、&lt;=、&gt;=、in、not in、is、is not判断。 1234567&#123;% if user_list %&#125; 用户人数：&#123;&#123; user_list|length &#125;&#125;&#123;% elif black_list %&#125; 黑名单数：&#123;&#123; black_list|length &#125;&#125;&#123;% else %&#125; 没有用户&#123;% endif %&#125; 12345678&lt;p&gt;if ... elif ... else&lt;/p&gt; &#123;% if p3 %&#125; &lt;p&gt;p3:&#123;&#123; p3 &#125;&#125;&lt;/p&gt; &#123;% elif p2 %&#125; &lt;p&gt;p2:&#123;&#123; p2 &#125;&#125;&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;什么人都没有&lt;/p&gt; &#123;% endif %&#125; 12345&#123;% if name_list|length &gt;= 3 %&#125; &lt;p&gt;需要两辆车&lt;/p&gt;&#123;% else %&#125; &lt;p&gt;一台车&lt;/p&gt;&#123;% endif %&#125; with定义一个中间变量，多用于给一个复杂的变量起别名,注意等号左右不要加空格 123456&lt;p&gt;with&lt;/p&gt;&#123;&#123; name_list.1.1 &#125;&#125;&#123;% with k=name_list.1.1 %&#125; &#123;&#123; k &#125;&#125;&#123;% endwith %&#125; 注释 和 注意事项1&#123;# ...注释... #&#125; 1234567891011121314151. Django的模板语言不支持连续判断，即不支持以下写法：&#123;% if a &gt; b &gt; c %&#125;...&#123;% endif %&#125; 2. Django的模板语言中属性的优先级大于方法def xx(request): d = &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;items&quot;: &quot;100&quot;&#125; return render(request, &quot;xx.html&quot;, &#123;&quot;data&quot;: d&#125;)如上，我们在使用render方法渲染一个页面的时候，传的字典d有一个key是items并且还有默认的 d.items() 方法，此时在模板语言中:&#123;&#123; data.items &#125;&#125;默认会取d的items key的值。 母版和继承为什么要有母版和继承html页面有重复的时候,把他们提取出来放到一个单独的html文件(比如:导航条和左侧菜单),把多个页面公用的部分提取出来,放在一个母版页面里面,其他的页面只需要 继承 母版就可以了 具体使用的步骤 把公用的HTML部分提取出来，在项目目录templates中新建一个 base.html 基础页面，将内容放入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0042)https://v3.bootcss.com/examples/dashboard/ --&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;link rel="icon" href="https://v3.bootcss.com/favicon.ico"&gt; &lt;title&gt;图书管理系统&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="/static/bootstrap/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="/static/dashboard.css" rel="stylesheet"&gt; &lt;link rel="stylesheet" href="/static/fontawesome/css/font-awesome.min.css"&gt; &#123;#专门替换css文件的块,别的页面没有用到#&#125; &#123;% block page_css %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&#123;#&#123;% include "nav.html" %&#125;#&#125;&lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;ul class="nav nav-sidebar"&gt; &#123;#只要传来的值有all_book或者author_list、publisher_list 我就给这个li加成选中状态#&#125; &lt;li class= "&#123;% block publisher_class %&#125;&#123;% endblock %&#125;"&gt; &lt;a href="/publisher_list/"&gt;出版社列表页&lt;/a&gt;&lt;/li&gt; &lt;li class= "&#123;% block book_class %&#125;&#123;% endblock %&#125;"&gt; &lt;a href="/book_list/"&gt;书籍列表&lt;/a&gt;&lt;/li&gt; &lt;li class= "&#123;% block author_class %&#125;&#123;% endblock %&#125;"&gt; &lt;a href="/author_list/"&gt;作者列表&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &#123;# 需要替换的部分,每个页面内容不同 #&#125; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &#123;# 这里是每个页面内容不同 #&#125; &#123;% block page-main %&#125; &#123;% endblock %&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="modal fade" tabindex="-1" role="dialog" id="myModal"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title"&gt;用户信息&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;邮箱&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;密码&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" class="form-control" id="inputPassword3" placeholder="Password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;取消&lt;/button&gt; &lt;button type="button" class="btn btn-primary"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;&lt;/div&gt;&lt;!-- /.modal --&gt;&lt;!-- Bootstrap core JavaScript================================================== --&gt;&lt;!-- Placed at the end of the document so the pages load faster --&gt;&lt;script src="/static/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;script src="/static/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;&#123;% block page_js %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 在base.html 中,通过定义block,把每个页面不同的部分区分出来: 12345678910111213141516&#123;#专门替换css文件的块,别的页面没有用到#&#125;&#123;% block page_css %&#125;&#123;% endblock %&#125;&#123;# 需要替换的部分,每个页面内容不同 #&#125;&lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt;&#123;# 这里是每个页面内容不同 #&#125;&#123;% block page-main %&#125;&#123;#专门替换js文件的块,别的页面没有用到#&#125;&#123;% endblock %&#125;&#123;% block page_js %&#125;&#123;% endblock %&#125; 在具体的页面中,先继承母版 1&#123;% extends 'base.html' %&#125; 然后通过block名字去指定替换母版中相应的位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123;% extends 'base.html' %&#125;&#123;% block page-main %&#125; &lt;h1 class="page-header"&gt;出版社管理页面&lt;/h1&gt; &lt;div class="panel panel-primary"&gt; &lt;!-- Default panel contents --&gt; &lt;div class="panel-heading"&gt;出版社列表 &lt;i class="fa fa-thumb-tack pull-right"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="row" style="margin-bottom: 15px"&gt; &lt;div class="col-md-4"&gt; &lt;div class="input-group"&gt; &lt;input type="text" class="form-control" placeholder="Search for..."&gt; &lt;span class="input-group-btn"&gt; &lt;button class="btn btn-default" type="button"&gt;搜索&lt;/button&gt; &lt;/span&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-md-4 --&gt; &lt;div class="col-md-1 pull-right"&gt; &lt;button class="btn btn-success" data-toggle="modal" data-target="#myModal"&gt;新增&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.row --&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;出版社名称&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for publisher in publisher_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-danger" href="/del_publisher/?id=&#123;&#123; publisher.id &#125;&#125;"&gt;删除&lt;/a&gt; &lt;a class="btn btn-danger" href="/del_publisher/&#123;&#123; publisher.id &#125;&#125;/"&gt;删除2&lt;/a&gt; &lt;a class="btn btn-info" href="/edit_publisher/?id=&#123;&#123; publisher.id &#125;&#125;"&gt;编辑&lt;/a&gt; &lt;a class="btn btn-info" href="&#123;% url 'edit_publisher' publisher_id %&#125;"&gt;编辑&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;nav aria-label="Page navigation" class="text-right"&gt; &lt;ul class="pagination"&gt; &lt;li&gt; &lt;a href="#" aria-label="Previous"&gt; &lt;span aria-hidden="true"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#" aria-label="Next"&gt; &lt;span aria-hidden="true"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 导航栏选中的判断方法123456789&lt;!--方法1:判断传进来的变量是否有值--&gt; &lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;ul class="nav nav-sidebar"&gt; &#123;#只要传来的值有all_book或者author_list、publisher_list 我就给这个li加成选中状态#&#125; &lt;li &#123;% if publisher_list %&#125; class = "active" &#123;% endif %&#125;&gt;&lt;a href="/publisher_list/"&gt;出版社列表页&lt;/a&gt;&lt;/li&gt; &lt;li &#123;% if all_book %&#125; class = "active" &#123;% endif %&#125;&gt;&lt;a href="/book_list/"&gt;书籍列表&lt;/a&gt;&lt;/li&gt; &lt;li &#123;% if author_list %&#125; class = "active" &#123;% endif %&#125;&gt;&lt;a href="/author_list/"&gt;作者列表&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 1234567891011121314&lt;!--方法2:使用block--&gt; &lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;ul class="nav nav-sidebar"&gt; &#123;#只要传来的值有all_book或者author_list、publisher_list 我就给这个li加成选中状态#&#125; &lt;li class= "&#123;% block publisher_class %&#125;&#123;% endblock %&#125;"&gt; &lt;a href="/publisher_list/"&gt;出版社列表页&lt;/a&gt;&lt;/li&gt; &lt;li class= "&#123;% block book_class %&#125;&#123;% endblock %&#125;"&gt; &lt;a href="/book_list/"&gt;书籍列表&lt;/a&gt;&lt;/li&gt; &lt;li class= "&#123;% block author_class %&#125;&#123;% endblock %&#125;"&gt; &lt;a href="/author_list/"&gt;作者列表&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--在相应的页面 添加块--&gt;&#123;% block book_class %&#125; active&#123;% endblock %&#125; 专门替换CSS样式的块123456789101112131415161718# 定义一个book_list_only.css文件body&#123; background-color: lawngreen; &#125;# 只有在指定的页面 用到这个样式&#123;#专门替换css文件的块,别的页面没有用到#&#125;&lt;head&gt;...&#123;% block page_css %&#125;&#123;% endblock %&#125;&lt;/head&gt;# book_list2.html替换&#123;% block page_css %&#125; &lt;link rel="stylesheet" href="/static/book_list_only.css"&gt;&#123;% endblock %&#125; 专门替换JS文件的块123456789101112131415161718# 定义一个author_list_only.js 文件alert('这是作者页面')# 只有在指定的页面 用到这个JS&lt;/body&gt;...&lt;script src="/static/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;script src="/static/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;&#123;% block page_js %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt;# 引用&#123;% block page_js %&#125; &lt;script src="/static/author_list_only.js"&gt;&lt;/script&gt;&#123;% endblock %&#125; 使用母版和继承的注意事项12341. &#123;% extends &apos;base.html&apos; %&#125; --&gt; 母版文件:base.html要加引号,2. &#123;% extends &apos;base.html&apos; %&#125; --&gt; 必须放在子页面的第一行3. 可以在base.html中定义很多block,通常我们会额外定义page_cs和page_js,这两个块4. views.py相应的函数中，返回的是对应的子页面文件不是不是不是base.html 组件可以将常用的页面内容如导航条，页尾信息等组件保存在单独的文件中，然后在需要使用的地方按如下语法导入即可。什么时候用组件:重复的代码,包装成一个独立的小html文件。 单独提取导航条 成为小组件,把导航条单独写成一个nav.html把base.html中的nav剪切分割到nav.html,里面的内容只放导航条的内容 12345678910111213141516171819202122232425&lt;nav class="navbar navbar-inverse navbar-fixed-top"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="https://v3.bootcss.com/examples/dashboard/#"&gt;BMS&lt;/a&gt; &lt;/div&gt; &lt;div id="navbar" class="navbar-collapse collapse"&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="https://v3.bootcss.com/examples/dashboard/#"&gt;Dashboard&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://v3.bootcss.com/examples/dashboard/#"&gt;Settings&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://v3.bootcss.com/examples/dashboard/#"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://v3.bootcss.com/examples/dashboard/#"&gt;Help&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-right"&gt; &lt;input type="text" class="form-control" placeholder="Search..."&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 如何使用在base.html中导入 12&lt;body&gt;&#123;% include "nav.html" %&#125; 在add_book.html中添加导航条 12345&#123;#加导航条#&#125;&#123;% include "nav.html" %&#125;&lt;div class="container" style="margin-top: 100px"&gt;.. 静态文件路径的灵活写法 利用static方法帮我拼接静文件的路径多用于base.html 母版中的css和js文件引入 123&#123;% load static %&#125;&lt;link href = "&#123;% static 'bootstrap/css/bootstrap.min.css' %&#125;" rel="stylesheet"&lt;script src="&#123;% static 'bootstrap/js/bootstrap.min.js' %&#125;"&gt;&lt;/script&gt; 利用内置的get_static_prefix获取静态文件路径的别名，我们自行拼接路径 12&#123;% load static %&#125;&lt;link href="&#123;% get_static_prefix %&#125;bootstrap/css/bootstrap.min.css" rel=stylesheet&gt; as 语法(一个路径多次用到，可以使用as保存到一个变量,后面直接使用变量代替具体路径 自定义的simple_tag比filter高级一点点，它可以接收的参数大于2 1234567from django import templateregister = template.Library()@register.simple_tag(name="my_sum")def my_sum(arg,arg2,arg3): return "&#123;&#125; &#123;&#125; &#123;&#125;" .format(arg,arg2,arg3) 自定义的inclusion_tag用来返回一段html代码(示例:返回ul标签) 定义阶段:在app下新建:templatetags 目录(注意是Python包)新建python文件 my_inclusion.py 12345678from django import template# 生成一个注册的实例,必须写成是registerregister = template.Library()@register.inclusion_tag("ul.html")def show_ul(num): num = 1 if num &lt; 1 else int(num) data = ["第&#123;:0&gt;3&#125;" .format(i) for i in range(1,num+1)] return &#123;"data":data&#125; 编辑要用到的ul.html 12345&lt;ul&gt; &#123;% for ret in data %&#125; &lt;li&gt; &#123;&#123; ret &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 调用阶段: 123&lt;!--# 要记得重启--&gt;&#123;% load my_inclusion %&#125;&#123;% show_ul 5 %&#125; Django 视图系统什么是视图系统 一个视图函数（类），简称视图，是一个简单的Python 函数（类），它接受Web请求并且返回Web响应。 视图view(接收请求，返回响应这一部分就叫视图,也可以叫处理函数) CBV 和 FBV CBV( class base view 基于类的视图 )和FBV( function base view 基于函数的视图 ) 例如将出版社的添加方法,修改为CBV 基于类的视图:views.py添加: 123456789101112# CBV 出版社添加from django.views import Viewclass AddPublisher(View): def get(self,request): # 用户第一次来，我给他返回一个用来填写的HTML页面 return render(request, 'add_publisher.html') def post(self,request): if request.method == "POST": publisher_name = request.POST.get("name") models.Publisher.objects.create(name=publisher_name) return redirect('/publisher_list/') 123456789# FBV 出版社添加# 出版社添加def add_publisher(request): if request.method == "POST": publisher_name = request.POST.get("name") models.Publisher.objects.create(name=publisher_name) return redirect('/publisher_list/') return render(request, 'add_publisher.html') 使用CBV时，urls.py中也做对应的修改： 123# urls.py中# url(r'^add_publisher/', views.add_publisher),url(r'^add_publisher/', views.AddPublisher.as_view()), Request 对象 和 Response 对象Request 对象当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。 请求相关的常用值:12345path_info 返回用户访问url，不包括域名method 请求中使用的HTTP方法的字符串表示，全大写表示。GET 包含所有HTTP GET参数的类字典对象POST 包含所有HTTP POST参数的类字典对象body 请求体，byte类型 request.POST的数据就是从body里面提取到的 常用属性: 12345678910111213request.method # 获取请求的方法(GET,POST等)request.GET # 获取URL里面的参数 127.0.0.1:8000/edit_book/?id=1&amp;name=python request.GET --&gt; &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;python&quot;&#125; request.GET.get(&quot;id&quot;)request.POST # 用来获取POST提交过来的数据 request.POST.get(&quot;book_title&quot;)request.path_info # 获取用户请求的路径(不包含IP端口和URL参数)request.body # post提交中会有数据 注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用： 1request.POST.getlist("hobby") 上传文件示例 urls.py 12# 上传文件url(r'^upload_files/', views.upload_files), views.py 12345678910111213141516171819202122232425# 处理上传文件的函数def upload_files(request): """ 1. 保存上传文件前，数据需要存放在某个位置。 默认当上传文件小于2.5M时，django会将上传文件的全部内容读进内存。 2. 从内存读取一次，写磁盘一次。 在f.chunks()上循环而不是用read()保证大文件不会大量使用你的系统内存。 3. 但当上传文件很大时，django会把上传文件写到临时文件中，然后存放到系统临时文件夹中。 :param request: :return: """ if request.method == "POST": # Request.FILES # 从请求的FILES中获取上传文件的文件名，file为页面上type=files类型input的name属性值 filename = request.FILES["file1"].name # 在项目目录下新建一个文件 with open(filename,"wb") as f: # 从上传的文件对象中一点一点读 for chunk in request.FILES["file1"].chunks(): # 写入本地文件 f.write(chunk) return HttpResponse('&#123;&#125; 上传完成' .format(filename)) return render(request,'upload_files.html') upload_files.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/upload_files/" method="post" enctype="multipart/form-data"&gt;&#123;# FILES 中的每个键为&lt;input type="file" name="" /&gt; 中的name，值则为对应的数据。#&#125;&#123;# 注意：FILES 只有在请求的方法为POST 且提交的&lt;form&gt; 带有enctype="multipart/form-data" 的情况下才会#&#125;&#123;# 包含数据。否则，FILES 将为一个空的类似于字典的对象。#&#125; &lt;p&gt;&lt;input type="file" name="file1"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="file" name="file2"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="提交"&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Response 对象与由Django自动创建的HttpRequest对象相比，HttpResponse对象是我们的职责范围了。我们写的每个视图都需要实例化，填充和返回一个HttpResponse。HttpResponse类位于django.http模块中。 基础必备三件套 123HttpResponse --&gt; 返回字符串内容render --&gt; 返回一个页面redirect --&gt; 返回一个重定向告诉浏览器去访问另外的网址 JsonResponse 对象JsonResponse是HttpResponse的子类，专门用来生成JSON编码的响应。 urls.py 12# JsonResponse对象url(r'^json_test/', views.json_test), views.py 123456789101112131415# json_testdef json_test(request): import json data = &#123;"name": "夜雨", "age": 18&#125; data2 = [1,2,3,4,5,"夜雨"] # 默认只能传递字典类型 # json_data = json.dumps(data,ensure_ascii=False) # 把data序列化成json格式的字符串 # return HttpResponse(json_data) # django帮我们封装的 专门用来返回JSON格式字符串响应方法 # return JsonResponse(data,json_dumps_params=&#123;'ensure_ascii':False&#125;) # django通常只能接收字典格式的,单独返回列表类型数据,需要加上safe=False return JsonResponse(data2,safe=False,json_dumps_params=&#123;'ensure_ascii':False&#125;) Django 路由系统URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL与要为该URL调用的视图函数之间的映射表。你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。 URLconf配置 基本格式: 12345from django.conf.urls import urlurlpatterns = [ url(正则表达式, views视图函数，参数，别名),] 参数说明: 1234正则表达式：一个正则表达式字符串views视图函数：一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串参数：可选的要传递给视图函数的默认参数（字典形式）别名：一个可选的name参数 正则表达式详解 基本配置 123456789101112131415161718192021222324# urls.py:# JsonResponse对象url(r'^json_test/$', views.json_test),# http://127.0.0.1:8000/json_test/1/2/3 无法访问# http://127.0.0.1:8000/json_test/?id=1 可以访问,因为?id是参数# 路由系统# book/2-4位数字# http://127.0.0.1:8000/book/12/# url(r'^book/[0-9]&#123;2,4&#125;/$', views.book),# 分组匹配()url(r'^book/([0-9]&#123;2,4&#125;)/([a-zA-Z]&#123;2&#125;)/$', views.book),# http://127.0.0.1:8000/book/12/ab/# book() takes 1 positional argument but 3 were given# 如果我们使用分组匹配,会将()分组匹配里面的值,当做参数发送给视图函数,函数中除了request,还需要接收()里面的参数# 这种方式可以代替?id=1，地址栏传值# views.py:# 分组匹配,位置参数def book(request,arg1,arg2): print('arg1:',arg1) # arg1: 12 print('arg2:',arg2) # arg2: ab return HttpResponse("分组匹配") 注意事项: 1234urlpatterns中的元素按照书写顺序从上往下逐一匹配正则表达式，一旦匹配成功则不再继续。若要从URL中捕获一个值，只需要在它周围放置一对圆括号（分组匹配）。不需要添加一个前导的反斜杠，因为每个URL 都有。例如，应该是^articles 而不是 ^/articles。每个正则表达式前面的&apos;r&apos; 是可选的但是建议加上。 分组匹配分组匹配:给视图函数传递位置参数分组匹配和分组命名匹配不能混用,看需求使用哪一种1234567# urls.py# 分组匹配()url(r'^book/([0-9]&#123;2,4&#125;)/([a-zA-Z]&#123;2&#125;)/$', views.book),# http://127.0.0.1:8000/book/12/ab/# book() takes 1 positional argument but 3 were given# 如果我们使用分组匹配,会将()分组匹配里面的值,当做参数发送给视图函数,函数中除了request,还需要接收()里面的参数# 这种方式可以代替?id=1，地址栏传值 12345678910111213# views.py# 分组匹配,位置参数def book(request,arg1,arg2): print('arg1:',arg1) # arg1: 1000 print('arg2:',arg2) # arg2: py return HttpResponse("分组匹配")# 分组匹配,args接收参数def book(request,*args): print(args) # args接收返回元祖('1000', 'py') print(args[0]) print(args[1]) return HttpResponse("分组匹配") 分组命名匹配分组命名:给视图函数传关键字参数 123456# urls.py# 分组命名匹配url(r'^book/(?P&lt;year&gt;[0-9]&#123;2,4&#125;)/(?P&lt;title&gt;[a-zA-Z]&#123;2&#125;)/$', views.book),# 会将year和title当做关键字参数# 分组匹配相当于 位置传参# 分组命名相当于 关键字传参 1234567891011121314views.py# 分组命名匹配,关键字参数def book(request,year,title): print('year:',year) print('title:',title) return HttpResponse("分组命名匹配")# 分组命名匹配,**kwargs接收参数def book(request,**kwargs): print(kwargs) # &#123;'year': '1000', 'title': 'py'&#125; print(kwargs['year']) # 1000 print(type(kwargs['year'])) # &lt;class 'str'&gt; 捕获的参数永远是字符串类型 print(kwargs['title']) # py return HttpResponse("分组命名匹配") 设置默认值 如果用户访问blog/ 那么我们默认返回num1,也就是blog的第一页 如果用户到这page100访问,那么我们直接返回对应的页面 返回的是blog/page具体第几页的blog，num=捕获的值,而不是num=1 12345678910111213# urls.py中from django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r'^blog/$', views.page), url(r'^blog/page(?P&lt;num&gt;[0-9]+)/$', views.page),]# views.py中，可以为num指定默认值def page(request, num="1"): pass 分组匹配的使用出版社删除 改为分组匹配1234# urls.pyurl(r'^del_publisher/$', views.del_publisher),#url分组匹配,括号里的值会传给函数url(r'^del_publisher2/([0-9]+)/$', views.del_publisher2), 12345678# views.py# url分组匹配传参形式-删除出版社def del_publisher2(request,del_id): # url(r'^del_publisher/([0-9]+)', views.del_publisher2), # 至少接收一个数字作为del_id # 不用再从request.GET取值 models.Publisher.objects.get(id=del_id).delete() return redirect("/publisher_list/") 1&lt;a href="/del_publisher2/&#123;&#123; publisher.id &#125;&#125;/"&gt;分组匹配删除&lt;/a&gt; 出版社修改 改为分组匹配1234# urls.pyurl(r'^edit_publisher/$', views.edit_publisher),# url分组匹配,括号里的值会传给函数url(r'^edit_publisher2/([0-9]+)/$', views.edit_publisher2), 12345678910111213# views.py# url分组匹配传参形式-编辑出版社def edit_publisher2(request,edit_id): if request.method == "POST": edit_id = request.POST.get("id") edit_name = request.POST.get("name") edit_obj = models.Publisher.objects.get(id=edit_id) edit_obj.name = edit_name edit_obj.save() return redirect("/publisher_list/") # 不用再从request.GET取值edit_id edit_obj = models.Publisher.objects.get(id=edit_id) return render(request, "edit_publisher.html", &#123;"edit_obj": edit_obj&#125;) 1&lt;a href="/edit_publisher2/&#123;&#123; publisher.id &#125;&#125;/"&gt;分组匹配编辑&lt;/a&gt; include 其他的URLconfs 我们现在所有的路由指向都是写在一个配置文件 project/urls.py 当我们的app有很多的时候,就需要分组管理 include 分流urls 执行命令 1D:\MyProject\test_0922&gt;python manage.py startapp app02 在settings中添加配置,告诉Django我们添加了新的app 12345678910INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01.apps.App01Config', 'app02.apps.App02Config',] 在app01中新建ursl.py 编辑2级路由app01/urls.py 12345678910from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ # 分组匹配() url(r'^book/([0-9]&#123;2,4&#125;)/([a-zA-Z]&#123;2&#125;)/$', views.book), # index url(r'^$', views.publisher_list),] 编辑1级路由project/urls.py 1234567891011121314from django.conf.urls import url,includefrom django.contrib import adminfrom app01 import views,urlsurlpatterns = [ url(r'^admin/', admin.site.urls), # http://127.0.0.1:8000/app01/publisher_list/ # 要记得导入include # 不要忘记修改对应的路径如:base下的 # &lt;a href="/app01/publisher_list/"&gt; # 所有以app01开头的url都交给app01/urls.py处理 url(r'^app01/',include(urls)),] include app02.urls1234567# app02.urlsfrom django.conf.urls import urlfrom app02 import viewsurlpatterns = [ url(r'^home/$', views.home),] 123# app02.viewsdef home(request): return HttpResponse('app02/home') 12345678910111213141516# project.urls# 要注意urls会重名,导入app02的urls后as别名from django.conf.urls import url,includefrom django.contrib import adminfrom app01 import views,urls as app01_urlsfrom app02 import urls as app02_urlsurlpatterns = [ url(r'^admin/', admin.site.urls), # http://127.0.0.1:8000/app01/publisher_list/ url(r'^app01/',include(urls)), # http://127.0.0.1:8000/app02/home/ url(r'^app02/',include(app02_urls)),] 命名URL和URL反向解析 Templates里面创建多级目录 templates car home.html house home.html 编写urls.py 对应各自的路由: 123# project/urls.pyurl(r'^car/',include(app01_urls)),url(r'^house/',include(app02_urls)) 1234# app01/urls.pyurlpatterns = [ url(r'^home/$', views.home),] 1234# app02/urls.pyurlpatterns = [ url(r'^home/$', views.home),] 编写views.py 12def home(request): return render(request,'car/home.html') 12def home(request): return render(request,'house/home.html') 编写html 123&lt;h1&gt;app01/home 这是卖车的首页&lt;/h1&gt;&lt;p&gt;友情链接&lt;/p&gt;&lt;a href="/house/home"&gt;想买房子点我&lt;/a&gt; 123&lt;h1&gt;app02/home 这是卖房子的首页&lt;/h1&gt;&lt;p&gt;友情链接&lt;/p&gt;&lt;a href="/car/home"&gt;想买车点我&lt;/a&gt; 现在我们有了两个app并且都各自用有自己的路由和视图函数,返回各自的首页,并且在页面中都由a标签跳转 这个时候如果我们的urls的路径被修改了,相应的跳转也就无法访问,这是由于url被固定了 1url(r'^carcar/',include(app01_urls)), 使用url反向解析来获取页面 一级路由解析 路由侧添加了别名:name=’别名’,html就可以动态调用url=’别名’此功能可以防止url被修改,导致页面无法找到url路径 12345# project.urls# JsonResponse对象# url(r'^json_test/$', views.json_test,name='json_test'),# 如果我们修改页面,跳转将失败，这是由于url被固定了 url(r'^json_data111/$', views.json_test,name='json_test'), 1234567# house/home.html&lt;p&gt;返回JsonResponse页面# &lt;a href="/json_data/"&gt;Json_test的反向解析&lt;/a&gt;# /json_data/不能被固定写死,通过别名去动态查询url# url会去整个项目的urls去找别名是json_test的url &lt;a href="&#123;% url 'json_test' %&#125;"&gt;Json_test的反向解析&lt;/a&gt;&lt;/p&gt; 二级路由,通过别名反向解析找到url 123# project/urls.py# url(r'^car/',include(app01_urls)),url(r'^car999/',include(app01_urls)), 1234# app01/urls.pyurlpatterns = [ url(r'^home/$', views.home,name='car_home'),] 1&lt;a href="&#123;% url 'car_home' %&#125;"&gt;想买车点我&lt;/a&gt; 使用url反向解析,在视图views中跳转 一般views中的跳转使用redirect 12# project/urlsurl(r'^json_data3/$', views.json_test,name='json_test'), 12def home(request): return redirect('/json_data3/') 根据别名找到跳转的url1234567def home(request): from django.urls import reverse # reverse 反向解析,根据别名找到跳转的url # 会去urls里面找到对应的别名 redirect_url = reverse("json_test") return redirect(redirect_url) 反向解析URL 本质上就是给url匹配模式起别名,然后通过别名拿到具体的url地址 如何使用 在url匹配模式中,定义name=’别名’ 在模板语言里使用 url ‘别名’ 在视图函数里使用 12from django.urls import reverseredirect_url = reverse("json_test") # 得到 URL 使用url反向解析,加上参数跳转 当url里面含有参数的时候,别名如何解析呢? 123app01/urls# 分组匹配()url(r'^book/([0-9]&#123;2,4&#125;)/([a-zA-Z]&#123;2&#125;)/$', views.book,name='book'), 123456789101112# 在反转的时候带参数def home(request): from django.urls import reverse # reverse 反向解析,根据别名找到跳转的url # 会去urls里面找到对应的别名 # redirect_url = reverse("book",kwargs=&#123;"year":2018,"title":"py"&#125;) redirect_url = reverse("book",args=[2018,"py"]) print(redirect_url) # /car999/book/2018/py/ # return redirect(redirect_url) return render(request,'car/home.html') 2.在模板语言中,测试带参数的url反向解析 12345&lt;p&gt;测试带参数的url反向解析: &lt;a href="&#123;% url 'book' 2018 "py" %&#125;"&gt;book点我&lt;/a&gt;&lt;/p&gt;# http://127.0.0.1:8000/car999/book/2018/py/ 把编辑按钮的连接改成反向解析URL形式 适用于分组匹配12# url分组匹配,括号里的值会传给函数url(r'^edit_publisher2/([0-9]+)/$', views.edit_publisher2,name="edit_pub"), 1&lt;a href="&#123;% url 'edit_pub' publisher.id %&#125;"&gt;分组匹配编辑&lt;/a&gt; 命名空间模式 当app多了,urls中的别名也可能会出现重复 123# project/urls.pyurl(r'^car999/',include(app01_urls,namespace="car")),url(r'^house/',include(app02_urls,namespace="house")), 1234# app02/urls.pyurlpatterns = [ url(r'^home/$', views.home,name='home'),] 12&lt;a href="&#123;% url 'car:car_home' %&#125;"&gt;想买车点我&lt;/a&gt;&lt;a href="&#123;% url 'house:home' %&#125;"&gt;想买房子点我&lt;/a&gt; 通过URL分组和反射 将方法三合一123456789101112131415161718192021222324252627# modelsfrom django.db import models# Create your models here.class Publisher(models.Model): id = models.AutoField(primary_key=True) name = models.CharField(max_length=64,null=False,unique=True) def __str__(self): return '&lt;&#123;&#125;出版社是:&gt;' .format(self.name)class Book(models.Model): id = models.AutoField(primary_key=True) title = models.CharField(max_length=64,null=False) publisher = models.ForeignKey(to='Publisher') def __str__(self): return '&lt;&#123;&#125;书名是:&gt;' .format(self.title)class Author(models.Model): id = models.AutoField(primary_key=True) name = models.CharField(max_length=64,null=False) book = models.ManyToManyField(to='Book') def __str__(self): return '&lt;&#123;&#125;作家姓名:&gt;' .format(self.name) 1234# urls.py# url(r'^delete/表名/id值',views.delete),# http://127.0.0.1:8000/delete/book/10/url(r'^delete/([a-zA-Z]+)/(\d+)/$',views.delete), 12345678import rer = re.compile(r'^delete/([a-zA-Z]+)/(\d+)/$')ret = r.match("delete/author/10/")print(ret.groups()) # ('author', '10')print(ret.group(1)) # authorprint(ret.group(2)) # 10 123456789101112131415161718192021222324# 正则表达式的匹配参数:# table_name = ([a-zA-Z]+)# del_id = (\d+)def delete(request,table_name,del_id): print(table_name,del_id) # 额外需要判断下表名和ID值,是否都是正经的数据,表名有并且ID值存在 # 反射,通过字符串去找一个函数,变量或者是类 # 从另外一个文件 根据字符串 反射具体的变量 # models 里面有没有table_name table_name = table_name.capitalize() # 首字母大写 if hasattr(models,table_name): # 如果能找到 table_class = getattr(models,table_name) try: table_class.objects.get(id=del_id).delete() except Exception as e: print(str(e)) print('id值不存在!') return HttpResponse("表名是&#123;&#125;,ID是&#123;&#125;" .format(table_name,del_id)) else: return HttpResponse("表不存在!")]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 基础]]></title>
    <url>%2F2019%2F09%2F03%2Fdjango-base%2F</url>
    <content type="text"><![CDATA[Django 基础使用Django 官网下载页面https://www.djangoproject.com/download/ 安装方法 命令行安装 121. pip3 install django==1.1.232. pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple/ django==1.1.23 # -i 指定哪个库 Pycharm安装 1安装不要勾选将包安装到指定的地址目录,否则需要将该地址加到环境变量才能使用django-admin命令 创建 Django 项目 命令行: 121. cd 要保存Django的目录2. python django-admin startproject 项目名 Pycharm 创建 1231. File --&gt; new project --&gt; Django2. 可以配置app名称3. 不要勾选虚拟环境 配置 Django 项目Django的配置文件为 project/settings.py文件,作为初学者要先记住4个需要配置的地方: templates (存放HTML文件的配置) 12345678TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 告诉Django 我用到的html文件都去这个目录找 'DIRS': [os.path.join(BASE_DIR, 'templates'),] # ... 列表中多个目录会依次查找 &#125;] 静态文件: 123456789# 静态文件夹的别名(在HTML文件中使用)# 静态文件保存的文件别名,会依次的查找下面的static1和static2,一直到找不到STATIC_URL = '/static/'# 静态文件夹的真正路径# 所有静态文件(css/js/图片) 都放在下面配置文件目录中STATICFILES_DIRS = [ os.path.join(BASE_DIR,'static')] 注释掉 csrf 相关的中间件 12# CSRF verification failed. Request aborted. 问题需要注释:大概是:46行# 'django.middleware.csrf.CsrfViewMiddleware' Django项目连接数据库 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 连接的数据库类型 'NAME': 'mybook', 'HOST': '10.0.0.200', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', &#125;&#125; Django Web 请求流程 启动Django项目，等待用户连接 浏览器在地址栏输入URL,来连接我的Django项目 在urls.py中找到路径和函数的对应关系 执行对应的函数 返回响应 urls.py 的配置 project/urls.py 负责保存路径和函数的对应关系 12from .views import index,sport,login,baobao --&gt; 项目中的views 默认从项目使用相对路径找到from app01 import views --&gt; app中的views,从项目使用绝对路径导 12345from app01 import views urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^publisher_list/', views.publisher_list),] views.py 的配置 app/views.py 专门用来定义处理请求的函数 123456# 必备三件套 # shortcuts(快捷键)from django.shortcuts import HttpResponse,render,redirect1. HttpResponse(&quot;要返回的字符串内容&quot;) --&gt; 通常用于直接返回数据2. render(request,&quot;html文件&quot;,&#123;&quot;k1&quot;:v1&#125;) --&gt; 返回一个HTML页面或者打开文件进行字符串替换3. redirect(&quot;URL&quot;) --&gt; 告诉用户的浏览器去访问指定的UR 123# request相关:request.method --&gt; 查看请求的方法request.POST --&gt; 获取POST请求的数 123def publisher_list(request): # 使用ORM获取所有出版社信息 return render(request,"publisher_list.html") ORM 的使用 什么是ORM 121. 是一种编程的方法论(模型)，和语言无关，其他的语言也有类似的实现2. 按照规定的语法写，自动翻译成对应的SQL语 ORM的本质 123类 --&gt; 数据表对象 --&gt; 数据行属性 --&gt; 字 ORM的功能 12ORM 操作数据表ORM 操作数据行 Django里的ORM使用 121. 手动创建数据库CREATE DATABASE mybook CHARACTER SET utf8; 123456789102. 在settings.py 里面配置数据库的链接信息DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;mybook&apos;, &apos;HOST&apos;: &apos;10.0.0.200&apos;, &apos;PORT&apos;: 3306, &apos;USER&apos;: &apos;root&apos;, &apos;PASSWORD&apos;: &apos;123456&apos;, &#125; 123# 3. 在project/__init__.py 文件中 告诉Django用pymysql模块代替MySQLDB来连接import pymysqlpymysql.install_as_MySQLdb() 1234# 4. 在app下的models.py 里面定义类class Publisher(models.Model): id = models.AutoField(primary_key=True) # 自增主键 name = models.CharField(max_length=64,null=False,unique=True) # 出版社名称,不能为空,唯一 1235. 执行两个命令:1. python3 manage.py makemigrations # 记录我们对文件的改动,放到migrations目录下2. python3 manage.py makemigrate # 把改动翻译成sql语句，再去数据库执行 1234567891011121314151617181920212223246. 创建成功的输出结果D:\MyProject\day03&gt;python manage.py makemigrationsMigrations for &apos;app01&apos;: app01\migrations\0001_initial.py - Create model PublisherD:\MyProject\day03&gt;python manage.py migrateOperations to perform: Apply all migrations: admin, app01, auth, contenttypes, sessionsRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying app01.0001_initial... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying sessions.0001_initial... OK 1234567891011121314151617181920212223247. 删除表1. 注释掉在models.py下的类# class Userinfo(models.Model):# id = models.AutoField(primary_key=True) # 创建一个自增的主键字段# name = models.CharField(null=False,max_length=20) # 创建varchar类型并且不能为空的字段2. 执行命令: 1. python3 manage.py makemigrations # 记录我们对文件的改动,放到migrations目录下 2. python3 manage.py makemigrate # 把改动翻译成sql语句，再去数据库执行 D:\MyProject\app&gt;python manage.py makemigrations Migrations for &apos;app01&apos;: app01\migrations\0002_delete_userinfo.py - Delete model Userinfo D:\MyProject\app&gt;python manage.py migrate Operations to perform: Apply all migrations: admin, app01, auth, contenttypes, sessions Running migrations: Applying app01.0002_delete_userinfo... OK3. migrations目录下的文件 会记录的改 123456789101112131415161718198. 修改表# 修改了name字段的长度 从20修改到32class Userinfo(models.Model): id = models.AutoField(primary_key=True) # 创建一个自增的主键字段 name = models.CharField(null=False,max_length=32) # 创建varchar类型并且不能为空的字段1. python3 manage.py makemigrations # 记录我们对文件的改动,放到migrations目录下2. python3 manage.py makemigrate # 把改动翻译成sql语句，再去数据库执行 D:\MyProject\app&gt;python manage.py makemigrationsMigrations for &apos;app01&apos;: app01\migrations\0004_auto_20190903_1054.py - Alter field name on userinfoD:\MyProject\app&gt;python manage.py migrateOperations to perform: Apply all migrations: admin, app01, auth, contenttypes, sessionsRunning migrations: Applying app01.0004_auto_20190903_1054... O 刷新数据到展示页面 完善views中的publisher_list函数,将数据库表中刚建好的数据展示出来 12345def publisher_list(request): # 使用ORM去数据库查出所有的出版社，填充到HTML页面中，给用户返回 ret = models.Publisher.objects.all().order_by("id") # 排序 return render(request,"publisher_list.html",&#123;"publisher_list":ret&#125;) # http://127.0.0.1:8000/publisher_list/ 在publisher_list.html中使用模板语言刷新出数据 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;出版社首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;出版社名称&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for publisher in publisher_list %&#125; &lt;tr&gt; &#123;#自动序号计数#&#125; &lt;td&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.name &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 启动Django项 命令行启动: D:\MyProject\项目路径&gt;python manage.py runserver 8099 Pycharm启动 点绿色的小三角，直接启动Django项目,选择项目名编辑可以修改端口 出版社信息 添加、删除、修改操作添加出版社 首先在urls.py文件中增加函数与访问路径的对应关系 12345urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^publisher_list/', views.publisher_list), url(r'^add_publisher/', views.add_publisher),] 在templates路径下添加add_publisher.html页面 12345678910111213141516&lt;!--post提交指向当前页面--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;添加出版社&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;添加出版社&lt;/h1&gt;&lt;form action="/add_publisher/" method="POST"&gt; &lt;input type="text" name="publisher_name"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;p style="color: red"&gt;&#123;&#123; error_msg &#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123&lt;!-- 在原有的展示页面上添加一个a标签作为入口指向add_publisher.html--&gt;&lt;a href="/add_publisher/"&gt;添加出版社&lt;/a&gt;&lt;hr&gt; 在views.py文件写 编写add_publisher函数方法 1234567891011121314151617181920# 添加出版社def add_publisher(request): error_msg = "" # 如果是POST请求 就取到用户提交的数据 if request.method == "POST": # 拿到用户提交的数据 new_name = request.POST.get("publisher_name",None) print(new_name ) if new_name: # 通过ORM 将数据入库 models.Publisher.objects.create(name=new_name) # 添加完成后 跳转回展示页面 查看结果 return redirect("/publisher_list/") else: # 如果添加的字符为空,那么久直接返回添加页面,并给提示 error_msg = "您填写的数据为空" return render(request, "add_publisher.html",&#123;"error_msg":error_msg&#125;) # GET请求放回添加页面 return render(request,"add_publisher.html") 删除出版社 在urls.py文件中添加对应关系 123456urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^publisher_list/', views.publisher_list), url(r'^add_publisher/', views.add_publisher), url(r'^del_publisher/', views.del_publisher),] 定义删除按钮 123456789101112&lt;tbody&gt; &#123;% for publisher in publisher_list %&#125; &lt;tr&gt; &#123;#自动序号计数#&#125; &lt;td&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href="/del_publisher/?id=&#123;&#123; publisher.id &#125;&#125;"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125;&lt;/tbody&gt; 编写del_publisher函数方法 1234567891011121314# 删除出版社def del_publisher(request): # 当在页面上点击删除的时候,首先应该通过ID获取用户想删除那条数据 # 页面上会通过/del_publisher/?id=&#123;&#123; publisher.id &#125;&#125; 在get的时候传过来id # 从GET请求的参数里面拿到将要删除的数据的ID值 del_id = request.GET.get("id",None) if del_id: # 通过ORM删除指定数据 del_obj = models.Publisher.objects.get(id=del_id).delete() # 删除后返回出版社页面，查看是否成功 return redirect("/publisher_list/") else: HttpResponse("您要删除的数据不存在") 编辑出版社 在urls.py文件中添加对应关系 1234567urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^publisher_list/', views.publisher_list), url(r'^add_publisher/', views.add_publisher), url(r'^del_publisher/', views.del_publisher), url(r'^edit_publisher/', views.edit_publisher),] 定义编辑按钮 123456789101112131415&lt;tbody&gt; &#123;% for publisher in publisher_list %&#125; &lt;tr&gt; &#123;#自动序号计数#&#125; &lt;td&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="/del_publisher/?id=&#123;&#123; publisher.id &#125;&#125;"&gt;删除&lt;/a&gt; &lt;a href="/edit_publisher/?id=&#123;&#123; publisher.id &#125;&#125;"&gt;编辑&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125;&lt;/tbody&gt; 创建edit_publisher.html页面 123456789101112131415161718&lt;!--1. id 将要编辑的数据id放在页面中，但是不显示--&gt;&lt;!--2. 将查询出来的要编辑的数据对象的名字刷新到编辑页面中--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;编辑出版社&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;编辑出版社&lt;/h1&gt;&lt;form action="/edit_publisher/" method="POST"&gt; &lt;input type="text" name="id" value="&#123;&#123; publisher_obj.id &#125;&#125;" style="display: none"&gt; &lt;input type="text" name="publisher_name" value="&#123;&#123; publisher_obj.name &#125;&#125;"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;p style="color: red"&gt;&#123;&#123; error_msg &#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 编写edit_publisher函数方法1234567891011121314151617181920212223242526# 编辑出版社def edit_publisher(request): # 如果是POST提交,将用户从编辑页面修改的数据刷新到数据库中 if request.method == "POST": edit_id = request.POST.get("id",None) new_name = request.POST.get("publisher_name",None) # 更新出版社 # 根据ID取到编辑的是哪个出版社 edit_publisher_obj = models.Publisher.objects.get(id=edit_id) edit_publisher_obj.name = new_name # 把修改后的数据提交到数据 edit_publisher_obj.save() # 去出版社列表页面展示，查看是否更新成功 return redirect("/publisher_list/") # 返回编辑的是哪个出版社对象 # 从GET请求中取到要编辑的ID # 当用户从展示页点击编辑按钮,需要获取用户点击的数据ID,然后得到数据对象传给编辑页面 edit_id = request.GET.get("id",None) if edit_id: publisher_obj = models.Publisher.objects.get(id=edit_id) return render(request,"edit_publisher.html",&#123;"publisher_obj":publisher_obj&#125;) else: return HttpResponse("您要编辑的数据不存在") 图书信息 添加、删除、修改一对多关系表的建立 ORM添加外键关联 models.ForeignKey12345class Book(models.Model): id = models.AutoField(primary_key=True) # 自增主键 title = models.CharField(max_length=64, null=False, unique=True) # 书籍名称,不能为空,唯一 # ForeignKey会自动加_id , 在数据库就叫做publisher_id_id, 所以只要写publisher就可以 publisher = models.ForeignKey(to=Publisher) # ForeignKey外键 展示所有书籍 在urls.py文件中添加对应关系 12# 书籍所有相关url(r'^book_list/', views.book_list), 在book_list.html中使用模板语言刷新出数据 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;书籍列表&lt;/title&gt;&lt;/head&gt;&lt;h1&gt;书籍列表&lt;/h1&gt;&lt;a href="/add_book/"&gt;添加书籍&lt;/a&gt;&lt;body&gt;&lt;table border="1"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for book in book_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.title &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.publisher.name &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &#123;#book.publisher 得到的是出版社对象,继续.出属性#&#125; &#123;#book --&gt; 书对象#&#125; &#123;#book.publisher --&gt; book对应的出版社对象#&#125; &#123;#book.publisher_id --&gt; 数据库表中实际保存的外键值#&#125; &#123;#book.publisher.name --&gt; book对应的出版社对象的属性#&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; views.py文件中添加展示书籍函数 book_list 12345def book_list(request): # ORM去数据库中查询所有的数据 all_book = models.Book.objects.all().order_by("id") # 去HTMK页面渲染数据 return render(request,"book_list.html",&#123;"book_list":all_book&#125;) 添加书籍 在urls.py文件中添加对应关系 123# 书籍所有相关url(r'^book_list/', views.book_list),url(r'^add_book/', views.add_book), 别忘记添加入口 1&lt;a href="/add_book/"&gt;添加书籍&lt;/a&gt; 编写add_book函数 1234567891011121314151617181920# 添加书籍def add_book(request): if request.method == "POST": # &#123;"book_title":"css","publisher":1&#125; new_book_title = request.POST.get("book_title",None) new_publisher = request.POST.get("publusher",None) print(new_book_title) print(new_publisher) # 创建新书,添加新数据 models.Book.objects.create( title=new_book_title, publisher_id = new_publisher ) # 返回书籍列表页面 return redirect("/book_list/") # 取到所有的出版社，给添加页面的select all_publisher = models.Publisher.objects.all() return render(request,"add_book.html",&#123;"all_publisher":all_publisher&#125;) 添加add_book.html页面 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;添加书籍&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;添加书籍&lt;/h1&gt;&lt;hr&gt;&lt;form action="/add_book/" method="post"&gt; &lt;input type="text" name="book_title"&gt; &#123;#&#123;"publisher":pid&#125;#&#125; &lt;select name="publusher" id=""&gt; &#123;% for publisher in all_publisher %&#125; &lt;option value="&#123;&#123; publisher.id &#125;&#125;"&gt;&#123;&#123; publisher.name &#125;&#125;&lt;/option&gt; &#123;% endfor %&#125; &lt;/select&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 删除书籍 在urls.py文件中添加对应关系 1234# 书籍所有相关url(r'^book_list/', views.book_list),url(r'^add_book/', views.add_book),url(r'^del_book/', views.del_book), 定义删除按钮 123456789101112131415&lt;tbody&gt; &#123;% for book in book_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.title &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.publisher.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="/del_book/?id=&#123;&#123; book.id &#125;&#125;"&gt;删除&lt;/a&gt; &lt;a href="/edit_book/?id=&#123;&#123; book.id &#125;&#125;"&gt;编辑&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125;&lt;/tbody&gt; 编写del_book方法 1234567def del_book(request): # 获取要删除的书籍的ID del_id = request.GET.get("id") # 去数据库根据del_id查找要删除的书籍对象,然后直接删除 models.Book.objects.get(id=del_id).delete() # 返回书籍展示页面 return redirect("/book_list/") 编辑书籍 在urls.py文件中添加对应关系 12345# 书籍所有相关url(r'^book_list/', views.book_list),url(r'^add_book/', views.add_book),url(r'^del_book/', views.del_book),url(r'^edit_book/', views.edit_book) 编写edit_book方法 12345678910111213141516171819202122def edit_book(request): # 从POST提交的数据中取出id、书名和书关联的出版社 if request.method == "POST": edit_id = request.POST.get("id") edit_book_title = request.POST.get("book_title") edit_publusher_id = request.POST.get("publusher") # 根据edit_id得到要修改的书籍对象,然后更新数据并提交 edit_obj = models.Book.objects.get(id=edit_id) edit_obj.title = edit_book_title edit_obj.publisher_id = edit_publusher_id # 将修改提交到数据 edit_obj.save() # 返回书籍列表页面 return redirect("/book_list/") # 通过Get获取ID 将要修改的书籍对象传给页面 edit_id = request.GET.get("id",None) edit_obj = models.Book.objects.get(id=edit_id) # 获取所有出版社对象,传给页面的select all_publisher = models.Publisher.objects.all() return render(request,"edit_book.html",&#123;"all_publisher":all_publisher,"edit_obj":edit_obj&#125;) 编写edit_book.html页面 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;编辑书籍&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;编辑书籍&lt;/h1&gt;&lt;hr&gt;&lt;form action="/edit_book/" method="post"&gt; &#123;#提交数据的时候拿到书籍的ID#&#125; &lt;input type="text" name="id" value="&#123;&#123; edit_obj.id &#125;&#125;" style="display: none"&gt; &lt;input type="text" name="book_title" value="&#123;&#123; edit_obj.title &#125;&#125;"&gt; &#123;#select默认选中编辑书籍的出版社#&#125; &lt;select name="publusher"&gt; &#123;# 当前书籍关联的出版社才默认选中，其他的出版社不选中 #&#125; &#123;# 如果书的出版社的id值 &#123;&#123; book_obj.publisher.id &#125;&#125; 等于 publisher.id#&#125; &#123;% for publisher in all_publisher %&#125; &#123;% if edit_obj.publisher.id == publisher.id %&#125; &lt;option selected value="&#123;&#123; publisher.id &#125;&#125;"&gt;&#123;&#123; publisher.name &#125;&#125;&lt;/option&gt; &#123;#否则不选中#&#125; &#123;% else %&#125; &lt;option value="&#123;&#123; publisher.id &#125;&#125;"&gt;&#123;&#123; publisher.name &#125;&#125;&lt;/option&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/select&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 作者信息 添加、删除、修改多对多关系表的建立 ORM添加多对多的关联关系 models.ManyToManyField12345678class Author(models.Model): id = models.AutoField(primary_key=True) # 自增主键 name = models.CharField(max_length=64,null=False,unique=True) # 作者名字,不能为空,唯一 # 告诉ORM 这张表与book表是多对多的关联关系，ORM自动帮我们生成第三张关联表 名字是author_book book = models.ManyToManyField(to='Book') # ManyToManyField 关联Book表 会创建第三张关联表 def __str__(self): return '&lt;Author 名字&#123;&#125;&gt;'.format(self.name) urls.py预先定义所有方法函数和路径的对应关系12345# 作者所有相关url(r'^author_list/', views.author_list),url(r'^add_author/', views.add_author),url(r'^del_author/', views.del_author),url(r'^edit_author/', views.edit_author), 展示所有作者 author_list函数 12345678910111213def author_list(request): # 查询出所有作家信息 all_author = models.Author.objects.all().order_by("id") # 单取一个作者对象,查看他的book属性 # 作者对象里的book # author_obj = all_author[0] author_obj = models.Author.objects.get(id=1) print(author_obj.book.all()) # &lt;QuerySet [&lt;Book: Java&gt;, &lt;Book: Python&gt;]&gt; 当前作者.所有的书籍对象 print("=" * 120) return render(request,"author_list.html",&#123;"author_list":all_author&#125;) 展示作者页面 author_list.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;作家信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;作家信息&lt;/h1&gt;&lt;hr&gt;&lt;a href="/add_author/"&gt;添加新作者&lt;/a&gt;&lt;table border="1"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;作家姓名&lt;/th&gt; &lt;th&gt;书籍&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for author in author_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; author.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; author.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;#循环作者所有书籍对象 判断最后一个加上|分割#&#125; &#123;% for book in author.book.all %&#125; &#123;% if forloop.last %&#125; &#123;&#123; book.title &#125;&#125; &amp;nbsp; &#123;% else %&#125; &#123;&#123; book.title &#125;&#125; | &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/td&gt; &lt;td&gt; &lt;a href="/del_author/?id=&#123;&#123; author.id &#125;&#125;"&gt;删除&lt;/a&gt; &lt;a href="/edit_author/?id=&#123;&#123; author.id &#125;&#125;"&gt;编辑&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 添加作者 add_author函数 12* 要将所有书籍传给添加页面的select* 先创建新作者,使用set添加新作者与书的对应关系 12345678910111213141516171819# 添加作者def add_author(request): # 取到提交数据 if request.method == "POST": new_name = request.POST.get("author_name") # POST 提交的数据是多个值的时候,要用getlist,如多选的checkbox和多选的select new_author_book = request.POST.getlist("author_book") print(new_name,new_author_book) print("*" * 150) # 创建新作者 new_author_obj = models.Author.objects.create(name=new_name) # 使用set添加新作者与书的对应关系 new_author_obj.book.set(new_author_book) # 返回作者列表页面 return redirect("/author_list/") # 要将所有书籍传给添加页面的select all_book = models.Book.objects.all().order_by("id") return render(request,"add_author.html",&#123;"book_list":all_book&#125;) 添加add_author.html页面 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;添加作者&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;添加作者&lt;/h1&gt;&lt;hr&gt;&lt;form action="/add_author/" method="post"&gt; &lt;p&gt;作者姓名: &lt;input type="text" name="author_name"&gt; &lt;/p&gt; &lt;p&gt;选择作品: &#123;#多选,将所有图书放入多选框中#&#125; &lt;select multiple name="author_book"&gt; &#123;% for book in book_list %&#125; &lt;option value="&#123;&#123; book.id &#125;&#125;"&gt;&#123;&#123; book.title &#125;&#125;&lt;/option&gt; &#123;% endfor %&#125; &lt;/select&gt; &lt;/p&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 删除作者 del_author函数: 1234567# 删除作者def del_author(request): # 从GET里获取要删除的作者ID，然后直接删除 del_id = request.GET.get("id",None) models.Author.objects.get(id=del_id).delete() # 返回作者列表页面 return redirect("/author_list/") 编辑作者 edit_author函数 123451. 注意获取页面上的select或者checkbox多个值需要使用getlist接收2. 页面条件判断 当书在作者对象.book.all里时，才默认选中该书,否则不选中3. edit_obj.book.all()在函数中得到对象所有的书籍对象,但是在页面中无法使用()方法4. 更新数据需要使用对象.save()方法5. 更新作者对象的书籍,edit_obj.book.set(edit_books) 123456789101112131415161718192021222324252627282930def edit_author(request): if request.method == "POST": # 从POST里取得编辑作者的id、姓名、作品 edit_id = request.POST.get("id") edit_name = request.POST.get("author_name") edit_books = request.POST.getlist("author_books") print(edit_books) print(edit_name) print("*" * 100) # 根据ID找到编辑的是哪个作者对象, 最后提交更新数据 edit_obj = models.Author.objects.get(id=edit_id) # 更新数据 edit_obj.name = edit_name # 更新作者关联书籍的对应关系 edit_obj.book.set(edit_books) # 将所有的修改提交 edit_obj.save() # 返回作者列表页面 return redirect("/author_list/") # 通过GET获取用户编辑的作者ID，找到要编辑的作者对象,返回给edit_author.html edit_id = request.GET.get("id",None) edit_obj = models.Author.objects.get(id=edit_id) print(edit_obj.book.all()) # &lt;QuerySet [&lt;Book: &lt;object book_title=Python&gt;&gt;, &lt;Book: &lt;object book_title=GO&gt;&gt;]&gt; # 返回所有书籍返回给页面的select all_book = models.Book.objects.all() return render(request,'edit_author.html',&#123;"book_list":all_book,"edit_obj":edit_obj&#125;) 添加edit_author.html页面 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;编辑作者&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;编辑作者&lt;/h1&gt;&lt;hr&gt;&lt;form action="/edit_author/" method="post"&gt; &lt;input type="text" name="id" value="&#123;&#123; edit_obj.id &#125;&#125;" style="display: none"&gt; &lt;p&gt;作者姓名: &lt;input type="text" name="author_name" value="&#123;&#123; edit_obj.name &#125;&#125;"&gt; &lt;/p&gt; &lt;p&gt;作者作品: &lt;select name="author_books" multiple&gt; &#123;% for book in book_list %&#125; &#123;#判断,如果当前这本书 在 当前作者关联的书列表里 edit_id_obj.book.all #&#125; &#123;% if book in edit_obj.book.all %&#125; &lt;option selected value="&#123;&#123; book.id &#125;&#125;"&gt;&#123;&#123; book.title &#125;&#125;&lt;/option&gt; &#123;#否则，不选中#&#125; &#123;% else %&#125; &lt;option value="&#123;&#123; book.id &#125;&#125;"&gt;&#123;&#123; book.title &#125;&#125;&lt;/option&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/select&gt; &lt;/p&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 使用 Bootstrap模板 和 Font Awesome图标字体库去Bootstrap下载想要的模板 选择控制台模板https://v3.bootcss.com/examples/dashboard/ 右键另存为桌面,会下载两个文件: Dashboard Template for Bootstrap_files 目录:只保留dashboard.css即可 Dashboard Template for Bootstrap.html html文件 去Font Awesome官网下载图标字体库和CSS框架 http://fontawesome.dashgame.com 将下载好的文件放入static目录 套用首页模板 修改publisher_list 为old_publisher_list 修改Dashboard Template for Bootstrap.html 为publisher_list 替换首页的css引入: 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0042)https://v3.bootcss.com/examples/dashboard/ --&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;link rel="icon" href="https://v3.bootcss.com/favicon.ico"&gt; &lt;title&gt;添加作者&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="/static/bootstrap/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="/static/dashboard.css" rel="stylesheet"&gt; &lt;link href="/static/fontawesome/css/font-awesome.min.css" rel="stylesheet"&gt;&lt;/head&gt; 替换首页的jQuery引入: 12&lt;script src="/static/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;script src="/static/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt; Bootstrap和fontawesome的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;ul class="nav nav-sidebar"&gt; &lt;li class="active"&gt;&lt;a href="/publisher_list/"&gt;出版社列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/book_list/"&gt;书籍列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/author_list/"&gt;作者列表&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;h1 class="page-header"&gt;出版社管理页面&lt;/h1&gt; &#123;#面板#&#125; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt;书籍列表&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="row" style="margin-bottom: 20px"&gt; &lt;div class="col-md-4"&gt; &lt;div class="input-group"&gt; &lt;input type="text" class="form-control" placeholder="Search for..."&gt; &lt;span class="input-group-btn"&gt; &lt;button class="btn btn-default" type="button"&gt;搜索&lt;/button&gt; &lt;/span&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-md-4 --&gt; &lt;div class="col-md-2 pull-right"&gt; &lt;a href="/add_publisher/" class="btn btn-success"&gt;新页面添加&lt;/a&gt; &lt;button class="btn btn-success" data-toggle="modal" data-target="#myModal"&gt;新增&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.row --&gt; &lt;table class="table table-bordered " &gt; &lt;thead &gt; &lt;tr&gt; &lt;th class="text-center"&gt;序号&lt;/th&gt; &lt;th class="text-center"&gt;ID&lt;/th&gt; &lt;th class="text-center"&gt;出版社&lt;/th&gt; &lt;th class="text-center"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class="text-center"&gt; &#123;% for publisher in all_publisher %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; publisher.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-danger" href="/del_publisher/?id=&#123;&#123; publisher.id &#125;&#125;"&gt;&lt;i class="fa fa-trash-o fa-fw"&gt;&lt;/i&gt;删除&lt;/a&gt; &lt;a class="btn btn-primary" href="/edit_publisher/?id=&#123;&#123; publisher.id &#125;&#125;"&gt;&lt;i class="fa fa-pencil fa-fw"&gt;&lt;/i&gt;编辑&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 简单的写一个add_book.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0042)https://v3.bootcss.com/examples/dashboard/ --&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;link rel="icon" href="https://v3.bootcss.com/favicon.ico"&gt; &lt;title&gt;添加作者&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="/static/bootstrap/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="/static/dashboard.css" rel="stylesheet"&gt; &lt;link href="/static/fontawesome/css/font-awesome.min.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-6 col-md-offset-3"&gt; &#123;#页头#&#125; &lt;div class="page-header"&gt; &lt;h1&gt;添加页面&lt;/h1&gt; &lt;/div&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt;添加出版社&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;form class="form-horizontal" action="/add_publisher/" method="post"&gt; &lt;div class="form-group"&gt; &lt;label for="publisher_name" class="col-sm-3 control-label"&gt;出版社名称&lt;/label&gt; &lt;div class="col-sm-9"&gt; &lt;input type="text" name="publisher_name" class="form-control" id="publisher_name" placeholder="出版社名称"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-3 col-sm-9"&gt; &lt;button type="submit" class="btn btn-default"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="/static/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;script src="/static/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/html&gt; 简单的写一个edit_book.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0042)https://v3.bootcss.com/examples/dashboard/ --&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;link rel="icon" href="https://v3.bootcss.com/favicon.ico"&gt; &lt;title&gt;编辑出版社&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="/static/bootstrap/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="/static/dashboard.css" rel="stylesheet"&gt; &lt;link href="/static/fontawesome/css/font-awesome.min.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-6 col-md-offset-3"&gt; &#123;#页头#&#125; &lt;div class="page-header"&gt; &lt;h1&gt;编辑页面&lt;/h1&gt; &lt;/div&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt;编辑出版社&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;form class="form-horizontal" action="/edit_publisher/" method="post"&gt; &lt;input type="text" name="edit_id" value="&#123;&#123; edit_obj.id &#125;&#125;" style="display: none" &gt; &lt;div class="form-group"&gt; &lt;label for="publisher_name" class="col-sm-3 control-label"&gt;出版社名称&lt;/label&gt; &lt;div class="col-sm-9"&gt; &lt;input type="text" name="publisher_name" class="form-control" id="publisher_name" value="&#123;&#123; edit_obj.name &#125;&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-3 col-sm-9"&gt; &lt;button type="submit" class="btn btn-default"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="/static/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;script src="/static/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyMySQL]]></title>
    <url>%2F2019%2F08%2F20%2Fpymysql%2F</url>
    <content type="text"><![CDATA[PyMySQL介绍 PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用 mysqldb。 Django 中也可以使用 PyMySQL 连接 MySQL 数据库。 PyMySQL安装pip3 install pymysql 连接数据库 前提需要: 你有一个MySQL数据库，并且已经启动。 你有可以连接该数据库的用户名和密码 你有一个有权限操作的database 基本使用连接数据库并查询数据123456789101112131415161718192021222324252627282930313233import pymysql# http://www.cnblogs.com/liwenzhou/p/8032238.htmlif __name__ == '__main__': # 拿到用户输入用户名和密码 username = input('请输入用户名: ') password = input('请输入密码: ') # 去数据库里面判断用户名和密码是否正确 # 1. 连接数据库 conn = pymysql.connect( host="localhost", port=3306, database="userinfo", user="root", password="123", charset="utf8" # 千万记得么有 - ) # 光标 获取输入sql语句的光标对象 cursor = conn.cursor() # SQL语句 sql = "select * from info where username = 'leo' and password = '123';" # 执行语句 ret = cursor.execute(sql) print(ret) # 1 返回结果的行数 # 关闭连接 cursor.close() conn.close() 登录效验,规避SQL注入123456789101112131415161718192021222324252627282930import pymysqlif __name__ == '__main__': username = input("请输入用户名; ") passowrd = input("请输入密码: ") conn = pymysql.connect( host = "localhost", port = 3306, user = "root", password = "123", database = "userinfo", charset = "utf8" ) cursor = conn.cursor() sql = "select * from info where username = %s and password = %s ;" print(sql) print('*' * 100) ret = cursor.execute(sql,[username,passowrd]) # 让pymysql帮我们拼接sql语句 if ret: print('登录成功') else: print('登录失败!') cursor.close() conn.close() 增删改查操作增1234567891011121314151617181920212223242526272829303132333435import pymysqlif __name__ == '__main__': username = input("请输入要添加的用户名: ") password = input("请输入用户的密码: ") conn = pymysql.connect( host = "localhost", port = 3306, user = "root", password = "123", database = "userinfo", charset = "utf8" ) cursor = conn.cursor() sql = "insert into info (username,password) VALUES(%s,%s)" # 执行 try: cursor.execute(sql,[usernam,password]) # 提交事务: 读操作不用提交，写操作一定要提交 conn.commit() # 提交之后，获取刚插入的数据ID last_id = cursor.lastrowid print(last_id) except Exception as e: print("报错: ",str(e)) conn.rollback() # 有异常，回滚事务 # 插入数据失败回滚 # 在执行增删改操作时，如果不想提交前面的操作，可以使用 rollback() 回滚取消操作。 # 关闭 cursor.close() conn.close() 获取插入数据的ID(关联操作时会用到)12345678910111213141516171819202122232425262728293031323334353637383940414243import pymysqlif __name__ == '__main__': # username = input("请输入要添加的用户名: ") # password = input("请输入用户的密码: ") conn = pymysql.connect( host = "localhost", port = 3306, user = "root", password = "123", database = "userinfo", charset = "utf8" ) cursor = conn.cursor() # 创建班级 sql1 = "insert into class (name) VALUES(%s)" # 创建学生 sql2 = "insert into student (name,cid) VALUES(%s,%s)" # 执行 try: cursor.execute(sql1,['全棧10期']) new_id = cursor.lastrowid # 拿到前一条语句执行后的id值 print(new_id) cursor.execute(sql2, ['leo',new_id]) # 提交事务: 读操作不用提交，写操作一定要提交 conn.commit() # 提交之后，获取刚插入的数据ID last_id = cursor.lastrowid print(last_id) except Exception as e: print("报错: ",str(e)) conn.rollback() # 有异常，回滚事务 # 关闭 cursor.close() conn.close() 批量执行 executemany12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import pymysqlif __name__ == '__main__': conn = pymysql.connect( host = "localhost", port = 3306, user = "root", password = "123", database = "userinfo", charset = "utf8" ) cursor = conn.cursor() data = [ ("k", "123"), ("w", "123"), ("m", "123"), ] # 创建用户 sql = "insert into info (username,password) VALUES(%s,%s)" # 批量执行 try: # 一次执行多个语句 传入可迭代的数据类型 cursor.executemany(sql,data) new_id = cursor.lastrowid # 拿到前一条语句执行后的id值 print(new_id) # for 循环执行语句 一次只执行一条语句 # for i in data: # cursor.execute(sql,i) # new_id = cursor.lastrowid # 拿到前一条语句执行后的id值 # print(new_id) # 提交事务: 读操作不用提交，写操作一定要提交 conn.commit() # 提交之后，获最新的数据ID last_id = cursor.lastrowid print(last_id) except Exception as e: print("报错: ",str(e)) conn.rollback() # 有异常，回滚事务 # 关闭 cursor.close() conn.close() 删1234567891011121314151617181920212223if __name__ == '__main__': conn = pymysql.connect( host = "localhost", port = 3306, user = "root", password = "123", database = "userinfo", charset = "utf8" ) cursor = conn.cursor() # sql = "delete from info WHERE username = %s ;" # cursor.execute(sql,'k') sql = "delete from info WHERE id = %s ;" cursor.execute(sql,10) # 提交 conn.commit() # 关闭 cursor.close() conn.close() 改12345678910111213141516171819202122import pymysqlif __name__ == '__main__': conn = pymysql.connect( host = "localhost", port = 3306, user = "root", password = "123", database = "userinfo", charset = "utf8" ) cursor = conn.cursor() sql = "update info set password = %s WHERE username = %s ;" cursor.execute(sql,["000","rubin"]) # 提交 conn.commit() # 关闭 cursor.close() conn.close() 查 指定返回的数据格式为 字典格式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import pymysqlif __name__ == '__main__': conn = pymysql.connect( host = "localhost", port = 3306, user = "root", password = "123", database = "userinfo", charset = "utf8" ) # cursor = conn.cursor() # 指定返回的数据格式为 字典格式 cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) # sql语句 sql = "select * from info;" # 执行 # 返回的是受影响的行数，不是具体数据 cursor.execute(sql) # print("&#123;&#125; rows in set" .format(ret)) # 返回所有数据 元组 ((1, 'leo', '123')... ret = cursor.fetchall() print(ret) # 获取一条数据,查一条打印一条，没有就是None # ret = cursor.fetchone() # print(ret) # # ret = cursor.fetchone() # print(ret) # 获取指定数量数据 # ret = cursor.fetchmany(3) # print(ret) # ret = cursor.fetchone() # print(ret) # ret = cursor.fetchall() # print(ret) # [] 按照光标移动查询 之前已经都查过了 # 按照光标位置查询 absolute 绝对定位 到第一条 # cursor.scroll(1,mode="absolute") # ret = cursor.fetchall() # print(ret) # 按照光标位置查询 相对定位 从当前位置向下移动 # ret = cursor.fetchmany(2) # print(ret) # # cursor.scroll(1,mode="relative") # ret = cursor.fetchall() # print(ret) # 提交 查询无需提交 # conn.commit() # 关闭 cursor.close() conn.close() 查询多条数据12345678910111213141516# 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host="你的数据库地址", user="用户名",password="密码",database="数据库名",charset="utf8")# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()# 查询数据的SQL语句sql = "SELECT id,name,age from USER1;"# 执行SQL语句cursor.execute(sql)# 获取多条查询数据ret = cursor.fetchall()cursor.close()conn.close()# 打印下查询结果print(ret) 剥皮函数1234567891011121314151617181920212223if __name__ == '__main__': list1 = [11, [22, 3], [4, ], [55, 66], 8, [9, [7, [12, [34, [26]]]]]] # 去除多余嵌套的列表,得到[11, 22, 3, 4, 55, 66, 8]# 小剥皮def func(x): return [a for b in x for a in b]def func2(x): ret = [] for b in x: if isinstance(b,list): for a in func2(b): ret.append(a) else: ret.append(b) return retlist2 = [11,22]list2 = [11,[22,33]]list2 = [11,[22,33,[44,55]]]ret = func2(list1)print(ret)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>pymysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap]]></title>
    <url>%2F2019%2F07%2F29%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[Bootstrap 介绍Bootstrap是Twitter开源的基于HTML、CSS、JavaScript的前端框架。它是为实现快速开发Web应用程序而设计的一套前端工具包。它支持响应式布局，并且在V3版本之后坚持移动设备优先。 为什么要使用 Bootstrap？在Bootstrap出现之前：命名：重复、复杂、无意义（想个名字费劲）样式：重复、冗余、不规范、不和谐页面：错乱、不规范、不和谐在使用Bootstrap之后： 各种命名都统一并且规范化。 页面风格统一，画面和谐。重点是记住人家定义好的样式类 Bootstrap 下载官方地址：https://getbootstrap.com中文地址：http://www.bootcss.com https://v3.bootcss.com下载：用于生产环境的 Bootstrap ， https://v3.bootcss.com/getting-started/#download Bootstrap环境搭建目录结构:1234567891011121314151617181920212223bootstrap-3.3.7-dist/├── css // CSS文件│ ├── bootstrap-theme.css // Bootstrap主题样式文件│ ├── bootstrap-theme.css.map│ ├── bootstrap-theme.min.css // 主题相关样式压缩文件│ ├── bootstrap-theme.min.css.map│ ├── bootstrap.css│ ├── bootstrap.css.map│ ├── bootstrap.min.css // 核心CSS样式压缩文件│ └── bootstrap.min.css.map├── fonts // 字体文件│ ├── glyphicons-halflings-regular.eot│ ├── glyphicons-halflings-regular.svg│ ├── glyphicons-halflings-regular.ttf│ ├── glyphicons-halflings-regular.woff│ └── glyphicons-halflings-regular.woff2└── js // JS文件 ├── bootstrap.js ├── bootstrap.min.js // 核心JS压缩文件 └── npm.js处理依赖由于Bootstrap的某些组件依赖于jQuery，所以请确保下载对应版本的jQuery文件，来保证Bootstrap相关组件运行正常。 Bootstrap引入基本上使用min压缩后的文件，并且需要引入jQuery1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script src="bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Bootstrap全局样式排版、按钮、表格、表单、图片等我们常用的HTML元素，Bootstrap中都提供了全局样式。我们只要在基本的HTML元素上通过设置class就能够应用上Bootstrap的样式，从而使我们的页面更美观和谐。 引入文件示例12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;!--IE浏览器用edge渲染--&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!--手机适配--&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;title&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="bootstrap/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 登录注册示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"&gt; &lt;style&gt; body&#123; background-color: #eeeeee; &#125; #login-box&#123; margin-top: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div id="login-box" class="col-md-4 col-md-offset-4"&gt; &lt;h3 class="text-center"&gt;请登录&lt;/h3&gt; &lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-3 control-label"&gt;Email&lt;/label&gt; &lt;div class="col-sm-9 has-error"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt; &lt;span id="helpBlock" class="help-block hide"&gt;邮箱不能为空&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="inputPassword3" class="col-sm-3 control-label"&gt;Password&lt;/label&gt; &lt;div class="col-sm-9"&gt; &lt;input type="password" class="form-control" id="inputPassword3" placeholder="Password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-3 col-sm-9"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-3 col-sm-9"&gt; &lt;button type="submit" class="btn btn-primary btn-block"&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script src="bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; font-awesome 图标12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"&gt; &lt;link rel="stylesheet" href="fontAwesome/css/font-awesome.min.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;button class="btn btn-danger"&gt; &lt;i class="fa fa-trash-o"&gt;&lt;/i&gt; 删除 &lt;/button&gt; &lt;/div&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script src="bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫面试题 170 道]]></title>
    <url>%2F2019%2F07%2F22%2Fcase-170%2F</url>
    <content type="text"><![CDATA[语言特性谈谈对 Python 和其他语言的区别12345678Python的定位是“优雅”、“明确”、“简单”，容易入门，开发效率高，拥有非常强大的第三方库。Python属于解释型编程语言,属于动态语言,并且是强类型语言。同时具备可移植、可扩展，可嵌入等优点。拿 C 语言和 Python 比： Python 的第三方类库比较齐全并且使用简洁,很少代码就能实现一些功能，如果用 C 去实现相同的功能可能就比较复杂。但是对于速度来说 Python 的运行速度相较于 C 就比较慢了。所以有利的同时也有弊端，毕竟我们的学习成本降低了。线程不能利用多CPU问题，GIL即全局解释器锁。 简述解释型和编译型编程语言12编译型: 一次性将所有代码编译成二进制文件,运行效率高。解释型: 当程序执行时,将代码从上至下一行一行的解释成二进制，运行效率慢。 Python 的解释器种类以及相关特点？12345CPython C语言开发的，使用最广的解释器。IPython是基于CPython之上的一个交互式解释器,交互方式增强功能和 cPython 一样。PyPy,采用 JIT 技术。对 Python 代码进行动态编译，提高执行效率JPython 运行在 Java 上的解释器，直接把 Python 代码编译成 Java 字节码执行IronPython 运行在微软 .NET 平台上的解释器，把 Python 编译成 .NET 的字节码。 Python3 和 Python2 的区别？12345print 在 Python3 中是函数,必须加括号 print(&apos;hello&apos;)，Python2 中 print 为 class,print &apos;Hello, World!&apos;Python3中 input得到的为str;Python2的input的到的为int型，Python2的raw_input得到的为str类型Python2中 使用xrange，Python3 使用range。Python2 中存在老式类和新式类的区别，Python3 统一采用新式类。Python2 中默认的字符串类型默认是 ASCII，Python3 中默认的字符串类型是 Unicode。 Python3 和 Python2 中 int 和 long 区别？12python2中有long类型python3中没有long类型，只有int类型 xrange 和 range 的区别？12xrange 是在 Python2 中的用法，Python3 中只有 range。range 生成的不是一个 list 对象，而是一个生成器。 编码规范什么是 PEP8?1《Python Enhancement Proposal #8》（8 号 Python 增强提案）又叫 PEP8，他针对的 Python 代码格式而编订的风格指南。 了解 Python 之禅么？1234567891011121314151617181920212223242526272829303132333435363738通过 import this 语句可以获取其具体的内容。它告诉大家如何写出高效整洁的代码。&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.# 优美胜于丑陋（Python以编写优美的代码为目标）Explicit is better than implicit.# 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）Simple is better than complex.# 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）Complex is better than complicated.# 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）Flat is better than nested.# 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）Sparse is better than dense.# 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）Readability counts.# 可读性很重要（优美的代码是可读的）Special cases aren&apos;t special enough to break the rules.Although practicality beats purity.# 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）Errors should never pass silently.Unless explicitly silenced.# 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）In the face of ambiguity, refuse the temptation to guess.# 当存在多种可能，不要尝试去猜测There should be one-- and preferably only one --obvious way to do it# 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）Although that way may not be obvious at first unless you&apos;re Dutch.# 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）Now is better than never.Although never is often better than *right* now.# 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）If the implementation is hard to explain, it&apos;s a bad idea.If the implementation is easy to explain, it may be a good idea.# 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）Namespaces are one honking great idea -- let&apos;s do more of those!# 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）]]></content>
      <categories>
        <category>Python 面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 在CentOS6下由 2.7 升级到 3.6]]></title>
    <url>%2F2019%2F07%2F11%2Fpython-versions%2F</url>
    <content type="text"><![CDATA[升级原因由于公司内部的服务器使用CentOS6.6，默认的python版本是Python 2.7.14,自己所学习的事Python3,所以想要升级到学习版本。我在网上看了一些文章,由于很多基本的命令、软件包都依赖旧版本，比如：yum。所以，在更新 Python 时，建议不要删除旧版本（新旧版本可以共存）。 安装配置 在服务器下载新版本 1wget https://www.python.org/ftp/python/3.6.9/Python-3.6.9.tgz 解压缩 1tar -zxvf Python-3.6.9.tgz 安装配置 1234cd Python-3.6.9 ./configure# 如果执行报错:configure: error: no acceptable C compiler found in $PATH # 说明没有安装合适的编译器,这时，需要安装/升级 gcc 及其它依赖包: gcc yum install make gcc gcc-c++ 编译 &amp; 安装 12makemake install 验证 12345678910111213141516171819[root@localhost Python-3.6.9]# pythonPython 2.6.6 (r266:84292, Jul 23 2015, 15:22:56) [GCC 4.4.7 20120313 (Red Hat 4.4.7-11)] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; [root@localhost Python-3.6.9]# python3Python 3.6.9 (default, Jul 11 2019, 09:22:29) [GCC 4.4.7 20120313 (Red Hat 4.4.7-23)] on linuxType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; [root@localhost bin]# ls -l /usr/local/bin/python3*lrwxrwxrwx. 1 root root 9 Jul 11 09:24 /usr/local/bin/python3 -&gt; python3.6-rwxr-xr-x. 2 root root 10030878 Jul 11 09:23 /usr/local/bin/python3.6lrwxrwxrwx. 1 root root 17 Jul 11 09:24 /usr/local/bin/python3.6-config -&gt; python3.6m-config-rwxr-xr-x. 2 root root 10030878 Jul 11 09:23 /usr/local/bin/python3.6m-rwxr-xr-x. 1 root root 3083 Jul 11 09:24 /usr/local/bin/python3.6m-configlrwxrwxrwx. 1 root root 16 Jul 11 09:24 /usr/local/bin/python3-config -&gt; python3.6-config 设置 3.x 为默认版本 查看 Python 的路径，在 /usr/bin 下面。 可以看到 python 链接的是 python 2.7，所以，执行 python 就相当于执行 python 2.7。 1234[root@localhost bin]# ls -l /usr/bin/python*-rwxr-xr-x. 2 root root 9032 Jul 24 2015 /usr/bin/pythonlrwxrwxrwx. 1 root root 6 Aug 20 2018 /usr/bin/python2 -&gt; python-rwxr-xr-x. 2 root root 9032 Jul 24 2015 /usr/bin/python2.7 将原来 python 的软链接重命名： 12345678910111213141516[root@localhost bin]# mv /usr/bin/python /usr/bin/python.bak[root@localhost bin]# ls -l /usr/bin/python*lrwxrwxrwx. 1 root root 6 Aug 20 2018 /usr/bin/python2 -&gt; python-rwxr-xr-x. 2 root root 9032 Jul 24 2015 /usr/bin/python2.6-rwxr-xr-x. 2 root root 9032 Jul 24 2015 /usr/bin/python.bak[root@localhost bin]# ln -s /usr/local/bin/python3 /usr/bin/python[root@localhost bin]# ls -l /usr/bin/python*lrwxrwxrwx. 1 root root 22 Jul 11 09:43 /usr/bin/python -&gt; /usr/local/bin/python3lrwxrwxrwx. 1 root root 6 Aug 20 2018 /usr/bin/python2 -&gt; python-rwxr-xr-x. 2 root root 9032 Jul 24 2015 /usr/bin/python2.6-rwxr-xr-x. 2 root root 9032 Jul 24 2015 /usr/bin/python.bak[root@localhost bin]# python -VPython 3.6.9 配置 yum 升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件：123vim /usr/bin/yumvim /usr/libexec/urlgrabber-ext-down # CentOS6.8 没找到这个文件将 #!/usr/bin/python 改为 #!/usr/bin/python2.7，保存退出即可。]]></content>
      <categories>
        <category>Linux运维</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2019%2F06%2F20%2Fweb-jquery%2F</url>
    <content type="text"><![CDATA[jQuery 基础jQuery 介绍 jQuery是一个轻量级的、兼容多浏览器的JavaScript库。 jQuery使用户能够更方便地处理HTML Document、Events、实现动画效果、方便地进行Ajax交互，能够极大地简化JavaScript编程。它的宗旨就是：“Write less, do more.“ jQuery 的优势 jQuery 写起来极其简练，比JS使用起来方便顺手。 jQuery 是轻量级的JS框架，jQuery 核心js文件才几十kb，不会影响页面加载速度。、 jQuery 相当于Python 的第三方模块,第三方模块就是别人写好(封装)的一些代码，我们拿过来（按照别人定好的规则），原生的JS DOM操作是基础。 链式表达式，jQuery的链式操作可以把多个操作写在一行代码里，更加简洁。 事件、样式、动画支持。jQuery还简化了js操作css的代码，并且代码的可读性也比js要强。 Ajax操作支持。jQuery简化了AJAX操作，后端只需返回一个JSON格式的字符串就能完成与前端的通信。 跨浏览器兼容。jQuery基本兼容了现在主流的浏览器，不用再为浏览器的兼容问题而伤透脑筋。 插件扩展开发。jQuery有着丰富的第三方的插件，例如：树形菜单、日期控件、图片切换插件、弹出窗口等等基本前端页面上的组件都有对应插件，并且用jQuery插件做出来的效果很炫，并且可以根据自己需要去改写和封装插件，简单实用。 jQuery 内容123456789101112131. 选择器2. 筛选器3. 样式操作4. 文本操作5. 属性操作6. 文档处理7. 事件8. 动画效果9. 插件10. each、data、Ajax官网:https://jquery.com/中文文档:http://jquery.cuishifeng.cn/ jQuery 对象 jQuery对象就是通过jQuery包装DOM对象后产生的对象。 jQuery对象是 jQuery独有的。 如果一个对象是 jQuery对象，那么它就可以使用jQuery里的方法。 声明一个jQuery对象变量的时候在变量名前面加上$ 虽然 jQuery对象是包装 DOM对象后产生的，但是 jQuery对象无法使用 DOM对象的任何方法，同理 DOM对象也没不能使用 jQuery里的方法。 引入 12// 先导入,再使用&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt; 123// jQuery 和 DOM 找到d1的方法document.getElementById("d1") // DOM对象，找到一个具体的标签$("#d1") // JQuery对象,找到一个对象 123456789101112131415161718//JQuery对象转换成DOM对象,用索引去除具体的标签$("#i1").html() // 的意思是：获取id值为 i1的元素的html代码。其中 html()是jQuery里的方法。相当于document.getElementById("i1").innerHTML;// 当已经是一个 DOM对象的标签的时候 就可以调用DOM的方法了$("#p3")[0].innerHTMLvar $variable = jQuery对像var variable = DOM对象$variable[0] //jQuery对象转成DOM对象$("#i1").html();//jQuery对象可以使用jQuery的方法$("#i1")[0].innerHTML;// DOM对象使用DOM的方法// 把DOM转换成JQuery对象var pEle = document.getElementById("p1")pEle = $(pEle)$(pEle).html() jQuery 基础语法查找标签基本选择器 id选择器 1$("#id") class选择器 1$(".className") 标签选择器 1$("tagName") 配合使用 1$("div.c1") // 找到有c1 class类的div标签 所有元素选择器 1$("*") 组合选择器 123// 逗号,分割条件$("#id, .className, tagName")$("a,.c2,.c1") // ,代表或,找出a标签或class = c2,或class = c1的所有标签 层级选择器1234$("x y"); // x的所有后代y（子子孙孙）$("x &gt; y"); // x的所有儿子y（儿子）$("x + y"); // 找到所有紧挨在x后面的y$("x ~ y"); // x之后所有的兄弟y 1234567891011// 找到本页面中form标签中的所有input标签$("form input")// 找到本页面中被包裹在label标签内的input标签$("label&gt;input")// 找到本页面中紧挨在label标签后面的input标签$("label + input"); // 找到本页面中id为p2的标签后面所有和它同级的li标签$("#p2~li") 基本筛选器：123456789:first // 第一个:last // 最后一个:eq(index) // 索引等于index的那个元素:even // 匹配所有索引值为偶数的元素，从 0 开始计数:odd // 匹配所有索引值为奇数的元素，从 0 开始计数:gt(index) // 匹配所有大于给定索引值的元素:lt(index) // 匹配所有小于给定索引值的元素:not(元素选择器) // 移除所有满足not条件的标签:has(元素选择器) // 选取所有包含一个或多个标签在其内的标签(指的是从后代元素找) 1234567891011// 第一个li标签$("li:first")// 最后一个li标签$("li:last")// not移除不满足条件的: 有c2的样式不要$("p:not(.c2)")// 找到含有a标签的div$("#d3 div:has(a)") 1234$("div:has(h1)"); // 找到所有后代中有h1标签的div标签$("div:has(.c1)"); // 找到所有后代中有c1样式类的div标签$("li:not(.c1)"); // 找到所有不包含c1样式类的li标签$("li:not(:has(a))"); // 找到所有后代中不含a标签的li标签 属性选择器123[attribute][attribute=value] // 属性等于[attribute!=value] // 属性不等于 1234567891011121314151617181920&lt;!--属性选择器--&gt;&lt;form&gt; &lt;label&gt;用户名: &lt;input name="username" type="text" disabled="disabled"&gt;&lt;/label&gt; &lt;label&gt;密码: &lt;input name="pwd" type="password"&gt;&lt;/label&gt; &lt;label&gt;篮球 &lt;input name="hobby" value="basketball" type="checkbox"&gt;&lt;/label&gt; &lt;label&gt;足球 &lt;input name="hobby" value=football type="checkbox"&gt;&lt;/label&gt; &lt;label&gt;男 &lt;input name="gender" value="1" type="radio"&gt;&lt;/label&gt; &lt;label&gt;女 &lt;input name="gender" value="0" type="radio"&gt;&lt;/label&gt;&lt;/form&gt; 12$("input[name='hobby']")$("input[name='gender']") 表单筛选器123456789:text:password:file:radio:checkbox:submit:reset:button 123// 找到所有的text$("input[type='text']")$(":text") 表单对象属性 1234:enabled:disabled:checked:selected 12$(":disabled")$(":checked") 筛选器 下一个元素 123456789$("#id").next()$("#id").nextAll()$("#id").nextUntil("#i2") // ``` ** 上一个元素 **```javascript$("#id").prev()$("#id").prevAll()$("#id").prevUntil("#i2") 父亲元素 123$("#id").parent()$("#id").parents() // 查找当前元素的所有的父辈元素$("#id").parentsUntil() // 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止。 儿子和兄弟元素 12$("#id").children();// 儿子们$("#id").siblings();// 兄弟们 1234567$("#l3")$("#l3").prev()$("#l3").next()$("#l3").prevAll()$("#l3").nextAll()$("#l0").nextUntil("#l3")$("#l3").prevUntil("#l0") 12345678910链式操作:$("a")$("a").parent()$("a").parent().parent()$("a").parents()$("a").parents("body")$("#dd").children()$("#p2").siblings() 查找标签 123// 搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。$("div").find("p")// 等价于$("div p") 12var $c1Ele = $(".c1") // 有现成变量$c1Ele.find("div") 1234// 筛选// 筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配的范围。用逗号分隔多个表达式。$("div").filter(".c1") // 从结果集中过滤出有c1样式类的// 等价于 $("div.c1") 12345.first() // 获取匹配的第一个元素.last() // 获取匹配的最后一个元素.not() // 从匹配元素的集合中删除与指定表达式匹配的元素.has() // 保留包含特定后代的元素，去掉那些不含有指定后代的元素。.eq() // 索引值等于指定值的元素 12$("div").first()$("div").last() 筛选器方法总结1234567891011121314151 .next() # 找到挨着的下一个同级标签2 .nextAll(&quot;.c1&quot;) # 下边同级的所有 有c1这个class的3 .nextUntil() # 往下找，直到找到终止条件为止4 .prev()5 .prevAll()6 .prevUntil()7 .siblings() # 前后都能找到8 .children()9 .parent()10 .parents() # 一级一级的父标签，最后html11 .parentsUntil()12 .find(各种条件都可以写) 操作标签样式操作1234addClass(); // 添加指定的CSS类名。removeClass(); // 移除指定的CSS类名。hasClass(); // 判断样式存不存在toggleClass(); // 切换CSS类名，如果有就移除，如果没有就添加。 1234567891011121314151617181920212223242526272829303132&lt;!-- 开关灯--&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .c1&#123; height:200px; width: 200px; border-radius: 50%; background-color: red; &#125; .c2&#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="c1"&gt;&lt;/div&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 找标签 $("div.c1").click(function () &#123; console.log(this); // this 是DOM 对象 $(this).toggleClass("c2") // 转换成jQuery对象,使用jQuery方法 &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!--自定义模态框--&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .cover&#123; position: absolute; top: 0; right: 0; left: 0; bottom: 0; background-color: rgba(0,0,0,0.4); z-index: 998; &#125; .modal&#123; height: 400px; width: 600px; background-color: white; position: absolute; top: 50%; left: 50%; /*宽度的一半*/ margin-left: -300px; /*高度的一半*/ margin-top: -200px; z-index: 1000; &#125; .hide&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="b1"&gt;点我点我&lt;/button&gt;&lt;div class="cover hide"&gt;&lt;/div&gt;&lt;div class="modal hide"&gt; &lt;form action=""&gt; &lt;p&gt; &lt;label for=""&gt;用户名: &lt;input type="text"&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;密码: &lt;input type="password"&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;登录: &lt;input type="submit"&gt; &lt;input id="cancel" type="button" value="取消"&gt; &lt;/label&gt; &lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 找到点击弹出模态框按钮 $("#b1").click(function () &#123; $(".cover").removeClass("hide"); // 显示背景 $(".modal").removeClass("hide"); // 显示模态框 &#125;) // 找到取消按钮,绑定事件 $("#cancel").click(function () &#123; // 给背景和模态框 都加上hide $(".cover").addClass("hide"); // 显示背景 $(".modal").addClass("hide"); // 显示模态框 &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 直接修改样式12css("color","red") // DOM操作：tag.style.color="red"原生DOM .style.color = 'green' 1$("div").css("color","greeen"); 12345// 修改多个样式时，传入键值对$(this).css(&#123; "color":"pink", "font-size":"24px"&#125;) 1234567891011121314151617181920212223242526&lt;!--修改样式--&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;AAA&lt;/p&gt;&lt;p&gt;BBB&lt;/p&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 把当前点击的标签 变绿 // 在处理事件的函数中 用this 表示 当前触发事件的标签 $("p").click( function () &#123;// $(this).css("color","red")// $(this).css("font-size","24px") $(this).css(&#123; "color":"pink", "font-size":"24px" &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 位置操作1234offset() // 获取匹配元素在当前窗口的相对偏移或设置元素位置position() // 获取匹配元素相对父元素的偏移scrollTop() // 获取匹配元素相对滚动条顶部的偏移scrollLeft() // 获取匹配元素相对滚动条左侧的偏移 123456789101112131415161718192021222324# 获取位置$(".c1").offset()&#123;top: 0, left: 0&#125;# 设置位置$(".c1").offset(&#123;top:"100",left:100&#125;)$(".c3").offset() # 对左上角定位&#123;top: 400, left: 300&#125;$(".c3").position()&#123;top: 100, left: 100&#125;# 尺寸# 内容区 高和宽height()width()# 内容区 + paddinginnerHeight()innerWidth()# 内容区 + padding + borderouterHeight()outerWidth() 1234567891011121314151617181920&lt;!-- 返回顶部 --&gt;&lt;button id="b2" class="btn btn-default c2 hide"&gt;返回顶部&lt;/button&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; $("#b1").on("click", function () &#123; $(".c1").offset(&#123;left: 200, top:200&#125;); &#125;); $(window).scroll(function () &#123; if ($(window).scrollTop() &gt; 100) &#123; $("#b2").removeClass("hide"); &#125;else &#123; $("#b2").addClass("hide"); &#125; &#125;); $("#b2").on("click", function () &#123; $(window).scrollTop(0); &#125;)&lt;/script&gt; 文本操作123456789101112&lt;!--HTML代码：--&gt; html()// 取得第一个匹配元素的html内容 html(val)// 设置所有匹配元素的html内容&lt;!--文本值：--&gt; text()// 取得所有匹配元素的内容 text(val)// 设置所有匹配元素的内容&lt;!--值：--&gt; val()// 取得第一个匹配元素的当前值 val(val)// 设置所有匹配元素的值 val([val1, val2])// 设置多选的checkbox、多选select的值 12345678910111213141516171819202122232425262728293031323334$("#d1")[0].innerHTML$("#d1").html()$("#d1")[0].innerText$("#d1").text()# 都会修改整个标签,主要使用html修饰标签,可以支持html格式的字符串文本$("#d1").text("呵呵")$("#d1").html("&lt;a href='www.baidu.com'&gt;go&lt;/a&gt;")$(":text").val()$(":password").val()val() 永远只取第一个值，设置值的话就是全部设置// 获取多个值 需要使用循环var $checkedEles = $(":checkbox:checked");for (var i=0;i&lt;$checkedEles.length;i++)&#123; console.log($checkedEles[i]) console.log($($checkedEles[i]).val())&#125;// radio$(":radio")$(":radio:checked").val()// select$("#s1").val()// 多选$("#s2").val()(2) ["021", "020"]$("#s2").val(["021","020"]) //传值可以设置值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!--文本操作--&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .error&#123; color: red; &#125; /*.error:before&#123;*/ /*content: "*";*/ /*&#125;*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="d1"&gt; &lt;p&gt; &lt;span&gt;span&lt;/span&gt; &lt;div&gt;div&lt;/div&gt; &lt;/p&gt;&lt;/div&gt; &lt;form action="" id="f1"&gt; &lt;p&gt; &lt;label for=""&gt;用户名: &lt;input class="need" name="username" type="text"&gt; &lt;span class="error"&gt;&lt;/span&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;密码: &lt;input class="need" name="password" type="password"&gt; &lt;span class="error"&gt;&lt;/span&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt;爱好: &lt;label for=""&gt;篮球: &lt;input name="hobby" type="checkbox" value="basketball"&gt; &lt;/label&gt; &lt;label for=""&gt;足球: &lt;input name="hobby" type="checkbox" value="football"&gt; &lt;/label&gt; &lt;label for=""&gt;双色球: &lt;input name="hobby" type="checkbox" value="doubleball"&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt;性别: &lt;label for=""&gt;男: &lt;input name="gender" type="radio" value="1"&gt; &lt;/label&gt; &lt;label for=""&gt;女: &lt;input name="gender" type="radio" value="0"&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="s1"&gt;从哪来&lt;/label&gt; &lt;select name="from" id="s1"&gt; &lt;option value="010"&gt;北京&lt;/option&gt; &lt;option value="021"&gt;上海&lt;/option&gt; &lt;option value="020"&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="s2"&gt;到哪去&lt;/label&gt; &lt;select name="from" id="s2" multiple&gt; &lt;option value="010"&gt;北京&lt;/option&gt; &lt;option value="021"&gt;上海&lt;/option&gt; &lt;option value="020"&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="t1"&gt;个人简介&lt;/label&gt; &lt;textarea name="memo" id="t1" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;登录: &lt;input type="submit" id="b1"&gt; &lt;input id="cancel" type="button" value="取消"&gt; &lt;/label&gt; &lt;/p&gt; &lt;/form&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 点击登录按钮 用户名和密码 是否为空 // 为空就在对应input标签下面显示一个 错误信息 // 1. 给登录按钮绑定点击事件 // 2. 点击事件要做的事 // 1. 找到input标签取值,判断是否为空（长度是否为0,length是否=0） // 2. 如果不为空，则什么都不做 // 3. 如果为空，就要： // 1. 当前这个input标签的下面，添加一个新的标签，内容为 XX 不能为空 // 2. class="need" 可以为空 $("#b1").click(function () &#123; var $needEles = $(".need"); console.log($needEles); for (var i = 0;i &lt; $needEles.length;i++)&#123; if ($($needEles[i]).val().trim().length === 0)&#123; var labelName = $($needEles[i]).parent().text().trim().slice(0,-1) $($needEles[i]).next().text(labelName + "不能为空") &#125; &#125; return false &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 属性操作123456用于ID等或自定义属性：attr(attrName)// 返回第一个匹配元素的属性值attr(attrName, attrValue)// 为所有匹配元素设置一个属性值attr(&#123;k1: v1, k2:v2&#125;)// 为所有匹配元素设置多个属性值removeAttr()// 从每一个匹配的元素中删除一个属性 12345.attr() // $("a").attr("href") // $("a").attr("href","设置值") // $("a").attr(&#123;"href":"设置值"."title":"设置值"&#125;).prop() // 适用于checkbox 和 radio(返回true或false属性) 123456789101112$("img")r.fn.init [img, prevObject: r.fn.init(1)]$("img").attr("src")"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=7b36b75d25f5e0feee188e07645b5395/a8014c086e061d9581528f7c73f40ad162d9ca5a.jpg"$("img").attr("src","https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1562835484&amp;di=8a585e9fe3abf1cf8a85aa910c74f975&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180907%2F6efd963b18e5404dadb7b314576dc530.jpeg")r.fn.init [img, prevObject: r.fn.init(1)]$("img").attr(&#123;"src":"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1562835484&amp;di=8a585e9fe3abf1cf8a85aa910c74f975&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180907%2F6efd963b18e5404dadb7b314576dc530.jpeg","title":"jojo"&#125;)r.fn.init [img, prevObject: r.fn.init(1)]$("img").removeAttr("title") 1234567891011121314151617181920212223242526&lt;!--属性操作--&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=7b36b75d25f5e0feee188e07645b5395/a8014c086e061d9581528f7c73f40ad162d9ca5a.jpg" alt=""&gt;&lt;input type="button" id="b1" value="下一个"&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; var oldUrl; var newUrl = "https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1562835484&amp;di=8a585e9fe3abf1cf8a85aa910c74f975&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180907%2F6efd963b18e5404dadb7b314576dc530.jpeg" $("#b1").click(function () &#123; var $imgEles = $("img") // 修改img标签的src属性 oldUrl = $imgEles.attr("src") $imgEles.attr("src",newUrl) newUrl = oldUrl &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 选择按钮操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;职位&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;jojo&lt;/td&gt; &lt;td&gt;黄金之风&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;bobo&lt;/td&gt; &lt;td&gt;钢链手指&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;东方仗助&lt;/td&gt; &lt;td&gt;疯狂钻石&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;input type="button" id="b1" value="全选"&gt;&lt;input type="button" id="b2" value="反选"&gt;&lt;input type="button" id="b3" value="取消"&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 点击全选 表格中所有的checkbox都选中 // 1. 找checkbox // 2. 全部选中 checked : ture $("#b1").click(function () &#123; $(":checkbox").prop("checked",true) &#125;) // 点击取消 // 点击全选 表格中所有的checkbox都选中 // 1. 找checkbox // 2. 取消选中 checked : false $("#b3").click(function () &#123; $(":checkbox").prop("checked",false) &#125;) // 反选 // 1. 找到所有checkbox // 2. 判断 ： // 2.1 没有选中的要选中 // 2.2 原来选中的要取消选中 $("#b2").click(function () &#123; // 把所有的checkbox 都存在$checkboxEles中 var $checkboxEles = $(":checkbox"); // 遍历所有的checkbox,根据每一个checkbox的选种状态做不通的操作 for (var i=0;i&lt;$checkboxEles.length;i++)&#123; // 把每一个checkbox包装成jQuery对象 var $tmp = $($checkboxEles[i]) // 如果 checkbox是选中的，我们就取消选中 if ($tmp.prop("checked"))&#123; $tmp.prop("checked",false) &#125;else &#123; // 否则不选中 $tmp.prop("checked",true) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文档处理12345678910111213141516171819202122232425262728293031323334var liEle = document.createElement("li")var liEle = document.createElement("li")liEle.innerText=0liEle&lt;li&gt;​0​&lt;/li&gt;​$("#u1").append(liEle) // 在最后添加r.fn.init [ul#u1]$("#u1").prepend(liEle) // 同一个dom对象 liElevar liEle = document.createElement("li")liEle.innerText=44$(liEle).appendTo("#u1")$("#l1")r.fn.init [li#l1]var liEle = document.createElement("li")liEle.innerText=1.5$("#l1").after(liEle)r.fn.init [li#l1]移除和清空元素remove()// 从DOM中删除所有匹配的元素。empty()// 删除匹配的元素集合中所有的子节点。$("#u1")$("#u1").remove() // 直接把ul标签急内部子标签都删除$("#u1").empty() // 删除ul内部标签 增加表格记录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1" id="t1"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;替身&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;Leo&lt;/td&gt; &lt;td&gt;黄金之风&lt;/td&gt; &lt;td&gt;&lt;button class="delete"&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;Lex&lt;/td&gt; &lt;td&gt;疯狂钻石&lt;/td&gt; &lt;td&gt;&lt;button class="delete"&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;button id="b1"&gt;添加一行数据&lt;/button&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 绑定事件 // 生成添加的tr标签和数据 // 把生成的tr插入到表格 $("#b1").click(function () &#123; var trEle = document.createElement("tr"); $(trEle).html("&lt;td&gt;3&lt;/td&gt;&lt;td&gt;rubin&lt;/td&gt;" + "&lt;td&gt;钢链手指&lt;/td&gt;&lt;td&gt;&lt;button class=\"delete\"&gt;删除&lt;/button&gt;&lt;/td&gt;"); $("#t1").find("tbody").append(trEle); &#125;) // 每一行的删除按钮绑定事件 $(".delete").click(function () &#123; $(this).parent().parent().remove() // 找到他的tr .remove &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 替换1234567891011121314151617181920212223242526&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;a href="www.baidu.com"&gt;aaa&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=""&gt;bbb&lt;/a&gt;&lt;/p&gt;&lt;button id="b1"&gt;替换&lt;/button&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; $("#b1").click(function () &#123; var imgEle = document.createElement("img") $(imgEle).attr("src","https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1562666099791&amp;di=f40cd71f3f9b66125fb72217ac77e1b5&amp;imgtype=0&amp;src=http%3A%2F%2Fimg2.178.com%2Facg1%2F201204%2F128126936227%2F128127453027.jpg") $("a").replaceWith(imgEle) $(imgEle).replaceAll("a") // 替换所有的a标签 &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 克隆12345678910111213141516171819&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="b1"&gt;克隆&lt;/button&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; $("#b1").click(function () &#123; $(this).clone(true).insertAfter(this) // true 代表连标签的事件也一起clone &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件常用事件123456click(function()&#123;...&#125;)hover(function()&#123;...&#125;)blur(function()&#123;...&#125;)focus(function()&#123;...&#125;)change(function()&#123;...&#125;)keyup(function()&#123;...&#125;) 事件绑定1234.on( events [, selector ],function()&#123;&#125;)events： 事件selector: 选择器（可选的）function: 事件处理函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .error&#123; color: red; &#125; /*.error:before&#123;*/ /*content: "*";*/ /*&#125;*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" id="f1"&gt; &lt;p&gt; &lt;label for=""&gt;用户名: &lt;input class="need" name="username" type="text"&gt; &lt;span class="error"&gt;&lt;/span&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;密码: &lt;input class="need" name="password" type="password"&gt; &lt;span class="error"&gt;&lt;/span&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt;爱好: &lt;label for=""&gt;篮球: &lt;input name="hobby" type="checkbox" value="basketball"&gt; &lt;/label&gt; &lt;label for=""&gt;足球: &lt;input name="hobby" type="checkbox" value="football"&gt; &lt;/label&gt; &lt;label for=""&gt;双色球: &lt;input name="hobby" type="checkbox" value="doubleball"&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt;性别: &lt;label for=""&gt;男: &lt;input name="gender" type="radio" value="1"&gt; &lt;/label&gt; &lt;label for=""&gt;女: &lt;input name="gender" type="radio" value="0"&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="s1"&gt;从哪来&lt;/label&gt; &lt;select name="from" id="s1"&gt; &lt;option value="010"&gt;北京&lt;/option&gt; &lt;option value="021"&gt;上海&lt;/option&gt; &lt;option value="020"&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="s2"&gt;到哪去&lt;/label&gt; &lt;select name="from" id="s2" multiple&gt; &lt;option value="010"&gt;北京&lt;/option&gt; &lt;option value="021"&gt;上海&lt;/option&gt; &lt;option value="020"&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="t1"&gt;个人简介&lt;/label&gt; &lt;textarea name="memo" id="t1" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;登录: &lt;input type="submit" id="b1"&gt; &lt;input id="cancel" type="button" value="取消"&gt; &lt;/label&gt; &lt;/p&gt; &lt;/form&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 点击登录按钮 用户名和密码 是否为空 // 为空就在对应input标签下面显示一个 错误信息 // 1. 给登录按钮绑定点击事件 // 2. 点击事件要做的事 // 1. 找到input标签取值,判断是否为空（长度是否为0,length是否=0） // 2. 如果不为空，则什么都不做 // 3. 如果为空，就要： // 1. 当前这个input标签的下面，添加一个新的标签，内容为 XX 不能为空 // 2. class="need" 可以为空 $("#b1").click(function () &#123; var $needEles = $(".need"); // 定义一个标志位: var flag = true; console.log($needEles); for (var i = 0;i &lt; $needEles.length;i++)&#123; // 如果有错误 if ($($needEles[i]).val().trim().length === 0)&#123; var labelName = $($needEles[i]).parent().text().trim().slice(0,-1) $($needEles[i]).next().text(labelName + "不能为空") // 将标志位 变成false flag = false break; &#125; &#125; return false &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!--使用on绑定事件--&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1" id="t1"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;替身&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;Leo&lt;/td&gt; &lt;td&gt;黄金之风&lt;/td&gt; &lt;td&gt;&lt;button class="delete"&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;Lex&lt;/td&gt; &lt;td&gt;疯狂钻石&lt;/td&gt; &lt;td&gt;&lt;button class="delete"&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;button id="b1"&gt;添加一行数据&lt;/button&gt;&lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 绑定事件 // 生成添加的tr标签和数据 // 把生成的tr插入到表格 $("#b1").on("click",function () &#123; var trEle = document.createElement("tr"); $(trEle).html("&lt;td&gt;3&lt;/td&gt;&lt;td&gt;rubin&lt;/td&gt;" + "&lt;td&gt;钢链手指&lt;/td&gt;&lt;td&gt;&lt;button class=\"delete\"&gt;删除&lt;/button&gt;&lt;/td&gt;"); $("#t1").find("tbody").append(trEle); &#125;) // 每一行的删除按钮绑定事件 $("tbody").on("click",".delete",function () &#123;// console.log(this) &lt;button class="delete"&gt;删除&lt;/button&gt; $(this).parent().parent().remove() // 找到他的tr .remove &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面载入12345678910111213141516171819202122&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; // 确保绑定事件的时候DOM树是生成好 // 等DOM树生成之后，我再执行 $(document).ready(function () &#123; console.log($("#d1").text()) // 执行绑定事件的操作 &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="d1"&gt;div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM 和 DOM 对象]]></title>
    <url>%2F2019%2F06%2F12%2Fweb-object%2F</url>
    <content type="text"><![CDATA[基础知识 JavaScript分为 ECMAScript，DOM，BOM。 BOM （Browser Object Model）是指浏览器对象模型，它使 JavaScript 有能力与浏览器进行“对话”。 DOM （Document Object Model）是指文档对象模型，通过它，可以访问HTML文档的所有元素(标签)。 BOM 对象BOM（Browser Object Mode）浏览器对象模型，是Javascript的重要组成部分。它提供了一系列对象用于与浏览器窗口进行交互，这些对象通常统称为BOM。 window 对象 – BOM核心1、它表示整个浏览器窗口，主要用来操作浏览器窗口2、所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。3、全局变量是 window 对象的属性。全局函数是 window 对象的方法。4、Window对象是客户端JavaScript最高层对象之一，由于window对象是其它大部分对象的共同祖先，在调用window对象的方法和属性时，可以省略window对象的引用。例如：window.document.write()可以简写成：document.write()。 所有浏览器都支持 window 对象。 概念上讲.一个html文档对应一个window对象。 功能上讲: 控制浏览器窗口的。 使用上讲: window对象不需要创建对象,直接使用即可。 12345// 一些常用的Window方法：window.innerHeight - 浏览器窗口的内部高度window.innerWidth - 浏览器窗口的内部宽度window.open() - 打开新窗口window.close() - 关闭当前窗口 window 的子对象navigator对象（了解即可）12345// 浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息。navigator.appName // Web浏览器全称navigator.appVersion // Web浏览器厂商和版本的详细字符串navigator.userAgent // 客户端绝大部分信息navigator.platform // 浏览器运行所在的操作系统 screen对象（了解即可）123// 屏幕对象，不常用。screen.availWidth - 可用的屏幕宽度screen.availHeight - 可用的屏幕高度 history对象（了解即可）123// 浏览历史对象，包含了用户对当前页面的浏览历史，但我们无法查看具体的地址，可以简单的用来前进或后退一个页面。history.forward() history.back() location对象12345678910// 用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。location.herf = 'url地址'location.hostname // 返回 web 主机的域名location.pathname // 返回当前页面的路径和文件名location.port // 返回 web 主机的端口 （80 或 443）location.portocol // 返回页面使用的web协议。 http:或https:location.href // 获取当前的URLlocation.href = 'http://www.baidu.com' // 跳转到指定的URLlocation.reload() // 重新加载当前页面 弹出框1234// JavaScript 中创建三种消息框：警告框、确认框、提示框。alert('提示信息'); // 警告框confirm("确认信息"); // 确认框prompt("请在下方输入","你的答案"); // 提示框 定时器 setTimeout() 和 clearTimeout() 在指定时间之后执行一次相应函数。 setInterval() 和 clearInterval() 在指定的周期（以毫秒计）来调用函数或计算表达式。 123456789101112// 一定时间间隔之后执行// 语法: var t=setTimeout("JS语句",毫秒)var t = setTimeout("alert('发送成功')",3000)// 函数定时执行function func()&#123; alert('发送成功')&#125;var t = setTimeout(func,3000)// 取消setTimeout设置clearTimeout(t) 123456789// 每隔多少秒执行一次// 语法：var t = setInterval("JS语句",时间间隔)function foo()&#123; console.log(1)&#125;;var t = setInterval(foo,1000)// 取消setInterval设置clearInterval(t); DOM 对象 DOM（Document Object Model）是一套对文档的内容进行抽象和概念化的方法。 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被构造为对象的树。 HTML DOM 树 dom树是为了展示文档中各个对象之间的关系，用于对象的导航。 DOM都有哪一些内容 HTML 文档中的每个成分都是一个节点。 DOM标准规定HTML文档中的每个成分都是一个节点(node)： 文档节点(document对象)：代表整个文档 元素节点(element 对象)：代表一个元素（标签） 文本节点(text对象)：代表元素（标签）中的文本 属性节点(attribute对象)：代表一个属性，元素（标签）才有属性 注释是注释节点(comment对象) JS 操作DOM JavaScript 可以通过DOM创建动态的 HTML JavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 查找标签直接查找12// 通过id查找标签document.getElementById("d1") 12// 根据class属性获取所有标签document.getElementsByClassName("p1") 12// 根据标签名获取标签合集document.getElementsByTagName("div") 间接查找123456parentElement // 父节点标签元素children // 所有子标签firstElementChild // 第一个子标签元素lastElementChild // 最后一个子标签元素nextElementSibling // 下一个兄弟标签元素previousElementSibling // 上一个兄弟标签元素 1234567// 查找父节点// 子节点.parentElementvar d3Ele = document.getElementById("d3")d3Ele.parentElement// &lt;div id=​"d2"&gt;​…​&lt;/div&gt;​d3Ele.parentElement.parentElement// &lt;body&gt;​…​&lt;/body&gt;​ 12345// 查找所有子标签// 父节点.childrenvar d2Ele = document.getElementById("d2")d2Ele.childrend2Ele.childNodes 123456// 第一个子标签元素 和 最后一个var d2Ele = document.getElementById("d2")d2Ele.firstElementChild // &lt;div id=​"d3"&gt;​d2里面的d3​&lt;/div&gt;​d2Ele.lastElementChild// &lt;div id=​"d5"&gt;​d2里面的d5​&lt;/div&gt;​ 123456// 下一个兄弟标签元素 和 上一个var d4Ele = document.getElementById("d4")d4Ele.previousElementSibling// &lt;div id=​"d3"&gt;​d2里面的d3​&lt;/div&gt;​d4Ele.nextElementSibling// &lt;div id=​"d5"&gt;​d2里面的d5​&lt;/div&gt;​ 节点操作创建节点12// 语法：createElement(标签名)var divEle = document.createElement("div"); 添加节点1234// 追加一个子节点（作为最后的子节点）// somenode.appendChild(newnode)；// 把增加的节点放到某个节点的前边。// somenode.insertBefore(newnode,某个节点); 1234567var imgEle = document.createElement("img") // 创建img节点// 给igm节点添加一个src属性imgEle.src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1560341306312&amp;di=67d00a7580c18d13000ced0c9df87e35&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2Fd487c4c496b952e7463a9ac2a041643a.jpeg"// 添加img节点到d1标签中var d1Ele = document.getElementById("d1")d1Ele.appendChild(imgEle) // 把创建好的imgEle添加到id=d1的标签内部 123456789// 在某个标签前面添加 insertBefore(要插入的新标签，哪个标签之前)var divEle = document.createElement("div") // 创建新的div标签divEle.innerText = "大家好" // 添加文本"大家好"var d4Ele = document.getElementById("d4") // 找到要加入的父标签var d2Ele = document.getElementById("d2") // 找到要加入到前面的子标签d2.insertBefore(divEle,d4Ele) // 在d4标签之前加入新div标签&lt;div&gt;​大家好​&lt;/div&gt;​ 删除节点1234567// 语法:somenode.removeChild(要删除的节点)// 获得要删除的元素，通过父元素调用该方法删除。var d2Ele = document.getElementById("d2")d2Ele.firstElementChild// &lt;div id=​"d3"&gt;​d2里面的d3​&lt;/div&gt;​var sonEle = d2Ele.firstElementChild;d2Ele.removeChild(sonEle) 替换节点123456789// 语法:somenode.replaceChild(newnode, 某个节点);var d2Ele = document.getElementById("d2")var sonEle = d2Ele.firstElementChild;var aEle = document.createElement("a")aEle.innerText="点我""点我"aEle.href="http://www.baidu.com""http://www.baidu.com"d2Ele.replaceChild(aEle,sonEle) 属性操作获取属性123// 获取元素节点中指定属性的属性值var d2Ele = document.getElementById("d2")d2Ele.getAttribute("id") 设置属性123456789// 默认属性都可以修改 d2Ele.setAttribute("age",18)d2.getAttribute("age")"18"// 自带的属性还可以直接.属性名来获取和设置imgEle.src="..."aEle.innerText="点我"aEle.href="http://www.baidu.com" 删除属性123d2.removeAttribute("age")d2.getAttribute("age")null 文本操作 innerHTML 和 innerText的区别: * innerHTML:子标签和子标签的内容都取出来,主要记这个:快速添加简单的标签 * innerText:只取标签之间的内容 获取标签文本12345678910// 获取标签内的文本信息var d2Ele = document.getElementById("d2")d2Ele.innerText// "d2里面的d3// d2里面的d4// d2里面的d5"var d4Ele = document.getElementById("d4")d4Ele.innerText// "d2里面的d4" 替换标签文本1d2Ele.innerText = "全部修改" // 修改文本内容 连子标签都没了,只剩下了文本 获取标签和文本12345678// 获取d2下面所有html内容,包括标签和文本var d2Ele = document.getElementById("d2")d2Ele.innerHTML//"// &lt;div id="d3"&gt;d2里面的d3&lt;/div&gt;// &lt;div id="d4"&gt;d2里面的d4&lt;/div&gt;// &lt;div id="d5"&gt;d2里面的d5&lt;/div&gt;//" 快速添加简单的标签12// 原先的标签会被替换d2Ele.innerHTML = "&lt;p&gt;我是新的p标签&lt;/p&gt;" 获取值操作123// 语法：elementNode.value// 适用于以下标签：// input、select、textarea 1234567891011121314151617181920var textEle = document.getElementById("i1")textEle.value"leo"var selectEle = document.getElementById("s1")selectEle.value"010"var tEle = document.getElementById("t1")tEle.value"哈哈哈"``` ### class 操作```javascriptclassName // 获取所有样式类名(字符串)classList.remove(cls) // 删除指定类classList.add(cls) // 添加类classList.contains(cls) // 存在返回true，否则返回falseclassList.toggle(cls) // 存在就删除，否则添加 1&lt;div class="c1 c2 c3"&gt;div&lt;/div&gt; 1234567891011121314151617181920212223242526272829var divEles = document.getElementsByTagName("div")divEles[0].className"c1 c2 c3"// 删除其中一个class样式 c3divEles[0].classList.remove("c3")divEles[0].className"c1 c2"// 添加一个class样式 c99divEles[0].classList.add("c99")divEles[0].className"c1 c2 c99"// 测试是否存在c3 和 c99 divEles[0].classList.contains("c3")falsedivEles[0].classList.contains("c99")true// 测试存在删除,不存在则添加divEles[0].classList.toggle("c3")true divEles[0].className"c1 c2 c99 c3" divEles[0].classList.toggle("c3")false divEles[0].className"c1 c2 c99" 123456789101112131415161718192021// 切换颜色实例&lt;style&gt; .c1&#123; height: 200px; width: 200px; border-radius: 50%; background-color: gray; &#125; .c2 &#123; background-color: yellow; &#125;&lt;/style&gt;&lt;div class="c1 c2 c3" onclick="change(this);"&gt;div&lt;/div&gt;&lt;script&gt; function change(ths) &#123; ths.classList.toggle("c2") // 点一下 有c2就去掉,没c2就加上，相当于来回切换 &#125;&lt;/script&gt; 指定CSS操作123// dom 直接修改样式var divEles = document.getElementsByTagName("div")divEles[0].style.backgroundColor="blue" // 原先带_改成了驼峰 JS操作CSS属性的规律： 123456// 1.对于没有中横线的CSS属性一般直接使用style.属性名即可。如：obj.style.marginobj.style.widthobj.style.leftobj.style.position 123456// 2.对含有中横线的CSS属性，将中横线后面的第一个字母换成大写即可。如：obj.style.marginTopobj.style.borderLeftWidthobj.style.zIndexobj.style.fontFamily 事件常用事件123456789101112131415161718onclick //当用户点击某个对象时调用的事件句柄。ondblclick //当用户双击某个对象时调用的事件句柄。onfocus //元素获得焦点。 练习：输入框onblur //元素失去焦点。 应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.onchange //域的内容被改变。 应用场景：通常用于表单元素,当元素内容被改变时触发.（select联动）onkeydown //某个键盘按键被按下。 应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.onkeypress //某个键盘按键被按下并松开。onkeyup //某个键盘按键被松开。onload //一张页面或一幅图像完成加载。onmousedown //鼠标按钮被按下。onmousemove //鼠标被移动。onmouseout //鼠标从某元素移开。onmouseover //鼠标移到某元素之上。onselect //在文本框中的文本被选中时发生。onsubmit //确认按钮被点击，使用的对象是form。 绑定方式123456789101112131415161718192021&lt;div class="c1 c2 c3" onclick="change(this);"&gt;div&lt;/div&gt;&lt;div class="c1 c2 c3"&gt;div&lt;/div&gt;&lt;div class="c1 c2 c3"&gt;div&lt;/div&gt;&lt;div class="c1 c2 c3"&gt;div&lt;/div&gt;&lt;script&gt; // 第一种方式 在标签里调用onclick，然后写函数方法 function change(ths) &#123; ths.classList.toggle("c2") // 点一下 有c2就去掉,没c2就加上，相当于来回切换 &#125; // 第二种方式 js代码绑定事件 找所有的div，循环每一个去绑定一个事件 var divEles = document.getElementsByTagName("div") // 获得div的数组 for (var i = 0;i&lt;divEles.length;i++)&#123; divEles[i].onclick = function ()&#123; this.classList.toggle("c2") // 哪个标签被点击,this就是谁 &#125; &#125;&lt;/script&gt; 事件示例定时器练习1234567891011121314151617181920212223242526272829303132333435363738394041&lt;input id="i1" type="text"&gt;&lt;input type="button" id = "start" value="开始"&gt;&lt;input type="button" id = "stop" value="停止"&gt;&lt;script&gt; // 声明全局的t，保存定时器的ID var t; // undefind // 在input框 显示当前时间 // 1.获取当前时间 function get_time() &#123; var now = new Date(); var nowStr = now.toLocaleString(); // 2.时间字符串填到input框 var i1Ele = document.getElementById("i1"); i1Ele.value = nowStr &#125; // 3. 点开始让时间动起来 每隔一秒钟就执行一次获取时间函数 get_time() // 找到开始按钮，并绑定事件 var startbutton = document.getElementById("start"); startbutton.onclick = function () &#123; // 先执行一次get_time，就不会有空隙 get_time() // 每隔一秒执行 定时器 // 如果不等于undefined 说明已经存在定时器 if (t === undefined)&#123; t = setInterval(get_time,1000); // 把定时器的ID 赋值给之前声明的全局变量t &#125; &#125; var stopbutton = document.getElementById("stop"); stopbutton.onclick = function () &#123; // 停止定时器 clearInterval(t) // 清除T对应的定时器,t的值还在 console.log(t); t = undefined // 初始化值 &#125;&lt;/script&gt; 搜索框1234567891011121314151617181920&lt;!--test框的默认值，在点击test框时消失--&gt;&lt;input type="text" id="i1" value="对子哈特" &gt;&lt;input type="button" value="搜索"&gt;&lt;script&gt; // 找到input框 var i1Ele = document.getElementById("i1") i1Ele.onfocus = function () &#123; // 把value青龙 this.value = ""; &#125; i1Ele.onblur = function () &#123; // 失去焦点之后，如果值是空叫填写回去 if (!this.value.trim())&#123; this.value = "对子哈特" &#125; &#125; &lt;/script&gt; select 联动123456789101112131415161718192021222324252627282930313233343536&lt;select name="" id="s1"&gt; &lt;option value="0"&gt;--请选择--&lt;/option&gt; &lt;option value="1"&gt;北京&lt;/option&gt; &lt;option value="2"&gt;上海&lt;/option&gt;&lt;/select&gt;&lt;select name="" id="s2"&gt; &lt;option value=""&gt;&lt;/option&gt;&lt;/select&gt;&lt;script&gt; var data = &#123;1:["西城区","朝阳区","东城区"],2:["静安区","闵行区","浦东区"]&#125;; // 给第一个select绑定事件,onchange var s1Ele = document.getElementById("s1"); s1Ele.onchange = function () &#123; // 取到选择的是哪一个 市 // 把对应市的区 填写到第二个select框里 console.log(this.value); var areas = data[this.value]; // 获得对应的区 var s2Ele = document.getElementById("s2") // 清空之前的标签 s2Ele.innerHTML = ""; // 生成option标签 for (var i = 0;i&lt;areas.length;i++)&#123; var opEle = document.createElement("option"); opEle.innerText= areas[i]; s2Ele.appendChild(opEle) &#125; // 添加到select内部 &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2019%2F05%2F29%2Fjavascript%2F</url>
    <content type="text"><![CDATA[JavaScript 介绍 完整的 JavaScript 实现是由以下 3 个不同部分组成的: 核心（ECMAScript） 文档对象模型（DOM） Document object model (整合js，css，html) 浏览器对象模型（BOM） Broswer object model（整合js和浏览器） Javascript 在开发中绝大多数情况是基于对象的.也是面向对象的. ECMAScriptECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。 ES6就是指ECMAScript 6。 简单地说，ECMAScript 描述了以下内容： 语法 类型 语句 关键字 保留字 运算符 对象 (封装 继承 多态) 基于对象的语言.使用对象. JavaScript 概述 JavaScript是脚本语言, 将JS插入 HTML 页面后，可由所有的现代浏览器执行。 JS跑在浏览器上，他的解释器就是浏览器，有浏览器就能跑 JS。 JavaScript 基础JS 引入方式 JS文件是在后端写的，浏览器通过网络从后端拿过来，然后在执行，如果找不到JS文件浏览器并不会报错 直接编写 123&lt;script&gt; alert('hello')&lt;/script&gt; 文件引入 1&lt;script src="jojo.js"&gt;&lt;/script&gt; JS 语言规范注释1// 单行注释 1/* 我是多行注释 */ 结束符 js语句之间有分号(;)为结束符,python通过缩进 JS 语言基础变量声明 js属于动态类型。(同一个变量可以存不同数据类型的值) 声明变量使用 var 变量名; 的格式来进行声明。 一行可以声明多个变量.并且可以是不同类型。 JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。 js中$也可以做变量名。12var userName = 'leo';var userName = 'leo',age = 28,city="beijing"; 注意 变量名是区分大小写的。 推荐使用驼峰式命名规则。Camel 标记法首字母是小写的，接下来的字母都以大写字符开头。例如：var myTestValue = 0, mySecondValue = “hi”; 保留字不能用做变量名。 保留字列表12345678910111213141516171819202122232425262728293031abstractbooleanbytecharclassconstdebuggerdoubleenumexportextendsfinalfloatgotoimplementsimportintinterfacelongnativepackageprivateprotectedpublicshortstaticsupersynchronizedthrowstransientvolatile JS 数据类型 JS 动态类型 JS属于动态类型语言 动态类型：声明变量即可以是字符串也可以是数字 静态类型，在声明变量的时候，声明类型，严谨，执行效率快，不用判断变量，范围缩小 1234567891011var x typeof(x)"undefined"var name = "leo"typeof(name)"string"var age = 28typeof(age)"number" 数值(Number) JavaScript不区分整型和浮点型，就只有一种数字类型。 12345678910var n1 = 28var n2 = 28.00var n3 = NaN ### NaN，表示不是一个数字（Not a Number）。typeof(n1)"number"typeof(n2)"number"typeof(n3)"number" 123var name = 'leo'parseInt(name) ### 表示强转后，结果并不是一个数字NaN 字符串(String) 字符串拼接用 + 号 12345var s1 = "jojo"var s2 = "bobo"var s3 = s1+s2console.log(s3)### jojobobo 字符串的常用方法 布尔值(Boolean) 区别于Python，true和false都是小写。 “”(空字符串)、0、null、undefined、NaN都是false 12var a = true;var b = false; null和undefined null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null; undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。 函数无明确的返回值时，返回的也是undefined。 null表示变量的值是空，undefined则表示只声明了变量，但还没有赋值。 123null == undefined弱等于 10 == "10"强等于 10 === "10" 1234567var ageageundefinedtypeof age"undefined" 对象(Object) JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…此外，JavaScript 允许自定义对象。 JavaScript 提供多个内建对象，比如 String、Date、Array 等等。 对象只是带有属性和方法的特殊数据类型。 数组: 数组对象的作用是：使用单独的变量名来存储一系列的值。类似于Python中的列表。 12var l1 = ['a','b','c','d','e']console.log(l1[1]) 常用方法: 遍历数组中的元素: 12345678for (var i=0;i&lt;l1.length;i++)&#123; console.log(i)&#125;01234 字典对象: 1234567891011var person = &#123; name : 'leo', age : 18&#125;;undefinedperson.name"leo"person.age18person&#123;name: "leo", age: 18&#125; 运算符算数运算符+ - * / % ++ -- 比较运算符&gt; &gt;= &lt; &lt;= != == === !== 12345678910111213141510 == '10'true ### 弱等于10 === '10'false ### 强等于,既判断类型又判断值 ,一般使用强等于null == undefinedtruenull === undefinedfalsetypeof null"object"typeof undefined"undefined" 逻辑运算符&amp;&amp; || !1与and 或or 非! 赋值运算符= += -= *= /=1234567var n = 1n = 22n += 24n -= 13 流程控制if-else if-else12345678var a = 5;if (a &gt; 5)&#123; console.log(" a &gt; 5");&#125;else if (a &lt; 5)&#123; console.log(" a &lt; 5");&#125;else&#123; console.log(" a = 5");&#125; switch1234567891011121314// 获取今天周几var day = new Date().getDay();switch (day)&#123; case 0: console.log("Sunday"); break; case 1: console.log("Monday"); break;default: console.log("...")&#125;Monday switch中的case子句通常都会加break语句，否则程序会继续执行后续case中的语句。 for1234567891011var l1 = [1,2,'leo']for (var i = 0;i &lt; l1.length;i++)&#123; console.log(i) // 索引 console.log(l1[i]) // 值&#125;01122leo while123456// 循环要有一个准确的终止条件var age = 10;while (age &lt; 18)&#123; console.log("可以进入"); age += 1&#125; 三元运算123456### pythona = 10b = 5c = a if a &gt; b else bprint(c)10 123456// jsvar a = 10;var b = 20;var c = a &gt; b ? a:b// 问号 ？ 前面是条件，后面是取值,成立取a，不成立取b(冒号后面的值) 函数函数定义123456789// 普通函数 带参函数function func(a,b) &#123; console.log(a); console.log(b); return a + b // 返回值&#125;ret = func(10,20) // 函数执行 接收返回值console.log('a + b = ' + ret) 123456789// 匿名函数 没有函数名,存在变量里var func2 = function (a,b) &#123; console.log(a); console.log(b); return a + b&#125;ret = func2(10,20)console.log('a + b = ' + ret) 123456789101112131415// 参数个数function func(a,b) &#123; console.log(a); console.log(b); return a + b&#125;// ret = func(10,20,30)// 多一个参数传进来 并不会报错 继续执行ret = func(10)// 少一个参数传进来 b = undefined , a + b = NaN// 也就是说b被声明了，但是没有赋值,相加的结果是NANconsole.log('a + b = ' + ret) 12345// 立即执行函数(function (a,b) &#123; console.log('立即执行函数') console.log(a+b)&#125;)(10,20); arguments 参数12345678910111213141516171819// arguments参数 有点像 python中的args 他可以用来接收多个参数// arguments 找到所有传进的参数 == *argsfunction func(a,b) &#123; console.log(arguments); console.log('参数个数:' + arguments.length); var ret = 0; for (var i = 0;i&lt;arguments.length;i++)&#123; ret += arguments[i] &#125; return ret // 3个参数相加之和&#125;ret = func(10,20,30)console.log(ret)// Arguments(3) [10, 20, 30, callee: ƒ, Symbol(Symbol.iterator): ƒ]// 参数个数:3// 60 函数的全局变量和局部变量 局部变量：121. 在JavaScript函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它（该变量的作用域是函数内部）。2. 只要函数运行完毕，本地变量就会被删除。 全局变量：11. 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 变量生存周期：1231. JavaScript变量的生命期从它们被声明的时间开始。2. 局部变量会在函数运行以后被删除。3. 全局变量会在页面关闭后被删除。 作用域 变量的查找顺序: 121. 函数的调用，要往回找，找到函数的定义阶段2. 变量首先在 函数的内部找 -&gt; 内部找不到就往外找 -&gt; 直到找到全局为止，全局都没有就是undefined。 12345678910var city = "BeiJing";function f() &#123; var city = "ShangHai"; function inner()&#123; var city = "ShenZhen"; console.log(city); &#125; inner();&#125;f(); //输出结果是？ ShenZhen 12345678910var city = "BeiJing";function Bar() &#123; console.log(city);&#125;function f() &#123; var city = "ShangHai"; return Bar;&#125;var ret = f();ret(); // 打印结果是？ BeiJing 1234567891011// 闭包var city = "BeiJing";function f()&#123; var city = "ShangHai"; function inner()&#123; console.log(city); &#125; return inner;&#125;var ret = f();ret(); // ShangHai 词法分析（尝试理解）123451.分析(函数内部变量的定义过程) 1.先看参数 2.看有没有局部变量 3.看有没有函数定义2.执行(实际执行代码) JavaScript中在调用函数的那一瞬间，会先进行词法分析。 当函数 调用 的前一瞬间，会先形成一个激活对象：Avtive Object（AO），并会分析以下3个方面： 1231:函数参数，如果有，则将此参数赋值给AO，且值为undefined。如果没有，则不做任何操作。2:函数局部变量，如果AO上有同名的值，则不做任何操作。如果没有，则将此变量赋值给AO，并且值为undefined。3:函数声明，如果AO上有，则会将AO上的对象覆盖。如果没有，则不做任何操作。 函数内部无论是使用参数还是使用局部变量都到AO上找。1234567891011121314var age = 18;function foo()&#123; console.log(age); var age = 22; console.log(age);&#125;foo(); // 问：执行foo()之后的结果是？// 分析:// 1.函数没有参数// 2.有局部变量 age 那么 ao.age = undefined// 3.有变量赋值 age = 22// 第一个age = undefined // 第二个age = 22 123456789101112131415161718192021var age = 18;function foo()&#123; console.log(age); var age = 22; console.log(age); function age()&#123; console.log("呵呵"); &#125; console.log(age);&#125;foo(); // 执行后的结果是？// 分析:// 1 没有参数// 2.age = undefined// 3.age = 22// 4.function age = ao.age = function age()...// 1. function age()...// 2. 22 // 3 .22 同理第三个输出的还是22, 因为中间再没有改变age值的语句了 内置对象和方法对象的属性 JavaScript中的所有事物都是对象：字符串、数字、数组、日期，等等。 123456789// 字符串对象创建// var 变量 = “字符串”// var 字串对象名称 = new String (字符串)var name1 = "leo"var name2 = new String("Leo")typeof name1"string"typeof name2"object" 1234567// 数组对象创建var l1 = [1,2,3]var l2 = new Array(1,2,3)l1(3) [1, 2, 3]l2(3) [1, 2, 3] 123456789101112// 数字类型对象创建var n1 = 28n128var n2 = new Number(30)n2Number &#123;30&#125;typeof n1"number"typeof n2"object" 自定义对象123456789101112131415161718192021// 第一种方法 直接创建// 自定义对象var person = &#123; "name":"leo", "age":28&#125;console.log(person)console.log(typeof person)console.log(person.name)console.log(person.age)// 循环遍历对象属性for (var i in person)&#123; console.log(i) // 键 console.log(person[i]) // 值&#125;// 注意:// 1. 键不用加引号,加上也不出错 &#123;name:"leo",age:28&#125;// 2. 值如果是字符串，必须写双引号 12345678// 第二种方法 new 关键字创建var person = new Object()person.name = "leo"person.age = 28person.city = "北京"console.log(person.name + person.age)var index3 = 'city' // 刚巧我有一个变量的值是对象里面的键console.log(person[index3]) // 变量取值 内置对象Date对象 内置对象相当于python当中的内置模块 1234567// 创建Date对象// Date对象var d1 = new Date();console.log(d1); // Tue Jun 11 2019 18:04:34 GMT+0800 (中国标准时间)console.log(typeof d1); // objectconsole.log(d1.toLocaleString()); // 2019/6/11 下午6:04:34 字符串时间console.log(typeof d1.toLocaleString()); // string 1234567// 生成指定时间的date对象var d2 = new Date("2019/06/11 18:10");var d3 = new Date("2019-06-11 18:10");var d4 = new Date("2019/06/11 18:10");console.log(d2.toLocaleString()); // 转成字符串格式的 本地时间 2019/6/11 下午6:10:00console.log(d3.toLocaleString()); // 2019/6/11 下午6:10:00console.log(d4.toUTCString()); // Tue, 11 Jun 2019 10:10:00 GMT UTC时间 1234567891011// Date对象的方法var d = new Date();console.log(d.getDate()); //获取日console.log(d.getDay ()); //获取星期console.log(d.getMonth ()); //获取月（0-11）console.log(d.getFullYear ()); //获取完整年份console.log(d.getHours ()); //获取小时console.log(d.getMinutes ()); //获取分钟console.log(d.getSeconds ()); //获取秒console.log(d.getMilliseconds ()); //获取毫秒console.log(d.getTime ()); //返回累计毫秒数(从1970/1/1午夜) 123456789101112131415161718192021222324// 编写代码，将当前日期按“2017-12-27 11:11 星期三”格式输出。var weekday = &#123; "0":"星期日", "1":"星期一", "2":"星期二", "3":"星期三", "4":"星期四", "5":"星期五", "6":"星期六"&#125;function get_day() &#123; var d = new Date() var year = d.getFullYear() var month = d.getMonth()+1; // 月份是0-11 所以加1 var day = d.getDay(); var h = d.getHours(); var m = d.getMinutes() &lt; 10 ? "0" + d.getMinutes():d.getMinutes(); // 三元运算 如果分钟&lt;10 在前面加个0 var week_day = weekday[d.getDay()] var strTime = `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;h&#125;:$&#123;m&#125; $&#123;week_day&#125;`; console.log(strTime)&#125;get_day() JSON对象12345678910// 字符串转成对象var person = '&#123;"name":"leo","age":28&#125;' // 字符串var json_s = JSON.parse(person)console.log(json_s)console.log(typeof json_s) // object// 对象转换成字符串var ob_s = JSON.stringify(json_s)console.log(ob_s)console.log(typeof ob_s) // string Math对象 同样Math用于数据科学计算 123456789101112abs(x); //返回数的绝对值。exp(x); //返回 e 的指数。floor(x); //对数进行下舍入。log(x); //返回数的自然对数（底为e）。max(x,y); //返回 x 和 y 中的最高值。min(x,y); //返回 x 和 y 中的最低值。pow(x,y); //返回 x 的 y 次幂。random(); //返回 0 ~ 1 之间的随机数。round(x); //把数四舍五入为最接近的整数。sin(x); //返回数的正弦。sqrt(x); //返回数的平方根。tan(x); //返回角的正切。 12var n = -100console.log(Math.abs(n)) RegExp对象12345678910111213141516// 创建正则对象方式1// 参数1 正则表达式(不能有空格)// 参数2 匹配模式：常用g(全局匹配;找到所有匹配，而不是在第一个匹配后停止)和i(忽略大小写)// 例子:用户名,只能是英文字母、数字和_，并且首字母必须是英文字母。长度最短不能少于6位 最长不能超过12位。// ^[a-zA-Z][a-zA-Z0-9_]&#123;5,12&#125;// 创建RegExp对象方式（逗号后面不要加空格）var reg1 = new RegExp("^[a-zA-Z][a-zA-Z0-9_]&#123;5,12&#125;$");var str1 = "abcde" // 待匹配字符串: 5位字符组成var str2 = "abcdef" // 待匹配字符串: 6位字符组成var str3 = "1abcdef" // 待匹配字符串: 7位字符组成,数字开头//RegExp对象的test方法，测试一个字符串是否符合对应的正则规则，返回值是true或false。console.log(reg1.test(str1)) // false 开头占1位，后面如果是4个字符，满足不了 &#123;5，12&#125;console.log(reg1.test(str2)) // true 1+5console.log(reg1.test(str3)) // false 不能数字开头 1234567// 第二种写法 /正则/// 创建方式2// /填写正则表达式/匹配模式（逗号后面不要加空格）=var reg2 = /^[a-zA-Z][a-zA-Z0-9_]&#123;5,12&#125;$/;var str2 = 'abcdef'console.log(reg2.test(str2)) 1234567// String对象与正则结合的4个方法var s2 = "hello world";s2.match(/o/g); // ["o", "o"] 查找字符串中 符合正则 的内容s2.search(/h/g); // 0 查找字符串中符合正则表达式的内容位置s2.split(/o/g); // ["hell", " w", "rld"] 按照正则表达式对字符串进行切割s2.replace(/o/g, "s"); // "hells wsrld" 对字符串按照正则进行替换 1234// 坑1console.log("==============================================================")// 正则表达式之间 不能有空格 &#123;5, 11&#125; 要不然就被崩//console.log(/^[a-zA-Z][a-zA-Z0-9]&#123;5, 11&#125;$/.test('xiaoqiang')) 12345678// 坑2// test 不传值 相当于传了一个 undefined// test() 就把undefined 当成是 "undefined" 来判断console.log("==============================================================")console.log(/^[a-zA-Z][a-zA-Z0-9]&#123;5,11&#125;$/.test())console.log(/^[0-9a-zA-Z][a-zA-Z0-9]&#123;5,11&#125;$/.test())console.log(/^[0-9a-zA-Z][a-zA-Z0-9]&#123;5,11&#125;$/.test(undefined))console.log(/^[0-9][a-zA-Z0-9]&#123;5,11&#125;$/.test()) 123456789101112131415161718192021222324252627// 字符串替换 不是改变原来的字符串,需要生成新的字符串var ss = 'Leo'var s3 = ss.replace("o","x")console.log(s3)// 正则 全部替换g 忽略大小写i// JS正则的两种模式:// 1. g 表示全局// 2. i 忽略大小写var ss = 'AbAcad'var s4 = ss.replace(/A/gi,"哈哈哈")console.log(s4)// 坑3// 当正则表达式使用了全局模式(g)时,并且你还让他去检测一个字符串// 此时会引出 lastIndex 记录上次匹配成功位置,并把下一次要开始效验的位置记住// 所以一般不要设置全局// a开头后面2-4位字符// console.log(/^a[a-zA-Z]&#123;2,4&#125;$/g.test("alex"))// console.log(/^a[a-zA-Z]&#123;2,4&#125;$/g.test("alex"))var r = /alex/g;console.log(r.test("alex")) // tureconsole.log(r.lastIndex) // 4console.log(r.test("alex")) // false 从头开始console.log(r.lastIndex) // 0]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F05%2F20%2Fweb-css%2F</url>
    <content type="text"><![CDATA[CSS 介绍 CSS（Cascading Style Sheet，层叠样式表)定义如何显示HTML元素。 当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化（渲染）。 HTML定义了页面的框架，CSS样式表用来装饰页面。 思维导图: https://www.processon.com/mindmap/5a2f4ec4e4b0abb143af4a08 CSS 语法 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 声明又包括属性和属性值。每个声明之后用分号结束。 选择器 {样式1;样式2} h1 {color:red; font-size:14px;} CSS引入方式行内样式 行内式是在标记的style属性中设定CSS样式,不推荐大规模使用。 1&lt;p style="color: blue"&gt;杰尼龟&lt;/p&gt; 内部样式 嵌入式是将CSS样式集中写在网页的&lt;head&gt;&lt;/head&gt;标签对的&lt;style&gt;&lt;/style&gt;标签对中。格式如下： 12345678910&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;style&gt; p &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt; 外部样式(推荐) 外部样式就是将css写在一个单独的文件中，然后在页面进行引入即可。推荐使用此方式。 123456789### link语句在&lt;head&gt;&lt;/head&gt;&gt;下使用&lt;link rel="stylesheet" href="index.css"&gt;### index.css/* 标签选择器 */p &#123; color: red; font-size: 48px;&#125; CSS 选择器 CSS选择器的作用: 查找标签 基本选择器 标签选择器123/* 标签选择器 *//*适用于：批量、统一、默认的样式*/p &#123; color: red;&#125; ID选择器123/* ID选择器 # *//*适用于：给特定标签设置特定样式*/#p2 &#123;color: blue;&#125; 类选择器123/* 类选择器 . *//*适用于：给某一些标签摄者相同的样式*/.c1 &#123;color: yellow;&#125; 123# 注意:# 样式类名不要用数字开头（有的浏览器不认）。# 标签中的class属性如果有多个，要用空格分隔。 通用选择器 通配选择器 * 会找到body里面所有的标签，包括body标签，所以页面整体都会被找到 12/* 类选择器 */* &#123;color: pink;&#125; 组合选择器后代选择器 空格分割 1234/* d1下的所有p标签被找到 */#d1 p &#123; color: red;&#125; 子代选择器 &gt; 只找儿子 1234/* id是d1标签 所有儿子是p标签 */#d1&gt;p&#123; color: green;&#125; 毗邻选择器 + 找紧挨着的兄弟标签 只往下找 1234/* 选择所有紧接着div元素之后的p标签 */div+p&#123; color: yellow;&#125; 弟弟选择器 只要是兄弟标签1234/* div后面的所有的p标签 */div~p&#123; color: blue;&#125; 分组和嵌套分组 当多个元素的样式相同的时候，我们没有必要重复地为每个元素都设置样式，可以通过在多个选择器之间使用逗号分隔的分组选择器来统一设置元素样式。 , 代表 或 123div, p&#123; color: red;&#125; 上面的代码为div标签和p标签统一设置字体为红色。通常，我们会分两行来写，更清晰,但是别忘记加上逗号: 1234div, p&#123; color: red;&#125; 嵌套 多种选择器可以混合起来使用，比如：.d1类内部所有p标签设置字体颜色为红色。 . 代表 且 123.c1 p &#123; color: red;&#125; 找一个class = d1 的span标签 123span.d1&#123; color: pink;&#125; 属性选择器123&lt;p cid="leo"&gt;我是一个P标签&lt;/p&gt;&lt;p cid="lex"&gt;我也是一个P标签&lt;/p&gt;&lt;p&gt;我还是一个P标签&lt;/p&gt; 用于选取带有指定属性的元素 123[cid]&#123; color: pink;&#125; 用于选取带有指定属性和值的元素 123[cid='lex']&#123; color: green;&#125; 伪类选择器 a：link（从未访问过的链接的崭新状态），用于定义了链接的常规状态。 a:hover（鼠标移动到链接上时未点击的悬浮状态），用于产生视觉效果。 a:visited（已访问过的链接的状态）用于阅读文章，能清楚的判断已经访问过的链接。 a:active（在链接上按下鼠标时的状态），用于表现鼠标按下时的链接激活状态。 123456789101112131415161718192021222324252627282930/* 所有没有访问过的a标签 */a:link &#123; color: deeppink;&#125;/* 所有访问过的a标签 */a:visited &#123; color: green;&#125;/* 鼠标移上去 变色 */a:hover &#123; color: blueviolet;&#125;#d1:hover &#123; color: darksalmon;&#125;/* 被选定 鼠标按下去变色 */a:active&#123; color: deeppink;&#125;/*input获取光标时*/input:focus&#123; outline: 0; background-color: deeppink;&#125; 伪元素选择器1234567891011121314151617/*常用的给首字母设置特殊样式：*/p:first-letter&#123; font-size: 48px; color: deeppink;&#125;/*在标签内容开头操作*/.p1:before&#123; content: "*"; color: red;&#125;/*在标签内容最后操作*/.p1:after&#123; content: "[?]"; color: blue;&#125; 选择器优先级 所谓CSS优先级，即是指CSS样式在浏览器中被解析的先后顺序。 1.内联样式表的权值最高 嵌套引入 style=”” －－－ 1000 2.统计选择符中的ID属性个数。 #id －－－ 100 3.统计选择符中的CLASS属性个数。 .class －－－ 10 4.统计选择符中的HTML标签名个数。 p －－－ 1 5.选择器都一样的情况下，谁靠近标签，谁的优先级高 6.万不得已可以使用!important CSS 常用属性宽和高 width 属性可以为元素设置宽度。 height 属性可以为元素设置高度。 只有块级标签才能设置宽和高，内联标签的宽度由内容的长度来决定 1234.d1 &#123; width: 300px; height: 200px;&#125; 字体属性文字字体 font-family 可以把多个字体名称作为一个“回退”系统来保存。 如果浏览器不支持第一个字体，则会尝试下一个。 浏览器会使用它可识别的第一个值。 1234/*全局样式*/*&#123; font-family: "幼圆","Microsoft YaHei" ,"Arial";&#125; 字体大小123.d1 &#123; font-size: 32px;&#125; 字重（粗细）123.d1 &#123; font-weight: bold;&#125; 文本颜色 颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 还有rgba(255,0,0,0.3)，第四个值为alpha, 指定了色彩的透明度/不透明度，它的范围为0.0到1.0之间。 可以通过浏览器工具获取颜色的十六进制值,然后用到自己的样式中 12345.d1 &#123; color: deeppink; /*color: #FF1493;*/ /*color: rgba(255,0,0,0.3);*/&#125; 文字对齐 text-align 属性规定元素中的文本的水平对齐方式。 123.p1&#123; text-align: justify;&#125; 文字装饰 text-decoration 属性用来给文字添加特殊效果。 常用方法: 1234/* 去掉a标签默认的自划线：*/a&#123; text-decoration: none;&#125; 首行缩进 首行缩进 字体像素的两倍就相当于是首行缩进两个字: 12345.p1&#123; font-size: 32px; text-indent: 32px;&#125; 文本其它属性 font-style: oblique; 斜体 letter-spacing: 10px; 字母间距 word-spacing: 20px; 单词间距 text-transform: capitalize/uppercase/lowercase ; 文本转换，用于所有字句变成大写或小写字母，或每个单词的首字母大写 line-height: 200px; 文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比 vertical-align:－4px 设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效 背景属性背景颜色123.d1&#123; background-color: deeppink;&#125; 背景图片 设置背景图片如:200 X 200像素 如果设置的div层宽和高 与图片的像素一致，则直接铺满 如果设置的div层宽和高 大于图片的像素 如 600 X 600 ，如下图，就要进行背景调整12345.d1&#123; width: 600px; height: 600px; background-image: url("xiaoxin.jpg");&#125; 背景重复 repeat(默认):背景图片平铺排满整个网页 repeat-x：背景图片只在水平方向上平铺 repeat-y：背景图片只在垂直方向上平铺 no-repeat：背景图片不平铺 1234567.d1&#123; width: 600px; height: 600px; background-image: url("xiaoxin.jpg"); /*图片超出后不重复(平铺)*/ background-repeat: no-repeat;&#125; 调整背景位置 1234567891011.d1&#123; width: 600px; height: 600px; background-image: url("xiaoxin.jpg"); /*图片超出后不重复(平铺)*/ background-repeat: no-repeat; /*background-position: center;*/ background-position: center; /*x轴 -&gt; 200，y轴100*/ /*background-position: 200px 100px;*/&#125; 支持简写：background:#ffffff url(&#39;1.png&#39;) no-repeat right top; 使用背景图片的一个常见案例就是很多网站会把很多小图标放在一张图片上，然后根据位置去显示图片。减少频繁的图片请求。http://www.w3school.com.cn/css/css_background.asp 鼠标滚动背景不动 123&lt;div class="c1"&gt;&lt;/div&gt;&lt;div class="c2"&gt;&lt;/div&gt;&lt;div class="c3"&gt;&lt;/div&gt; 123456789101112131415.c1&#123; height: 500px; background-color: red;&#125;.c2&#123; height: 500px; background: url("CSS 属性/img23.jpg") no-repeat center; background-attachment: fixed;&#125;.c3&#123; height: 500px; background-color: green;&#125; 边框属性设置边框 border-width 粗细 border-style 样式 border-color 颜色 12345678.d1&#123; height: 200px; width: 300px; background-color: deeppink; border-width: 5px; border-style: solid; background-color: green;&#125; 12345/*通常使用简写方式：*/.d1&#123; border: 5px solid green;&#125; 除了可以统一设置边框外还可以单独为某一个边框设置样式，如下所示： 1234567.d1&#123; border-top-style:dotted; border-top-color: red; border-right-style:solid; border-bottom-style:dotted; border-left-style:none;&#125; 圆角边框123456.d1&#123; height: 200px; width: 200px; border-radius: 100px 100px; background-color: deeppink;&#125; 列表属性12341、list-style-type 设置列表项标志的类型。2、list-style-image 将图象设置为列表项标志。3、list-style-position 设置列表中列表项标志的位置。4、list-style 简写属性。用于把所有用于列表的属性设置于一个声明中 1234/*使用图像来替换列表项的标记:*/ul &#123; list-style-image: url('图片');&#125; display 属性 用于控制HTML元素的显示效果。 none(隐藏某标签) display: none 与 visibility: hidden的区别 visibility:hidden: 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 display:none: 可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 display: none不占位，visibility: hidden占位 12345.d1&#123; height: 100px; color: red; display: none; /*visibility: hidden;*/ block (内联标签设置为块级标签)1234.s1&#123; display: block; background-color: green;&#125; inline(块级标签设置为内联标签)123456&lt;ul class="u1"&gt; &lt;li&gt;&lt;a href=""&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;体育&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;娱乐&lt;/a&gt;&lt;/li&gt; &lt;li class="last"&gt;&lt;a href=""&gt;天气&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213li&#123; display: inline; border-right: 1px solid black; padding: 1px 10px;&#125;li a&#123; text-decoration: none;&#125;li.last&#123; border-right: none;&#125; inline-block display:inline-block可做列表布局，其中的类似于图片间的间隙小bug可以通过如下设置解决： 1234#outer&#123; border: 3px dashed; word-spacing: -5px;&#125; CSS 盒子模型 margin: 用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。 padding: 用于控制内容与边框之间的距离； Border(边框): 围绕在内边距和内容外的边框。 Content(内容): 盒子的内容，显示文本和图像。 margin 外边距12345678910111213141516.d1&#123; height: 300px; width: 300px; background-color: deeppink; /*margin-top:10px;*/ /*margin-right:20px;*/ /*margin-bottom:10px;*/ /*margin-left:20px;*/ /*顺序：上右下左*/ margin: 10px 20px 10px 20px; /*常见居中*/ margin: 0 auto;&#125; 123456789101112131415161718### 简写属性margin:10px 20px 20px 10px； 上边距为10px 右边距为20px 下边距为20px 左边距为10pxmargin:10px 20px 10px; 上边距为10px 左右边距为20px 下边距为10pxmargin:10px 20px; 上下边距为10px 左右边距为20pxmargin:25px; 所有的4个边距都是25px padding内填充123456.padding-test &#123; padding-top: 5px; padding-right: 10px; padding-bottom: 15px; padding-left: 20px;&#125; 123.padding-test &#123; padding: 5px 10px 15px 20px;&#125; 123456顺序：上右下左补充padding的常用简写方式：1、提供一个，用于四边；2、提供两个，第一个用于上－下，第二个用于左－右；3、如果提供三个，第一个用于上，第二个用于左－右，第三个用于下；4、提供四个参数值，将按上－右－下－左的顺序作用于四边； 12345678.d1&#123; height: 200px; width: 300px; background-color: deeppink; margin: 20px 30px; padding: 20px 30px; border: 10px solid black;&#125; body标签的外边距 有时候div的宽度我们设置为100%,依然发现不能占满整个页面的宽度，这是由于body存在8px的外边距(不同的浏览器分辨率有所区别可能), 通用初始化,浏览器不设置外边距,解决屏幕铺满问题 1234*&#123; margin: 0; padding: 0;&#125; float 浮动 浮动:div 配合 float浮动 来做 页面的布局 在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 关于浮动的两个特点： 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 浮动标签 left：向左浮动 right：向右浮动 none：默认值，不浮动 123456789101112131415161718*&#123; margin: 0; padding: 0;&#125;.d1&#123; height: 600px; width: 20%; background-color: red; float: left;&#125;.d2&#123; height: 600px; width: 80%; background-color: green; float: left;&#125; 12345a&#123; /*内联标签设置float就会变成块级标签，可以设置长和宽*/ width: 1000px; float: left;&#125; clear 清除浮动 重要，主要解决清除浮动的副作用（父标签塌陷问题） clear属性规定元素的哪一侧不允许其他浮动元素。 出现塌陷演示1234&lt;div id="d0"&gt; &lt;div class="d1"&gt;c1&lt;/div&gt; &lt;div class="d2"&gt;c2&lt;/div&gt;&lt;/div&gt; 12345678910111213141516*&#123; margin: 0; padding: 0;&#125;#d0&#123; border: 1px solid black;&#125;.d1,.d2&#123; /*如果父标签没有高度，float浮动会脱离父标签;*/ float: left; height: 100px; width: 100px;&#125; 标签塌陷：浮动的标签脱离文档流，不在原来的位置，通过清除浮动即左边不能有标签，在浮动标签下撑起整个父标签 为什么父标签没有高度,因为父标签里没有内容 1、因为里面儿子的div 都是浮动的 不能撑起父标签 2、浮动元素 脱离文档流，不在原来的位置上 3、在父标签的最后增加一个没有高度的设置，撑起整个父标签。 伪元素 撑起父标签12345678910#d0:after&#123; /*伪元素，在父标签上内部的最后,增加一个空内容,他的左边不能有浮动*/ /*父标签就会被撑起来*/ /*不浮动的元素在浮动元素的下面*/ content: ""; clear: left; display: block; /*左右都不能有浮动元素*/ /*clear: both;*/&#125; 业界通用版123456789&lt;div id="d1" class="clearfix"&gt; &lt;div class="d2"&gt;&lt;/div&gt; &lt;div class="d2"&gt;&lt;/div&gt; &lt;div class="d2"&gt;&lt;/div&gt; &lt;div class="d2"&gt;&lt;/div&gt; &lt;!--&lt;div class="d3"&gt;&lt;/div&gt;--&gt;&lt;/div&gt;&lt;div class="d4"&gt;我是正常的内容块&lt;/div&gt; 12345678910111213141516171819202122232425262728293031*&#123; margin: 0; padding: 0;&#125;#d1&#123; /*父div没有高度*/ border: 1px solid black;&#125;.d2&#123; height: 50px; width: 50px; background-color: blue; border: 1px solid red; /*display: inline;*/ /*向左浮动left*/ float: left;&#125;.d4&#123; height: 200px; background-color: darkgreen;&#125;/*业界规定清除浮动类*/.clearfix:after&#123; content: ""; clear: both; display: block;&#125; overflow 溢出属性 12345678&lt;div class="d1"&gt; 国安国安北京国安 国安国安北京国安 国安国安北京国安 国安国安北京国安国安国安北京国安 国安国安北京国安国安国安北京国安国安国安北京国安国安国安北京国安国安国安北京国安国安国安北京国安 国安国安北京国安国安国安北京国安&lt;/div&gt; 123456789.d1&#123; width: 120px; height: 120px; border: 1px solid red; /*给溢出的内容一个滚动条*/ overflow: auto; /*超出的隐藏*/ /*overflow: hidden;*/&#125; 制作圆形头像123&lt;div class="header-img"&gt; &lt;img src="xiaoxin.jpg"&gt;&lt;/div&gt; 123456789101112.header-img&#123; height: 120px; width: 120px; border: 2px solid antiquewhite; border-radius: 100%; /*内容溢出隐藏*/ overflow: hidden;&#125;img&#123; /*max直到父标签的100%*/ max-height: 100px;&#125; position 定位 static:默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。 relative:相对定位相对于原来的位置来说 绝对定位相对于最近的一个被定位过的祖宗标签，一直没有就是body,默认来说走左上角 relative 相对定位 相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。 注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。 12345678910111213141516171819202122232425262728*&#123; margin: 0; padding: 0;&#125;.c1,.c2,.c3&#123; height: 150px; width: 150px;&#125;.c1&#123; background-color: red;&#125;.c2&#123; background-color: green; /*相对定位，相对的是原来在的位置*/ /*左边0,上面是c1的高*/ position: relative; left: 400px; top: 150px;&#125;.c3&#123; background-color: blue;&#125; 123&lt;div class="c1"&gt;&lt;/div&gt;&lt;div class="c2"&gt;&lt;/div&gt;&lt;div class="c3"&gt;&lt;/div&gt; absolute 绝对定位 定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。 父节点没有定位 12345&lt;!-- 绝对定位，父节点没有定位，所有对照body --&gt;&lt;div class="c1"&gt;&lt;/div&gt;&lt;div class="c2"&gt;&lt;/div&gt;&lt;div class="c3"&gt;&lt;/div&gt;&lt;div class="c4"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536*&#123; margin: 0; padding: 0;&#125;.c1,.c2,.c3,.c4&#123; height: 150px; width: 150px;&#125;.c1&#123; background-color: red;&#125;.c2&#123; background-color: green; /*相对定位，相对的是原来在的位置*/ /*左边0,上面是c1的高*/ position: relative; left: 400px; top: 150px;&#125;.c3&#123; background-color: blue;&#125;.c4&#123; background-color: deeppink; position: absolute; top: 150px; left: 400px;&#125; 父节点有定位 12345678&lt;!-- 绝对定位，父节点有定位，对照父节点 --&gt;&lt;!-- 加了一父节点div class=c4-father --&gt;&lt;div class="c1"&gt;&lt;/div&gt;&lt;div class="c2"&gt;&lt;/div&gt;&lt;div class="c3"&gt;&lt;/div&gt;&lt;div class="c4-father"&gt; &lt;div class="c4"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243*&#123; margin: 0; padding: 0;&#125;.c1,.c2,.c3,.c4,.c4-father&#123; height: 150px; width: 150px;&#125;.c1&#123; background-color: red;&#125;.c2&#123; background-color: green; /*相对定位，相对的是原来在的位置*/ /*左边0,上面是c1的高*/ position: relative; left: 400px; top: 150px;&#125;.c3&#123; background-color: blue;&#125;.c4&#123; background-color: deeppink; position: absolute; top: 150px; left: 400px;&#125;.c4-father&#123; position: relative; left: 150px; background-color: darkgoldenrod;&#125; fixed固定 经常用于返回顶部按钮 图片制作 输入网址 图片大小 背景颜色 文字颜色 格式 最后文字内容https://dummyimage.com/600X400/695151/fff.png&amp;text=leo CSS 知识补充小米导航条123456789101112131415161718192021222324252627282930313233343536373839404142*&#123; margin: 0; padding: 0;&#125;ul&#123; list-style-type: none;&#125;.nav-left li&#123; float: left; color: white; padding: 10px;&#125;.nav-right&#123; float: right; padding: 10px;&#125;.nav&#123; background-color: black; padding: 5px 0;&#125;/*清理左右两边浮动*/.clearfix:after&#123; content: ""; display: block; clear: both;&#125;.oa&#123; width: 80%; margin: 0 auto;&#125;a&#123; color: white; text-decoration: none;&#125; 123456789101112131415161718192021&lt;div class="nav "&gt; &lt;div class="oa clearfix"&gt; &lt;div class="nav-left"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;玉米商城&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;大米&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;小米&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;苹果&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;香蕉&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;橘子&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;西瓜&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;荔枝&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="nav-right"&gt; &lt;a href=""&gt;登录&lt;/a&gt; &lt;a href=""&gt;注册&lt;/a&gt; &lt;a href=""&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 脱离文档流 脱离文档流的3种方式 浮动 float 绝对定位 position: absolute 固定定位 position: fixed 123&lt;div class="d1"&gt;&lt;/div&gt;&lt;div class="d2"&gt;&lt;/div&gt;&lt;div class="d3"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839*&#123; margin: 0; padding: 0;&#125;.d1&#123; height: 100px; width: 100px; background-color: deeppink;&#125;.d2&#123; height: 150px; width: 150px; background-color: green; /*脱离文档流 让绿色的框脱离文档原来的位置 */ /*浮动*/ /*float: right;*/ /*相对定位: 标签还占有原来的位置*/ /*position: relative;*/ /*left: 400px;*/ /*绝对定位: 没有就找左上角 蓝色框会顶上来,绿色的框脱离了原来的位置 ，脱离了文档流*/ /*position: absolute;*/ /*left: 400px;*/ /*fixed 固定 蓝色也顶上来，绿色失去了原来的位置，脱离文档流 */ position: fixed; right: 100px; top: 100px;&#125;.d3&#123; height: 200px; width: 200px; background-color: blue;&#125; 内容知识点总结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101.伪类和伪元素 1.伪类 1.:link 2.:visited 3.:hover(重要) 4.:active 5.:focus(input标签获取光标焦点) 2.伪元素 1. :first-letter 2. :before(重要 在内容前面添加) 3. :after(重要 在内容后面添加)2.CSS属性 1.字体： 1. font-family 2. font-size 3. font-weight 2.文本: 1. text-align 对齐 2. text-decoration 装饰(去除a标签的下划线) 3. text-indent 首行缩进 3.背景 1. background-color 颜色 2. background-image 图片 url() no-repeat 4.颜色 1. red 直接写名字 2. #FF0000 3. rgb(255,0,0) --&gt; rgba(255,0,0,0)透明度[0-1] 5.边框 1. border-width 宽度 2. border-style 样式 3. border-color 颜色 border 1px solid red; 6.CSS盒子模型 4个部分 1. content 内容的宽度和高度 2. padding 内填充 调整内容和边框的距离 3. border 边框 4. margin 外边距 调整两个标签之间的距离 (注意两个挨着的标签margin取最大值) 5. 注意：要习惯看浏览器console 窗口的那个盒子模型 7.display 标签的展示形式 1. inline 2. block 菜单里的a标签可以设置成block 3. inline-block 4. none 不显示隐藏，但是不占位 8.float 浮动 1.多用于布局效果 1. 顶部的导航条 2. 页面的左右分栏 blog页面 左边20% 右边80% 3. 任何标签都可以浮动，浮动之后都会变成块级标签（可以设置高和宽） 2.float取值: 1. left 2. right 3. none 默认 9.clear 清除浮动的副作用 （内容溢出，父标签撑不起来） 1. 结合伪元素实现 .clearfix:after&#123; content:"", display:"block", clear:both (左右都清除) &#125; 2.clear 取值: 1. left 2. right 3. both 10.overflow 1.标签的内容放不下(溢出) 2.取值: 1. hidden 隐藏 2. scroll 滚轮 3. inherit 继承父标签 4. auto 自动 5. scroll-x 6. scroll-y 例子: 圆形头像例子 1. overflow:hidden 2. border-radius: 50% 边框圆角 11.position 定位 1. static 默认 2. relative 相对定位 # 相对于原来的位置 3. absolute 绝对定位 # 相对于已经定位过的前辈标签 没有就是body 4.fixed 固定 返回顶部按钮实例 补充: 12.脱离文档流的3种方式 1 浮动 float 2 绝对定位 position: absolute 3 固定定位 position: fixed 13.opacity (不透明度) 1. 和agba的区别: 取值0~1 1是原有,0是全透明 opacity 能改变元素 子标签的透明度 比如背景色和文字 rgba 给谁写才能改变 14.z-index 1. 数值越大，越靠近你 2. 只能作用于 定位过的元素标签 3. 自定义模态框示例]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2019%2F05%2F15%2Fweb-base%2F</url>
    <content type="text"><![CDATA[HTML 介绍前端有哪些内容1234### 三大基础基础: HTML CSS JavaScript框架: Bootstrap JQuery功能: 内容 外观 动作 HTML 是什么 超文本标记语言（Hypertext Markup Language, HTML）是一种用于创建网页的标记语言。 本质上是浏览器可识别的规则，我们按照规则写网页，浏览器根据规则渲染我们的网页。对于不同的浏览器，对同一个标签可能会有不同的解释。（兼容性问题） 网页文件的扩展名：.html或.htm HTML是一种标记语言（markup language），它不是一种编程语言。 HTML使用标签来描述网页。 思维导图: https://www.processon.com/mindmap/5a2f4ec4e4b0abb143af4a08 Web服务的本质12345678### 浏览器输入网址 回车 都发生了什么# 1. 浏览器发请求 --&gt; HTTP协议# 2. 服务端接收请求 --&gt; 服务端返回响应# 3. 服务端把HTML文件内容发给浏览器# 4. 浏览器接收渲染页面# 5. 客户端与服务端 消息的格式是约定好的 ,这个约定就叫做 HTTP协议# 6. HTTP协议:浏览器和服务器之间约定好的消息格式 123456789101112131415161718192021222324# web serverimport socketsk = socket.socket()sk.bind(('127.0.0.1',8090))sk.listen()while 1: conn,addr = sk.accept() conn.recv(1024) # 收消息 conn.send(b'HTTP:/1.1 200 ok\r\n\r\n') # 按照HTTP协议的格式 发消息 # 直接发送 # conn.send(b'&lt;h1&gt;hello!&lt;/h1&gt;') # 从文件读取,按字节 with open("data.html",'rb') as f: msg = f.read() conn.send(msg) conn.close()sk.close()# 浏览器作为客户端访问: 127.0.0.1:8090 1234# data html&lt;h1&gt; hello leo &lt;/h1&gt;&lt;img src = "https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3054306616,2519291525&amp;fm=26&amp;gp=0.jpg"&gt;&lt;a href='http://www.sogo.com'&gt;sogo&lt;/a&gt; HTML 文档结构12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;css样式优先级&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; &lt;!DOCTYPE html&gt; 声明为HTML5文档。 &lt;html&gt;、&lt;/html&gt; 是文档的开始标记和结束的标记。是HTML页面的根元素，在它们之间是文档的头部（head）和主体（body）。 &lt;head&gt;、&lt;/head&gt; 定义了HTML文档的开头部分。它们之间的内容不会在浏览器的文档窗口显示。包含了文档的元（meta）数据。 &lt;title&gt;、&lt;/title&gt; 定义了网页标题，在浏览器标题栏显示。 &lt;body&gt;、&lt;/body&gt; 之间的文本是可见的网页主体内容。 HTML 标签HTML 标签格式之前我们学习到，HTML是一种标记语言(HTML,XML,YTAML),他的作用是使用标签来描述网页。 HTML标签是由尖括号包围的关键字，如&lt;html&gt;, &lt;div&gt;等 HTML标签通常是成对出现的，比如：&lt;div&gt;和&lt;/div&gt;，第一个标签是开始，第二个标签是结束。结束标签会有斜线。 也有一部分标签是单独呈现的，比如：&lt;br/&gt;、&lt;hr/&gt;、&lt;img src=&quot;1.jpg&quot; /&gt;等。 标签里面可以有若干属性，也可以不带属性。 标签的分类1 一般标签与自闭和标签 双标签(一般标签) &lt;h1&gt;&lt;/h1&gt; &lt;a&gt;&lt;/a&gt; 单标签(自闭和标签) &lt;img&gt; &lt;link&gt; 一般标签由于有开始符号和结束符号，可以在标签内部插入其他标签或文字； 自闭合标签由于没有结束符号，没办法在内部插入其他标签或文字，只能定义自身的一些属性。1234567891011121314### 常见的自闭合标签1、&lt;meta/&gt; 定义页面的说明信息，供搜索引擎查看。2、&lt;link/&gt; 用于连接外部的CSS文件或脚本文件。3、&lt;base/&gt; 定义页面所有链接的基础定位。4、&lt;br/&gt; 用于换行。5、&lt;hr/&gt; 水平线。6、&lt;input/&gt; 用于定义表单元素7、&lt;img/&gt; 图像标签。 标签的语法 &lt;标签名 属性1=“属性值1” 属性2=“属性值2”……&gt;内容部分&lt;/标签名&gt; &lt;标签名 属性1=“属性值1” 属性2=“属性值2”…… /&gt; 标签的属性任何标签都有三个常用属性: id：定义标签的唯一ID，HTML文档树中唯一 class：为html元素定义一个或多个类名（classname）(CSS样式类名) style：规定元素的行内样式（CSS样式） HTML注释1&lt;!--注释内容--&gt; HTML 常用标签head 常用标签 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!--定义网页标题--&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;!--定义内部样式表--&gt; &lt;style&gt; a &#123; color: red; &#125; &lt;/style&gt; &lt;!--引入外部样式表文件--&gt; &lt;link rel="stylesheet" href="test.css"&gt; &lt;!--定义JS代码或引入外部JS文件--&gt; &lt;script&gt; alert("hello") &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="head_demo.html"&gt;点我跳转&lt;/a&gt; &lt;h1&gt;大家好&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021### Meta标签介绍：&lt;meta&gt;元素可提供有关页面的元信息（mata-information）,针对搜索引擎和更新频度的描述和关键词。&lt;meta&gt;标签位于文档的头部，不包含任何内容。&lt;meta&gt;提供的信息是用户不可见的。meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 ### 1.http-equiv属性：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。&lt;!--2秒后跳转到对应的网址，注意引号--&gt;&lt;meta http-equiv="refresh" content="2;URL=https://www.oldboyedu.com"&gt;&lt;!--指定文档的编码类型--&gt;&lt;meta http-equiv="content-Type" charset=UTF8"&gt;&lt;!--告诉IE以最高级模式渲染文档--&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;### 2.name属性: 主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。&lt;meta name="keywords" content="meta总结,html meta,meta属性,meta跳转"&gt;&lt;meta name="description" content="老男孩教育Python学院"&gt; body 常用标签基本标签（块级标签和内联标签）1234567891011121314151617&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;s&gt;删除&lt;/s&gt;&lt;p&gt;段落标签&lt;/p&gt;&lt;h1&gt;标题1&lt;/h1&gt;&lt;h2&gt;标题2&lt;/h2&gt;&lt;h3&gt;标题3&lt;/h3&gt;&lt;h4&gt;标题4&lt;/h4&gt;&lt;h5&gt;标题5&lt;/h5&gt;&lt;h6&gt;标题6&lt;/h6&gt;&lt;!--换行--&gt;&lt;br&gt;&lt;!--水平线--&gt;&lt;hr&gt; 特殊字符 div 标签和span 标签 div标签用来定义一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。 span标签用来定义内联(行内)元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。 123456&lt;!--div 和 span div占用一行, span在同一行 --&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;span&gt;我是span&lt;/span&gt; 标签的分类2 块级标签与内联标签的区别根据长度分类: 块级标签: 默认占浏览器宽度,块级标签可以设置长和宽: 1h1 - h6、div、p、hr、 内联(行内)标签: 根据内容决定长度，不能设置长和宽: 1a、img、u、s、i、b、span 标签的嵌套规则: 行内标签不能嵌套块级标签 p标签不能包含块级标签，p标签也不能包含p标签。 图片 img 向网页中嵌入一幅图像 标签并不会在网页中插入图像，而是从网页上链接图像。 标签有两个必需的属性：src 属性 和 alt 属性。1&lt;img src="图片的路径" alt="图片未加载成功时的提示" title="鼠标悬浮时提示信息" width="宽" height="高(宽高两个属性只用一个会自动等比缩放)"&gt; 超链接 a 超链接标签 超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。 1&lt;a href="http://www.baidu.com" target="_blank" &gt;点我&lt;/a&gt; 1234567891011### 什么是URL？URL是统一资源定位器(Uniform Resource Locator)的缩写，也被称为网页地址，是因特网上标准的资源的地址。URL举例http://www.sohu.com/stu/intro.htmlURL地址由4部分组成第1部分：为协议：http://、ftp://...等 第2部分：为站点地址：可以是域名或IP地址第3部分：为页面在站点中的目录：stu第4部分：为页面名称，例如 index.html各部分之间用“/”符号隔开。 123456789### href 属性指定目标网页地址。该地址可以有几种类型：1、绝对URL - 指向另一个站点（比如 href="http://www.jd.com）2、相对URL - 指当前站点中确切的路径（href="index.htm"）3、锚URL - 指向页面中的锚（href="#top"）&lt;!--锚URL - 指向页面中的锚（href="#top"）--&gt;&lt;a href="#a2"&gt;a1跳a2&lt;/a&gt;&lt;div style="height: 1000px;background: red"&gt;&lt;/div&gt;&lt;a href="" id="a2"&gt;哈哈哈&lt;/a&gt; 123### target：_blank表示在新标签页中打开目标网页_self表示在当前标签页中打开目标网页 列表 无序列表: ui 有序列表: oi 标题列表: dl 1234567891011### 无序列表: ui&lt;ul type="circle"&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ul&gt;### type属性：disc（实心圆点，默认值）circle（空心圆圈）square（实心方块）none（无样式） 123456789101112### 有序列表: oi&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt;### type属性：1 数字列表，默认值A 大写字母a 小写字母Ⅰ大写罗马ⅰ小写罗马 12345678### 标题列表: dl&lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;内容2&lt;/dd&gt; &lt;dd&gt;内容2&lt;/dd&gt;&lt;/dl&gt; 表格 table 表格是一个二维数据空间，一个表格由若干行组成，一个行又有若干单元格组成，单元格里可以包含文字、列表、图案、表单、数字符号、预置文本和其它的表格等内容。 表格最重要的目的是显示表格类数据。表格类数据是指最适合组织为表格格式（即按行和列组织）的数据。 12345678910111213141516171819202122232425262728293031323334### 表格的基本结构&lt;table border="1" cellpadding="10" cellspacing="10"&gt; &lt;!-- 表头开始 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;爱好&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!-- 表内数据开始 --&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan="2"&gt;leo&lt;/td&gt; &lt;!--&lt;td&gt;28&lt;/td&gt;--&gt; &lt;td rowspan="2"&gt;游戏&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;lex&lt;/td&gt; &lt;td&gt;28&lt;/td&gt; &lt;!--&lt;td&gt;开车&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;### 属性:border: 表格边框.cellpadding: 内边距cellspacing: 外边距.width: 像素 百分比.（最好通过css来设置长宽）rowspan: 单元格竖跨多少行colspan: 单元格横跨多少列（即合并单元格） 快捷语句123456781、快速格式化 : Code --&gt; reformat code2、快速建立4个标签 : h1*4 --&gt;点击tab3、快速建立标签并增加属性 : div*4&gt;a.c1&#123;a标签$&#125;### div*4&gt;a.c1&#123;a标签$&#125; == 快速建立4个div标签，里面添加a标签,class='c1',内容为&#123;a标签$&#125;,&#123;$&#125;表示从1开始的序号 &lt;div&gt;&lt;a href="" class="c1"&gt;a标签1&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;a href="" class="c1"&gt;a标签2&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;a href="" class="c1"&gt;a标签3&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;a href="" class="c1"&gt;a标签4&lt;/a&gt;&lt;/div&gt; Form 表单 form 表单的作用：表单用于收集用户的输入信息，然后向服务器传输数据，从而实现用户与Web服务器的交互 表单能够包含input系列标签，如文本字段、复选框、单选框、提交按钮等等，表单还可以包含textarea、select、fieldset和 label标签。 表单属性 123456action: 表单提交到哪.一般指向服务器端一个程序,程序接收到表单提交过来的数据（即表单元素值）作相应处理，比如https://www.sogou.com/webmethod: 表单的提交方式 post/get，默认取值就是get# 关于表单提交点击sumbit提交后，会将数据组装成字典格式—键值对如果是：与查询相关的内容，使用get提交方法，数据在地址栏用？隔开如果是：服务器修改相关的内容用post请求 数据在请求体里 http协议中可见 Djaogo接收表单数据代码12345678910111213141516171819from django.conf.urls import urlfrom django.shortcuts import HttpResponsedef upload(request): print('request.GET:',request.GET) print("request.POST:", request.POST) if request.FILES: filename = request.FILES['avatar'].name with open(filename,'wb') as f: for chunk in request.FILES['avatar'].chunks(): f.write(chunk) return HttpResponse("上传成功") return HttpResponse('收到了')urlpatterns = [ url(r'^upload/',upload)] input系列标签 text 文本框12345678910&lt;p&gt; &lt;label for="username"&gt;用户名:&lt;/label&gt; &lt;input type="text" id="username" name="username" placeholder="请输入用户名" value="默认值" disabled&gt;&lt;/p&gt;# 属性说明: 1、disabled: 禁用2、placeholder: 占位符3、value: 默认值4、request.GET: &lt;QueryDict: &#123;'username': ['leo']&#125;&gt; password 密码输入框12345678&lt;p&gt; &lt;label for="password"&gt;密码:&lt;/label&gt; &lt;input type="password" id="password" name="password" placeholder="请输入密码" &gt;&lt;/p&gt;# 属性说明:1、基本与text一致2、request.GET: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123']&#125;&gt; date 日期1234567&lt;p&gt; &lt;label for="birthday"&gt;生日:&lt;/label&gt; &lt;input type="date" id="birthday" name="birthday"&gt;&lt;/p&gt;# 属性说明:1、request.GET: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20']&#125;&gt; radio 单选按钮123456789101112&lt;p&gt; &lt;label&gt;性别:&lt;/label&gt; &lt;input type="radio" id="r1" name="gender" value="男"&gt; &lt;label for="r1"&gt;男&lt;/label&gt; &lt;input type="radio" id="r2" name="gender" value="女"&gt; &lt;label for="r2"&gt;女&lt;/label&gt;&lt;/p&gt;# 属性说明:1、checked: 默认选中2、value:选择相关联的值 3、request.GET: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 'gender': ['男']&#125;&gt; checkbox 多选按钮1234567891011121314&lt;p&gt; &lt;label&gt;爱好:&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="football" checked&gt;足球 &lt;input type="checkbox" name="hobby" value="basketball"&gt;篮球 &lt;input type="checkbox" name="hobby" value="doubleball"&gt;双色球&lt;/p&gt;# 属性说明1、key=name: 多选标签的name必须一致，"hobby":[basketball,doubleball]2、值=value: value值必须设置3、value:选择相关联的值 4、checked: 默认选中5、request.GET: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 'gender': ['男'], 'hobby': ['basketball', 'doubleball']&#125;&gt; submit 提交按钮12345678&lt;p&gt; &lt;input type="submit" value="提交数据"&gt; &lt;input type="reset" value="重置数据"&gt;&lt;/p&gt;# 属性说明1、value:按钮上显示的文本内容2、点击sumbit会将表单中的数据组成字典(键值对)，并向服务器提交数据 reset 撤销按钮1234567&lt;p&gt; &lt;input type="submit" value="提交数据"&gt; &lt;input type="reset" value="重置数据"&gt;&lt;/p&gt;# 属性说明1、value:按钮上显示的文本内容2、点击reset撤销按钮，会将输入的内容数据重置 button 普通按钮123456&lt;p&gt; &lt;input type="button" value="普通事件按钮" onclick="alert(123)"&gt;&lt;/p&gt;# 属性说明1、通常用于JS绑定事件2、value: 按钮显示文本 hidden 隐藏标签123456&lt;p&gt; &lt;input type="hidden" name="user_id" value="leo_id"&gt;&lt;/p&gt;# 属性说明:1、每个页面中存储的用户信息比如隐藏身份证2、key=name, 值=value file 上传标签上传文件注意两点： 请求方式必须是: post form标签增加: enctype=”multipart/form-data” 1234567891011&lt;form action="http://127.0.0.1:8000/upload/" method="post" enctype="multipart/form-data"&gt; &lt;p&gt; &lt;input type="file" name="avatar" &gt; &lt;/p&gt;&lt;/form&gt;# 属性说明1、key="name",值="上传文件对象"2、request.POST: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 'gender': ['男'], 'hobby': ['football', 'basketball'], 'leo': ['leo_id']&#125;&gt;3、上传的附件会根据程序代码存储到指定目录 input表单标签属性总结 name: 表单提交时的“键”，注意和id的区别 value: 表单提交时对应项的值: type=”button”, “reset”, “submit”时，为按钮上显示的文本内容 type=”text”,”password”,”hidden”时，为输入框的初始值 type=”checkbox”, “radio”, “file”，为输入相关联的值 checked: radio和checkbox默认被选中的项 readonly: text和password设置只读 disabled: 所有input均适用 其他常用标签label 标记定义： 标签为 input 元素定义标注（标记）。1234# 属性说明:1、label 元素不会向用户呈现任何特殊效果。2、&lt;label&gt; 标签的 for 属性值应当与相关元素的 id 属性值相同。3、点击label内的内容 可以进入text文本框的光标 用for关联text的id select 下拉菜单123456789101112131415161718# 普通下拉框&lt;p&gt; &lt;label for="city"&gt;城市:&lt;/label&gt; &lt;select name="city" id="city"&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="hongkong" selected&gt;香港&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;# 属性说明:1、select 标签中的name为键2、option 标签中的value为值，一般情况下都不会使用中文,常用的地市会使用区号 010 = 北京3、selected="selected" 默认选中4、multiple="multiple" 为多选5、optgroup 分组的下拉框6、request.POST: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 'gender': ['男'], 'hobby': ['football', 'basketball'], 'city': ['beijing'], 'area': ['xc'], 'info': ['哈哈哈'], 'leo': ['leo_id']&#125;&gt; 12345678910111213141516# 分组下拉框&lt;p&gt; &lt;label for="area"&gt;区域&lt;/label&gt; &lt;select name="area" id="area"&gt; &lt;optgroup label="北京"&gt; &lt;option value="xc" selected&gt;西城&lt;/option&gt; &lt;option value="dc"&gt;东城&lt;/option&gt; &lt;option value="sjs"&gt;石景山&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="上海"&gt; &lt;option value="pd"&gt;浦东新区&lt;/option&gt; &lt;option value="hp"&gt;黄浦区&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;&lt;/p&gt; textarea 多行文本1234567891011&lt;p&gt; &lt;label for="info"&gt;自我介绍&lt;/label&gt; &lt;textarea id="info" name="info" cols="30" rows="10" placeholder="不少于100字"&gt;&lt;/textarea&gt;&lt;/p&gt;# 属性说明1、key=name,值=用户输入2、rows：行数3、cols：列数4、request.POST: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 、'gender': ['男'], 'hobby': ['football', 'basketball'], 'city': ['beijing'], 'info': ['哈哈哈'], 'leo': ['leo_id']&#125;&gt; form表单提交数据的几个注意事项 所有获取或用户输入的标签，都必须放在form表单里面 action 控制着往哪提交 input\select\textarea 都需要有name属性 提交按钮 input type=’sumbit’ file文件 需要post提交方式和enctype=”multipart/form-data”]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发爬虫]]></title>
    <url>%2F2019%2F05%2F10%2Fconcurrent-crawl%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO 模型]]></title>
    <url>%2F2019%2F05%2F08%2Fio-model%2F</url>
    <content type="text"><![CDATA[IO模型介绍Stevens在文章中一共比较了五种IO Model：12345# 1、blocking IO 阻塞IO# 2、nonblocking IO 非阻塞IO# 3、IO multiplexing IO多路复用# 4、signal driven IO 信号驱动IO# 5、asynchronous IO 异步IO 由于signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model IO发生时涉及的对象和步骤:对于一个network IO (这里我们以read举例)，它会涉及到 两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，该操作会经历两个阶段： 12#1）等待数据准备 (Waiting for the data to be ready)#2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process) 阻塞 IO(blocking IO) 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。kernel要等待足够的数据到来,用户进程这边，整个进程会被阻塞。 有数据到来后，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。 几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。123# 使用多线程或多进程解决阻塞？# 在服务器端使用多线程（或多进程）。# 多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。 123# 多线程或多进程的问题:# 开启多进程多线程的方式，在遇到要同时响应成百上千路的连接请求，# 则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态。 1234# 使用线程池或进程池的问题:# 线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。# 而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。# 所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。 对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。 非阻塞 IO(non-blocking IO) 当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。 用户进程判断结果是一个error时，它就知道数据还没有准备好，于是用户就可以在本次到下次再发起read询问的时间间隔内做其他事情，或者直接再次发送read操作。 一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存（这一阶段仍然是阻塞的），然后返回。 所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。 但是非阻塞IO模型绝不被推荐。12345#1. 循环调用recv()将大幅度推高CPU占用率；这也是我们在代码中留一句time.sleep(2)的原因,否则在低配主机下极容易出现卡机情况#2. 任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。# 这会导致整体数据吞吐量的降低。#3. recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，# 例如select()多路复用模式，可以一次检测多个连接是否活跃。 多路复用 IO(IO multiplexing)IO multiplexing这个词可能有点陌生，但是如果我说select/epoll，大概就都能明白了。有些地方也称这种IO方式为事件驱动IO(event driven IO)。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。结论: select的优势在于可以处理多个连接，不适用于单个连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445# IO 多路复用# 代理帮忙去查看链接和接收发送消息,代理可以监听多个对象# windows 拥有select模块import selectimport socketsk = socket.socket()sk.bind(('127.0.0.1',8000))sk.setblocking(False) # 非阻塞模式sk.listen()read_lst = [sk] # 监听谁就放谁# print(ret) # ([&lt;socket.socket fd=204, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000)&gt;], [], [])# print(r_lst) # [&lt;socket.socket fd=204, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000)&gt;]# print(sk) # &lt;socket.socket fd=204, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000)&gt;# r_lst 里面存着的 sk对象while True: # 当有链接来连，获取了socket对象并链接 # 将对象再放入列表中继续监听 [sk,conn] r_lst, w_lst, x_lst = select.select(read_lst, [], []) # r_list和其他空列表 # print('******',r_lst) for i in r_lst: if i is sk: conn,addr = i.accept() # print(conn) # &lt;socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000), raddr=('127.0.0.1', 61832)&gt; read_lst.append(conn) else: # 否则是conn ret = i.recv(1024) if ret == b'': i.close() read_lst.remove(i) continue print(ret) i.send(b'bye')# IO多路复用 # select Windows Linux 都是操作系统轮询每一个被监听的项，看是否有读才做 # poll Linux 可以监听的对象比select对象多 # 随着监听项的增多，导致效率降低 # epoll Linux 给每一个监听对象都绑定一个回调函数 # selectors 可以自动帮我们选适合操作系统的模块 12345678910111213141516# clientimport socketimport timeimport threadingdef func(): sk = socket.socket() sk.connect(('127.0.0.1',8000)) sk.send(b'hello') time.sleep(3) print(sk.recv(1024)) sk.close()for i in range(20): threading.Thread(target=func).start() 异步IO (Asynchronous I/O) 12345678910111213141516### 需要记住# 同步 # 提交一个任务之后，要等待这个任务执行完毕# 异步 # 只管提交任务，不等待这个任务执行完毕，就可以做其他事情# 阻塞 # recv、recvfrom、accept # 非阻塞 # 都可以正常执行# 阻塞和非阻塞 # 线程遇到阻塞 ： 运行 --&gt; 阻塞 --&gt; 就绪 --&gt; 运行 # 线程遇到非阻塞：运行 &lt;--&gt; 就绪 123456789### 需要理解# 1、异步IO 没有数据 直接返回# 2、操作系统会告诉我有新数据进来，并直接将数据交给用户# 异步IO 没有wait data 和 copy data# 其他模型只是对wait data 进行优化# 异步IO 都是操作系统来完成 wait data 和 copy data，Python并不能完成，C语言可以直接实现# Python的异步模块和框架 很多都是用底层的C语言实现 框架包括Twisted和Tornado# 异步框架 可以相应更多的需求 IO模型比较分析12# blocking和non-blocking的区别# 调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回 selectors 模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#服务端from socket import *import selectorssel=selectors.DefaultSelector()def accept(server_fileobj,mask): conn,addr=server_fileobj.accept() # accept 建立后 注册conn sel.register(conn,selectors.EVENT_READ,read) # 监听conn的读时间 , 回调函数 readdef read(conn,mask): try: data=conn.recv(1024) if not data: print('closing',conn) sel.unregister(conn) conn.close() return conn.send(data.upper()+b'_SB') except Exception: print('closing', conn) sel.unregister(conn) conn.close()# 建立socket对象sk=socket(AF_INET,SOCK_STREAM) # socket对象sk.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)sk.bind(('127.0.0.1',8088))sk.listen(5)sk.setblocking(False) #设置socket的接口为非阻塞# 选择适合的IO多路复用机制# sel=selectors.DefaultSelector() selectors模块sel.register(sk,selectors.EVENT_READ,accept)# selectors.EVENT_READ 监听的是一个读事件# 相当于网select的读列表里append了一个socket对象,并且绑定了一个回调函数 accept# 有人请求链接socket了 就调用 accept方法 accept(server_fileobj,mask)while True: events=sel.select() # 检测所有的fileobj(socket|conn)，是否有完成wait data for sel_obj,mask in events: callback=sel_obj.data # callback=accpet | read callback(sel_obj.fileobj,mask) # accpet(server_fileobj,1) | read(conn,l)#客户端from socket import *c=socket(AF_INET,SOCK_STREAM)c.connect(('127.0.0.1',8088))while True: msg=input('&gt;&gt;: ') if not msg:continue c.send(msg.encode('utf-8')) data=c.recv(1024) print(data.decode('utf-8'))# selectors 模块 可以帮助我们选择适合操作系统的IO多路复用模块# 非阻塞IO一直在询问，会耗费CPU# 1、异步IO 没有数据 直接返回# 2、操作系统会告诉我有新数据进来，并直接将数据交给用户]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>IO多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程]]></title>
    <url>%2F2019%2F04%2F30%2Fcoroutines%2F</url>
    <content type="text"><![CDATA[什么是协程 在操作系统中进程是资源分配的最小单位,线程是CPU调度的最小单位。 无论是创建多进程还是创建多线程来解决问题，都要消耗一定的时间来创建进程、创建线程、以及管理他们之间的切换。 基于单线程来实现并发又成为一个新的课题，即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并发。这样就可以节省创建线进程所消耗的时间。 并发的本质：切换+保存状态cpu正在运行一个任务，会在两种情况下切走去执行其他的任务（切换由操作系统强制控制），一种情况是该任务发生了阻塞，另外一种情况是该任务计算的时间过长。 协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。为了实现它，我们需要找寻一种可以同时满足以下条件的解决方案： 可以控制多个任务之间的切换，切换之前将任务的状态保存下来，以便重新运行时，可以基于暂停的位置继续执行。 作为1的补充：可以检测io操作，在遇到io操作的情况下才发生切换 实现在多个任务之间切换 yield + send yield无法做到遇到io阻塞12345678910111213141516171819202122232425262728293031323334353637383940# 进程 : 启动多个进程,进程之间是由操作系统负责调用# 线程 : 启动多个线程,真正被CPU执行的最小单位实际是线程 # 开启一个线程 ：创建1个线程,属于线程的内存开销 寄存器和堆栈 # 关闭一个线程 # 线程在CPython下，由于全局GLI锁，多线程没有办法同时访问CPU，真正工作只有一个CPU# 协程 : 本质上是一个线程 # 在多个任务之间切换，来节省IO时间 # 无需切换寄存器 和 堆栈，只是正常在程序之间切换 # ***** 能在多个任务之间切换 # ***** 协程中任务之间的切换也消耗时间，但是开销，要远远小于进程线程之间的切换。# 实现并发的手段### 实现在多个任务之间切换 yield + sendimport timedef consumer(): # print(111111) while True: x = yield time.sleep(1) print('处理了数据: ' ,x)def producer(): c = consumer() # 生成器 next(c) # 激活生成器,send之前必须next for i in range(10): time.sleep(1) print('生产了数据 %s ' %i) c.send(i)producer() # 在producer控制了consumer函数，并且来回切换 即-在两个任务中切换c = consumer() # 生成器print(c) # &lt;generator object consumer at 0x00000000021C84C0&gt;c.__next__()next(c)c.send(100)c.send(200) greenlet 模块切换执行程序12345678910111213141516171819202122232425262728293031323334353637from greenlet import greenlet# pip3 install greenlet# pip3 install gevent# greenlet 学习一下 后续不用# 协程模块# 切换执行程序# 真真干的协程模块，就是使用greenlet完成的切换def eat(): print('eating start') g2.switch() # 第1次切换 在这里switch(切换)，不仅切换还会记录执行的位置 print('eating end') g2.switch()def play(): print('playing start') g1.switch() print('playing end')# 把执行的方法 交给greenletg1 = greenlet(eat)g2 = greenlet(play)g1.switch() # 首先让g1执行# 结果: 出现switch即切换程序# eating start# playing start# eating end# laying end# 进程 4c+1 = 5# 线程 4c*5 = 20# 协程 每个线程里最多可以启动500个协程# 并发 1个进程20个线程 5个进程 100个线程 100个线程 = 50000W个协程# nginx 分发任务,最大承载量 5W# 在IO等待的时候 切换执行其他任务 使用gevent模块实现协程 安装：pip3 install gevent Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。 123456# g1=gevent.spawn(func,1,,2,3,x=4,y=5)创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的# g2=gevent.spawn(func2)# g1.join() #等待g1结束# g2.join() #等待g2结束# 或者上述两步合作一步：gevent.joinall([g1,g2])# g1.value#拿到func1的返回值 使用gevent实现IO切换123456789101112131415161718192021222324252627282930313233343536373839from gevent import monkey;monkey.patch_all()# 会把后面所有的阻塞操作都打成包，就会认识到time.sleepimport timeimport geventimport threading# 遇到IO切换def eat(): print(threading.current_thread().getName()) # DummyThread-1 仿制品线程 虚拟线程 -- 协程 print('eating start') time.sleep(1) # gevent.sleep(1) print('eating end')def play(): print(threading.current_thread().getName()) print('playing start') time.sleep(1) # gevent.sleep(1) print('playing end')g1 = gevent.spawn(eat) # gevent 遇到IO会自动切换g2 = gevent.spawn(play)g1.join() # 等待g1执行结束g2.join() # 等待g2执行结束,不然则异步# 或者上述两步合作一步：gevent.joinall([g1,g2])# 结果# eating start# playing start 同时开始# 同时睡一秒# eating end 同时结束# playing end# 总结：# 1、进程和线程的任务切换 由操作系统完成，而协程任务切换由程序代码完成,只有遇到协程模块能识别的IO操作的时候，程序才会执行任务切换# 实现并发效果。# 2、协程是通过greenlet模块的switch()方法控制切换 gevent的同步和异步1234567891011121314151617181920212223242526272829# gevent.sleep(2)模拟的是gevent可以识别的io阻塞,而time.sleep(2)或其他的阻塞,# gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了# from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前# 或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头from gevent import monkey;monkey.patch_all()import timeimport geventdef task(): time.sleep(1) # 模拟IO阻塞 print(12345)def sync(): # synchronous = sync 同步 for i in range(10): task()def async(): # 异步 g_lst = [] for i in range(10): g = gevent.spawn(task) g_lst.append(g) # for g in g_lst:g.join() # 等待所有的协程结束 gevent.joinall(g_lst) # 接收可迭代对象 每个g都执行完join# sync() # 同步 睡一秒执行一个async() # 异步 都睡一秒一起执行# 协程 适合用于网络操作，比如爬虫 协程爬虫小例子123456789101112131415161718192021222324252627282930313233343536373839404142434445# 协程：能够在线程中实现并发效果 # 能够规避一些在任务中遇到的IO操作 # 在任务的执行过程中,检测到IO就切换到其他任务### 协程 — 爬虫例子# 正则基础# 请求过程中的IO等待from gevent import monkey;monkey.patch_all()import requestsimport geventurl = 'https://maoyan.com/board/4'# res = requests.get(url)# print(len(res.content.decode('utf-8')))# print(len(res.text))def get_url(url): headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/71.0.3578.98 Safari/537.36' &#125; res = requests.get(url,headers=headers) html = res.content.decode('utf-8') return len(html)# ret = get_url('http://www.baidu.com')g1 = gevent.spawn(get_url,'http://www.tianmao.com')g2 = gevent.spawn(get_url,'http://www.taobao.com')g3 = gevent.spawn(get_url,'http://www.jd.com')g4 = gevent.spawn(get_url,'https://maoyan.com/board/4')gevent.joinall([g1,g2,g3,g4])print(g1.value)print(g2.value)print(g3.value)print(g4.value)# 总结：# 为什么用到协程 # 多线程在CPython解释器下，存在GIL锁，无法真正的使用多个CPU，多个线程之间的切换就会浪费时间 # 可以把一个线程的作用发挥到极致 1个线程可以开启500个协程,提高了CPU的利用率 # 协程相比于多线程的优势 ，切换的效率更快]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2019%2F04%2F25%2Fthread%2F</url>
    <content type="text"><![CDATA[线程进程内容回顾： 程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。 程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。 在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。 进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。 进程的出现，可以让一台服务器同时处理多个任务,在多个任务之间来回切换并记录任务执行状态。 进程的缺陷： 进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。 进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。 线程的出现：随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。因此在80年代，出现了能独立运行的基本单位——线程（Threads）。 注意: 进程是资源分配的最小单位,线程是CPU调度的最小单位. 每一个进程中至少有一个线程。 进程和线程的关系 地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 调度和切换：线程上下文切换比进程上下文切换要快得多。 在多线程操作系统中，进程不是一个可执行的实体。 线程的特点在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。 轻型实体。存储的较少线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。 独立调度和分派的基本单位。 真正被操作系统调度的是线程在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。 共享进程资源。 进程的数据在多线程中使用不用ipc，而是直接使用线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。 可并发执行。 比如6个线程可以运行不同的代码在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。 内存中的线程 多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程。而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。 不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。 类似于进程，每个线程也有自己的堆栈，不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。 线程通常是有益的，但是带来了不小程序设计难度，线程的问题是： 父进程有多个线程，那么开启的子线程是否需要同样多的线程 在同一个进程中，如果一个线程关闭了文件，而另外一个线程正准备往该文件内写内容呢？因此，在多线程的代码中，需要更多的心思来设计程序的逻辑、保护程序的数据。 开启多线程通过threading模块开启多线程123456789101112131415# Python多线程模块# thread、threading和Queue 推荐使用threading# 线程的创建Threading.Thread类import timefrom threading import Thread# 多线程并发def func(n): time.sleep(1) # 10次子线程一起执行 print(n) # 并发for i in range(10): t = Thread(target=func,args=(i,)) t.start() 通过继承threading类 开启多线程1234567891011121314import timefrom threading import Threadclass MyTread(Thread): def __init__(self,arg): super().__init__() self.arg = arg def run(self): time.sleep(1) print(self.arg)for i in range(10): t = MyTread(10) t.start() 多线程与多进程12345678910111213141516import osimport timefrom threading import Threaddef func(a,b): n = a+b print(n,os.getpid())print('主线程',os.getpid())for i in range(10): t = Thread(target=func,args=(i,5)) t.start()# 主线程和子线程的pid是一致的，说明子线程都是在一个进程里执行# 主进程中 存储 导入的模块，文件所在的位置，内置的函数，代码# 主线程存储循环的i 和 t# 子线程拥有栈，里面存储着 add a 和 b n = 0+5 内存数据共享12345678910111213141516171819# 内存数据共享import osimport timefrom threading import Threaddef func(a,b): global g g = 0 # g = 0 + a print(g,os.getpid())g = 100t_lst = []print('主线程',os.getpid())for i in range(10): t = Thread(target=func,args=(i,5)) t.start() t_lst.append(t)for t in t_lst:t.join()print(g) 12345678910111213141516171819202122232425262728293031# 总结:# 进程 是 最小的内存分配单位# 线程 是 操作系统调度的最小单位# 真正被执行的是线程，线程被CPU执行# 进程内至少含有一个线程# 进程中可以开启多个线程 # 开启一个线程 所需要的时间 要远远小于开启一个进程 # 线程占用的内存空间 也更小 # 多个线程内部有自己的数据栈，这个数据是不共享的 # 全局变量在多个线程之间是共享的# 在CPython解释器下的Python程序 # 在同一时刻，多个线程中只能有一个线程 被 CPU执行 # 高CPU：计算类 --- 高CPU利用率 执行效率不高 # 高IO: # 爬取网页 # 读写文件 处理日志文件 # 网络请求 处理web请求 # 读数据库 写数据库 # 非要处理计算类，就使用多进程 进程与进程没有锁 # 4个CPU# 不同的CPU可以执行多条线程，可能会造成数据的混乱# 对同一个数据的加减操作# CPython解释器 为了避免 存在 一种锁 GLP 全局解释器锁# 任何一个线程 想要给CPU 必须拿到钥匙，只有拿到钥匙的线程才能交给CPU执行# 重点：# 1 同一时刻，只能有一个线程，访问CPU，# 2 锁的是什么？锁的是线程# 3 锁的缺点: 多线程不能充分的利用CPU，同一时间只能用到一个C# 4 GLP是Python语言的问题么？ 不是，是CPython解释器的特性，JPython没有这个锁 多线程与多进程执行效率对比123456789101112131415161718192021222324252627282930import timefrom threading import Threadfrom multiprocessing import Processdef func(n): n + 1 # 计算操作 占用cpuif __name__ == '__main__': start = time.time() t_lst = [] for i in range(100): t = Thread(target=func,args=(i,)) t.start() t_lst.append(t) for t in t_lst:t.join() t1 = time.time() - start start = time.time() p_lst = [] for i in range(100): p = Process(target=func,args=(i,)) p.start() p_lst.append(t) for p in p_lst:p.join() t2 = time.time() - start print('线程执行',t1) # 0.009000539779663086 print('进程执行',t2) # 1.8071033954620361 # 对于高IO 和 简单的高CPU计算任务时 , 多线程的开销更少，执行效率更高 线程模块中的其他方法123456789101112131415import threadingimport timedef wahaha(n): time.sleep(0.5) print(n,threading.current_thread(),threading.get_ident()) # 子线程 名字 PIDfor i in range(10): threading.Thread(target=wahaha,args=(1,)).start()print(threading.active_count()) # 查看当前所有的活跃的线程数 # 11 (10个子线程+1个主线程)print(threading.current_thread()) # 主线程 名字 PIDprint(threading.enumerate()) # 所有的进程名字 pid 存在一个列表返回print(len(threading.enumerate())) # 11 多线程实现简单的socket服务123456789101112131415161718192021# serverimport socketfrom threading import Threaddef chat(conn): conn.send(b'hello') msg = conn.recv(1024).decode('utf-8') print(msg) conn.close()s = socket.socket()s.bind(('127.0.0.1',8090))s.listen()while True: conn,addr = s.accept() # 获取连接 t = Thread(target=chat,args=(conn,)) t.start()s.close() 1234567891011# clientimport sockets = socket.socket()s.connect(('127.0.0.1',8090))msg = s.recv(1024).decode('utf-8')print(msg)inp = input('&gt;&gt;&gt;').encode('utf-8')s.send(inp)s.close() 守护线程 daemon=True123456789101112131415161718192021222324252627282930313233343536373839404142434445import timefrom threading import Threaddef func1(): while True: print(10 * '*') time.sleep(1)def func2(): print('in func2') time.sleep(5)t = Thread(target=func1,)t.daemon = Truet.start()t2 = Thread(target=func2,)t2.start()t2.join() # 所有的t2结束后打印在执行主进程代码# 守护进程 随着主进程代码的执行结束 而结束# 守护线程 会在主线程结束之后，等待其他子线程的结束而结束# 主进程 在执行完自己的代码之后 不会立即结束，而是等待子进程结束之后 回收子进程的资源import timefrom multiprocessing import Processdef func1(): while True: print(10 * '*') time.sleep(1)def func2(): print('in func2') time.sleep(5)if __name__ == '__main__': p = Process(target=func1, ) p.daemon = True # 守护线程 主线程结束，守护线程随之结束 p.start() p2 = Process(target=func2, ) p2.start() print('主进程') 线程锁 Lock123456789101112131415161718192021222324252627282930import timefrom threading import Lock,Threaddef func(lock): global n lock.acquire() temp = n time.sleep(0.2) n = temp - 1 lock.release()n = 10t_lst = []lock = Lock()for i in range(10): t = Thread(target=func,args=(lock,)) t.start() t_lst.append(t)for i in t_lst:t.join() # 执行完所有子线程print(n)# 10个线程分别 n - 1# 1、10个线程同时执行 都去拿 n = 10# 2、都sleep 0.2秒,同时减1# 3、同时赋值回去 大家赋值的都是9# 4、为什么有了GIL锁 还是会出现混乱 : 拿到数据后 刚好时间片到了会释放锁 ，就会拿到同一数据# 5、GIL锁加给线程，为了避免多个线程同一时间对一个数据操作，但是无法避免时间片的轮转对数据的不安全性# 6、多线程里还需要用到锁# 7、加锁，牺牲了效率，保证了数据安全 递归锁解决死锁问题 RLock1234567891011121314151617181920212223242526272829303132333435363738394041import timefrom threading import Lock,Threadnoodle_lock = Lock()fork_lock = Lock()def eat1(name): noodle_lock.acquire() print('%s 拿到面条' %name) fork_lock.acquire() print('%s 拿到叉子' %name) print('%s 吃面' %name) fork_lock.release() noodle_lock.release()def eat2(name): fork_lock.acquire() print('%s 拿到叉子' %name) time.sleep(1) noodle_lock.acquire() print('%s 拿到面条' %name) print('%s 吃面' %name) noodle_lock.release() fork_lock.release()Thread(target=eat1,args=('rubin',)).start()Thread(target=eat2,args=('leo',)).start()Thread(target=eat1,args=('lex',)).start()Thread(target=eat2,args=('fily',)).start()# rubin 拿到面条# rubin 拿到叉子# rubin 吃面# leo 拿到叉子# lex 拿到面条# ... 卡住了 123456789101112131415161718192021222324252627282930313233343536373839404142# 递归锁 解决死锁问题import timefrom threading import Lock,Threadfrom threading import RLockr_fork_lock = r_noodle_lock = RLock() # 一个钥匙串上的两把钥匙def eat1(name): r_noodle_lock.acquire() # 一旦拿到其中一把钥匙，说明要是都在手里 房子1 print('%s 拿到面条' %name) r_fork_lock.acquire() # 房子2 2层钥匙 print('%s 拿到叉子' %name) print('%s 吃面' %name) r_fork_lock.release() # 释放1层 r_noodle_lock.release() # 释放2层 还完所有钥匙def eat2(name): r_fork_lock.acquire() print('%s 拿到叉子' %name) time.sleep(1) r_noodle_lock.acquire() print('%s 拿到面条' %name) print('%s 吃面' %name) r_noodle_lock.release() r_fork_lock.release()Thread(target=eat1,args=('rubin',)).start()Thread(target=eat2,args=('leo',)).start()Thread(target=eat1,args=('lex',)).start()Thread(target=eat2,args=('fily',)).start()# Lock 互斥锁 1把钥匙# RLock 递归锁 同一个线程拿多少次钥匙都可以 , 不同的线程里 一旦有一个拿到了，别的线程都无法拿到# 递归解决死锁问题，同一个线程可以被 acquire 多次。# 当同一个线程 或者 同一个进程 遇到两把以上锁的时候，就容易出现死锁，需要使用递归锁。# 线程进场遇到全局数据，全局数据又是共享，所以经常要加锁。 信号量 Semaphore12345678910111213141516import timefrom threading import Semaphore,Thread# 信号量 就是控制n个线程 访问同一段代码def func(sem,a,b): sem.acquire() time.sleep(1) print(a + b) sem.release()# KTV例子 同一时间几个人能够进入sem = Semaphore(4) # 同一时间 只能有4个线程进入for i in range(10): t = Thread(target=func,args=(sem,i,i+5)) t.start() 事件 Event123456789101112131415161718192021222324252627282930313233343536373839404142# 事件被创建的时候# 当False状态，wait() 阻塞# 当True状态的 wait() 非阻塞# clear 设置状态为False# set 设置状态为True# 之前有红绿灯例子# 链接数据库和检测数据库的可链接情况# 起两个线程# 第一个线程 : 链接数据库 # 等待一个信号,告诉我们之间的网络是通的 # 链接数据库# 第二个线程 : 检测与数据库之间的网络是否连通 # 模拟检测 time.sleep(0,2) 如果2秒钟没通 就是没通 # 将事件的状态,设置为 Trueimport timeimport randomfrom threading import Event,Threaddef connect_db(e): count = 0 # 计数器，尝试三次链接 while count &lt; 3: e.wait(0.5) # 状态为False的时候 ，只等待n秒钟就结束 if e.is_set() == True: print('链接数据库') break else: count += 1 print('第%s次链接失败' %count) else: # while 循环 + else 三次都没有被break 也就是都没连接上 raise TimeoutError('数据库连接超时') # 超时错误def check_web(e): time.sleep(random.randint(0,3)) e.set() # wait = Truee = Event()t1 = Thread(target=connect_db,args=(e,))t2 = Thread(target=check_web,args=(e,))t1.start()t2.start() 定时器 Timer123456789import timefrom threading import Timerdef func(): print('时间同步')while True: t = Timer(2,func).start() # Timer(秒数,方法) 2秒钟之后开启线程 time.sleep(5) # 和上面的Timer是同步 Timer5秒后会执行func 队列 queue1234# Queue 先进先出 队列# LifoQueue 先进后出 栈# PriorityQueue 优先级队列# 他们都是数据安全 1234567# 队列import queue q = queue.Queue() # 队列的特点 先进先出q.put() # 满了会阻塞q.get() # 空了会阻塞q.put_nowait() # + 异常处理q.get_nowait() # 1234567# 栈import queue q = queue.LifoQueue() # 栈 先进后出 (先进来的在最底下,后进来的先出去)q.put(1)q.put(2)q.put(3)print(q.get()) # 3 12345678910# 优先级队列import queue q = queue.PriorityQueue() # 优先级队列 放数据的时候，给优先级q.put((20,'a'))q.put((10,'b'))q.put((30,'c'))q.put((1,'z'))q.put((1,'d'))print(q.get()) # (1, 'd') 顺序按照 数字从小到大，如果数字相同,按照数据的ASCII码排 线程池 concurrent.futures 模块12345# 1 介绍# concurrent.futures模块提供了高度封装的异步调用接口# ThreadPoolExecutor：线程池，提供异步调用# ProcessPoolExecutor: 进程池，提供异步调用# Both implement the same interface, which is defined by the abstract Executor class. 12345678910111213141516171819202122232425# 2 基本方法# submit(fn, *args, **kwargs)# 异步提交任务# map(func, *iterables, timeout=None, chunksize=1)# 取代for循环submit的操作# shutdown(wait=True)# 相当于进程池的pool.close() + pool.join() 操作# wait=True，等待池内所有任务执行完毕回收完资源后才继续# wait=False，立即返回，并不会等待池内的任务执行完毕# 但不管wait参数为何值，整个程序都会等到所有任务执行完毕# submit和map必须在shutdown之前# result(timeout=None)# 取得结果# add_done_callback(fn)# 回调函数# done()# 判断某一个线程是否完成# cancle()# 取消某个任务 12345678910111213141516171819# 线程池import timefrom concurrent.futures import ThreadPoolExecutor # 线程池,提供异步调用from concurrent.futures import ProcessPoolExecutor # 进程池,提供异步调用 apply_async()def func(n): time.sleep(2) print(n) return n*ntpool = ThreadPoolExecutor(max_workers=5) # 1一般情况下 线程卡其 max_workers = 默认不要超过 cpu个数 * 5t_lst = [] # 任务列表for i in range(10): t = tpool.submit(func,i) # 线程池提交任务 t_lst.append(t) # 存储结果对象,就像领了个号，等任务结束后去领取结果tpool.shutdown() # pool.close() 关闭池子不让人物再提交进来 + pool.join() 阻塞直到池子中的子线程任务执行完print('主线程')for t in t_lst:print('***',t.result()) # 为什么这个地方按顺序打印，因为 t_lst 是按照顺序产生的 123456789101112# 流程总结:# 1、创建线程池# 2、线程池异步提交任务# 3、阻塞到线程池任务都结束# 4、获取结果# 如果没有shutdown:# 1、会先打印 print('主线程')# 2、谁先执行好 就先接收到结果输出 (消耗好一些)# 5线程 * 每个任务2秒 = 5任务2秒 10任务4秒 如果join 需要4秒后统一拿结果# 不加join 2秒后执行完前5个任务拿到结果# 如果有返回值的话 ，超过池子的数量 用 shutdown 效率会慢 123456789101112131415161718192021### 进程池import timefrom concurrent.futures import ThreadPoolExecutor # 线程池,提供异步调用from concurrent.futures import ProcessPoolExecutor # 进程池,提供异步调用 apply_async()def func(n): time.sleep(2) print(n) return n*nif __name__ == '__main__': p_pool = ProcessPoolExecutor(max_workers=5) p_lst = [] # 任务列表 for i in range(10): t = p_pool.submit(func, i) p_lst.append(t) p_pool.shutdown() print('主进程') for p in p_lst: print('进程池 ***', p.result()) 1234567891011### mapimport timefrom concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutordef func(n): time.sleep(2) print(n) return n*nt_pool = ThreadPoolExecutor(max_workers=5)t_pool.map(func,range(20)) # 拿不到返回值啦 123456789101112131415161718# 回调函数 call_backimport timefrom concurrent.futures import ThreadPoolExecutor # 线程池,提供异步调用from concurrent.futures import ProcessPoolExecutor # 进程池,提供异步调用 apply_async()def func(n): time.sleep(2) print(n) return n*ndef call_back(m): # 接收到了个对象 print('结果是%s' %m.result())tpool = ThreadPoolExecutor(max_workers=5)t_lst = [] # 任务列表for i in range(10): t = tpool.submit(func,i).add_done_callback(call_back) # 线程池提交任务 带回调函数 t_lst.append(t)]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多进程 multiprocess模块]]></title>
    <url>%2F2019%2F04%2F19%2Fprocess-note%2F</url>
    <content type="text"><![CDATA[开启多进程使用Process模块123456# Process([group [, target [, name [, args [, kwargs]]]]])# target表示调用对象，你可以传入方法的名字# args表示被调用对象的位置参数元组，比如target是函数a，他有两个参数m，n，那么args就传入(m, n)即可# kwargs表示调用对象的字典# name是别名，相当于给这个进程取一个名字# group分组，实际上不使用 12345678910111213141516171819# 使用process模块from multiprocessing import Processimport multiprocessingimport osdef process(num): print('PID:%s Process:%s' %(os.getpid(),num))if __name__ == '__main__': for i in range(5): p = Process(target=process,args=(i,)) p.start() print('CPU number:%d' %multiprocessing.cpu_count()) # cpu个数 # CPU number:4# PID:97764 Process:1# PID:101312 Process:2# PID:100472 Process:0# PID:101172 Process:4# PID:99964 Process:3 继承Process类12345678910111213141516171819# 继承创建多进程from multiprocessing import Processclass MyProcess(Process): def __init__(self): super().__init__() def run(self): print('开始一个新进程 PID:%s' %self.pid)if __name__ == '__main__': for i in range(5): p = MyProcess() p.start()# 开始一个新进程 PID:100524# 开始一个新进程 PID:97824# 开始一个新进程 PID:87880# 开始一个新进程 PID:93100# 开始一个新进程 PID:94960 守护进程 deamon123456789101112131415161718192021222324# 如果设置为True，当父进程结束后，子进程会自动被终止。# 注意: 守护进程 会随着 主进程的代码执行完毕 而结束# 代码运行: 主进程 在延迟一秒后只打印一句话，全部的代码已经执行完成,也直接终止了子进程的运行# 作用: 有效防止无控制地生成子进程，关闭这个主程序运行时，就无需额外担心子进程有没有被关闭了。import timefrom multiprocessing import Processclass MyProcess(Process): def __init__(self): super().__init__() def run(self): time.sleep(2) print('开启一个新进程%s' %self.pid)if __name__ == '__main__': for i in range(5): p = MyProcess() p.daemon = True p.start() time.sleep(1) print('主进程结束') # time.sleep(3) # 如果再延迟3秒，子进程会执行，因为这个时候主进程的代码还没有执行结束 # 主进程结束 主进程等待子进程执行完成 join12345678910111213141516171819202122232425262728293031323334# 主进程等待子进程执行完成 join# 每个子进程都调用了join()方法，这样父进程（主进程）就会等待子进程执行完毕。import osimport timefrom multiprocessing import Processclass MyProcess(Process): def __init__(self,num): super().__init__() self.num = num def run(self): time.sleep(1) print('子进程%s 任务编号%s 开始执行' %(os.getpid(),self.num))if __name__ == '__main__': start_time = time.time() p_lst = [] for i in range(1,6): p = MyProcess(i) p_lst.append(p) p.daemon = True p.start() # p.join() # 如果在循环里面join,则每循环一个进程都要等待进程的结束,会变成同步 [p.join() for i in p_lst] # 之前的所有进程必须在这里都执行完，才能执行后面的代码 print('主进程执行结束') print('程序运行:',time.time()-start_time) # 子进程55888 任务编号3 开始执行# 子进程16812 任务编号4 开始执行# 子进程77500 任务编号1 开始执行# 子进程62216 任务编号5 开始执行# 子进程86548 任务编号2 开始执行# 主进程执行结束# 程序运行: 1.2200696468353271]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程]]></title>
    <url>%2F2019%2F04%2F04%2Fconcurrency%2F</url>
    <content type="text"><![CDATA[进程理论基础一、操作系统的作用: 隐藏丑陋复杂的硬件接口，提供良好的抽象接口 管理、调度进程，并且将多个进程对硬件的竞争变得有序 二、多道技术: 产生背景：针对单核，实现并发ps：现在的主机一般是多核，那么每个核都会利用多道技术有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个cpu中的任意一个，具体由操作系统调度算法决定。 空间上的复用：如内存中同时有多道程序 时间上的复用：复用一个cpu的时间片强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样才能保证下次切换回来时，能基于上次切走的位置继续运行 三、进程: 进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。 进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。 PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。 内存越大，多个程序占用的空间越大；CPU核数越多，同一时间处理的任务越多。 什么是进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。 进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。[3]进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。 进程的并行与并发 并行 : 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ） 并发 : 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。 区别:并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。 进程的三状态 在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。 （1）就绪(Ready)状态 当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。 （2）执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。 （3）阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。 同步与异步 同步: 串行处理一件事物 异步: 同时处理多件不同的事物 所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。 所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。 阻塞与非阻塞 阻塞: input 读写文件 产生IO操作 非阻塞: 不产生IO操作阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的 同步/异步与阻塞/非阻塞 同步阻塞形式 效率低 专心排队，什么别的事都不做 异步阻塞形式 领一张排队号码，不用排队等着叫号，但是等的过程中不能做其他事情。异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。 同步非阻塞形式 一边排队，一边打电话,来回切换两种不同的行为，效率低 异步非阻塞形式 效率高，等着柜台(消息触发机制)通知，去外面抽烟，做自己的事 很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞。 进程的创建与结束但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程： 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印） 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等） 用户的交互式请求，而创建一个新进程（如用户双击暴风影音） 一个批处理作业的初始化（只在大型机的批处理系统中应用）无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。 进程的结束: 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess） 出错退出（自愿，python a.py中a.py不存在） 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try…except…） 被其他进程杀死（非自愿，如kill -9） 在python程序中的进程操作创建进程共四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。 multiprocess.process模块process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。 Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动） 强调： 需要使用关键字的方式来指定参数 args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号 参数介绍：1 group参数未使用，值始终为None2 target表示调用对象，即子进程要执行的任务3 args表示调用对象的位置参数元组，args=(1,2,’egon’,)4 kwargs表示调用对象的字典,kwargs={‘name’:’egon’,’age’:18}5 name为子进程的名称 在windows中使用process模块的注意事项:必须把创建子进程的部分使用if __name__ ==‘__main__’判断保护起来 使用process模块创建进程123456# Process([group [, target [, name [, args [, kwargs]]]]])# target表示调用对象，你可以传入方法的名字# args表示被调用对象的位置参数元组，比如target是函数a，他有两个参数m，n，那么args就传入(m, n)即可# kwargs表示调用对象的字典# name是别名，相当于给这个进程取一个名字# group分组，实际上不使用 123456789101112import timefrom multiprocessing import Processdef f(name): print('hello', name) print('我是子进程')if __name__ == '__main__': p = Process(target=f, args=('leo',)) p.start() time.sleep(1) print('执行主进程的内容了') 查看进程的执行12345678910111213141516171819202122232425262728293031323334import timeimport osfrom multiprocessing import Processdef func(args,args2): print(args,args2) # print(54321) time.sleep(1) print('子进程:', os.getpid()) print('子进程的父进程:', os.getppid()) # 查看当前进程的父进程号 print(12345)if __name__ == '__main__': # 主进程(父进程)执行的 p = Process(target=func,args=('参数','参数2')) # 注册 args传参必须传元祖,里面放着参数 # p 是进程对象,此时还没有启动进程 p.start() # 开启子进程 print('*'*10) print('父进程:',os.getpid()) # 查看当前进程的进程号 print('父进程的父进程:', os.getppid()) # 查看当前进程的父进程号 在pycharm中启动就是pycharm 可以通过任务管理器查看到# 如果是同步的函数执行，会先执行完func函数在执行打印# 异步虽然要先启动子进程，但是不影响后面的代码# 进程的生命周期: # 主进程 : 从程序开启开始，直到程序执行完成 # 子进程 : 从start开始，到子进程中的代码执行完成 # 开启了子进程的主进程: # 主进程自己的代码如果长，等待自己的代码执行结束 # 子进程的执行时间长，主进程会在主进程代码执行完毕后,等待子进程执行完毕,主进程才结束# python chrom.py &amp; 终端没有关闭 进程都在后台运行# 父进程在 自己进程就在 不一定，要看怎么启动的# 子进程不一定要依赖父进程运行 123456789101112131415161718from multiprocessing import Processimport timeimport osdef func(args,args2): print('大家好,我是子进程') print(args,args2) time.sleep(3) print('子进程执行完成') print('子进程:',os.getpid()) print('子进程的父进程: ',os.getppid())if __name__ == '__main__': p = Process(target=func,args=(10,20)) # 注册 p.start() # 启动紫禁城 print('当前进程:',os.getpid()) print('当前进程的父进程: ',os.getppid()) print('*'*10) join方法 p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程12345678910111213141516171819# join()import timefrom multiprocessing import Processdef func(arg1,arg2): print('*'*arg1) time.sleep(5) print('*'*arg2)if __name__ == '__main__': p = Process(target=func, args=(10, 20)) p.start() print('这个时候还是异步的') p.join() # 作用：感知一个子进程的结束 ，异步的程序就变成同步了 print('主进程运行完成')# join 会将异步的程序变成同步 开启多个子进程,并写入文件通过join方法，让写文件的操作编程异步123456789101112131415161718192021222324252627282930313233343536373839404142434445# 多进程写文件# for 循环500个文件,没处理1个文件需要0.1秒，500个是50秒# 同步，只有一个进程处理: 0.1 * 500 = 50 # 异步，存在500个进程: 500 * 0.1 = 0.1# 1. 先往文件夹中写文件# 2. 展示写入后文件件的所有文件名# join 会将异步的程序变成同步import timeimport osfrom multiprocessing import Processdef func(filename,context): print('子进程%s开始' %(os.getpid())) with open(filename,'w') as f: f.write(str(context))# 单过在循环外只有1个join无法确定所有子进程都结束，所以需要控制if __name__ == '__main__': p_lst = [] for i in range(1,6): p = Process(target=func,args=('inod%s'%i,i)) p_lst.append(p) # 每创建出来一个进程都加入进程列表 p.start() # p.join() # 如果在循环里面join,则每循环一个进程都要等待进程的结束,会变成同步 # 如果不用join 开启进程无法保障运行的时间，所以后面的代码一起异步执行 [p.join() for p in p_lst] # 之前的所有进程必须在这里都执行完，才能执行后面的代码 # 列表推导式，先启动所有的进程，按顺序执行，在最后之前保障所有的进程对象执行完成 print('主进程%s执行完成' %(os.getpid())) print([i for i in os.walk(r'D:\PycharmProjects\Notes\08 并发编程')])# 场景:# 同时开启多个子进程，异步执行，当我需要同步执行的时候，设置一个阻拦的手段，让所有的进程在这话话都执行完成# 结果:# 子进程8332开始# 子进程4936开始# 子进程2728开始# 子进程9832开始# 子进程4428开始# 主进程9340执行完成# [('inod1', 'inod2', 'inod3', 'inod4', 'inod5'])] 开启多进程方法212345678910111213141516171819202122232425# 自定义类继承Process，实现多进程import osfrom multiprocessing import Processclass MyProcess(Process): # 自定义类继承Process def __init__(self,arg1,arg2): # 传参需要继承父类的__init__ super().__init__() # 继承父类的__init__ self.arg1 = arg1 self.arg2 = arg2 def run(self): # 实现run方法 print(self.pid) print(self.name) print(self.arg1) print(self.arg2) print('开始一个新进程%s' %os.getpid())if __name__ == '__main__': print('主进程:', os.getpid()) p1 = MyProcess(1,2) p1.start() # start 调用 run方法 p2 = MyProcess(3,4) p2.start() 123456789101112131415161718192021222324import osfrom multiprocessing import Processclass MyProcess(Process): # 自定义类继承Process def __init__(self,arg1,arg2): # 传参需要继承父类的__init__ super().__init__() # 继承父类的__init__ self.arg1 = arg1 self.arg2 = arg2 def run(self): # 实现run方法 print(self.pid) print(self.name) print(self.arg1) print(self.arg2) print('开始一个新进程%s' %os.getpid())if __name__ == '__main__': print('主进程:', os.getpid()) p1 = MyProcess(1,2) p1.start() # start 调用 run方法 p2 = MyProcess(3,4) p2.start() 多进程之间的数据隔离12345678910111213141516171819202122# 进程 与 进程之间数据是隔离的？ 是隔离的# 微信 与 QQ之间的数据能共享么？import osfrom multiprocessing import Processdef func(): global n # 全局变量n n = 0 # 重新定义n print('子进程 : %s' %os.getpid(),n)if __name__ == '__main__': print('主进程',os.getpid()) n = 100 p = Process(target=func) p.start() p.join() # 等待子进程 结束完 print('主进程',n) # 主进程打印的n 和 子进程不一样 ，多进程之间数据有隔离# 运行结果# 主进程pid: 5748# 子进程pid: 6048 0# 主进程 100 守护进程1234567891011121314151617181920212223242526272829# 特点: 会随着主进程的结束而结束。# 主进程创建守护进程 # 其一：守护进程会在主进程代码执行结束后就终止 # 其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children# 注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止import timefrom multiprocessing import Processdef func(): while True: time.sleep(0.2) print('我还活着') # 每隔0.5秒 说下进程状态if __name__ == '__main__': p = Process(target=func) p.daemon = True # 设置子进程为守护进程 p.start() i = 0 while i &lt; 5: print('我是socket server') time.sleep(1) i += 1# 守护进程 会随着 主进程的代码执行完毕 而结束 12345678910111213141516171819202122232425262728293031323334353637383940414243# 守护进程# 子进程 转换成 守护进程# 守护进程 子进程随着主进程 一起结束import timefrom multiprocessing import Processdef func(): while True: time.sleep(0.2) print('我还活着') # 每隔0.5秒 说下进程状态def func2(): print('in func2 开始') time.sleep(8) print('in func2 结束')if __name__ == '__main__': p = Process(target=func) p.daemon = True # 设置子进程为守护进程 p.start() p2 = Process(target=func2) # 另外一个子进程 p2.start() p2.terminate() # 结束一个进程 print(p2.is_alive()) # 检查进程是否还活着 time.sleep(2) print(p2.is_alive()) print(p2.name) # i = 0 # while i &lt; 5: # print('我是socket server') # time.sleep(1) # i += 1# 守护进程 会随着 主进程的代码执行完毕 而结束# 在主进程内结束进程 p2.terminate()# 结束一个进程不是在执行方法之后立即生效，需要一个操作系统响应的过程# 检验进程是否活着的状态 p2.is_alive()# p.name p.pid 进程名 和 进程号 多进程中的方法和属性1234567891011121314151617181920212223242526272829import randomimport timefrom multiprocessing import Processclass MyProcess(Process): def __init__(self,user): super().__init__() self.user = user def run(self): print('子进程 %s 的 pid %s' %(self.name,self.pid)) print('%s 开始执行子进程'%self.user) time.sleep(random.randrange(1,5)) print('%s 子进程完成' %(self.user))if __name__ == '__main__': p1 = MyProcess(user='leo') p1.start() p1.terminate() # 关闭进程,不会立即关闭,所以is_alive立刻查看的结果可能还是存活 print(p1.is_alive()) # True time.sleep(1) print(p1.is_alive()) # False # self.name 属性是Process中的属性，标示进程的名字 # super().__init__() # 执行父类的初始化方法会覆盖name属性 # self.pid 查看id # p1.terminate() 关闭进程 # p1.is_alive() 查看进程是否存活 socket聊天并发实例123456789101112131415161718192021222324# serverimport socketfrom multiprocessing import Processdef server(conn): # ret = input('&gt;&gt;&gt;').encode('utf-8') ret = '你好'.encode('utf-8') conn.send(ret) msg = conn.recv(1024).decode('utf-8') print(msg) conn.close()if __name__ == '__main__': sk = socket.socket() sk.bind(('127.0.0.1',8090)) sk.listen() while True: conn,addr = sk.accept() # 拿到链接 放到多进程 每个链接都执行 p = Process(target=server,args=(conn,)) p.start() sk.close() 1234567891011# clientimport socketsk = socket.socket()sk.connect(('127.0.0.1',8090))msg = sk.recv(1024).decode('utf-8')print(msg)msg2 = input('&gt;&gt;&gt;').encode('utf-8')sk.send(msg2)sk.close() 进程同步 —— 锁、信号量和事件重要程度:Lock(加锁，同一时间1个进程执行) 锁 —— multiprocess.Lock加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。虽然可以用文件共享数据实现进程间通信，但问题是：1.效率低（共享数据基于文件，而文件是硬盘上的数据）2.需要自己加锁处理12345678910111213141516171819202122232425262728293031323334353637383940414243from multiprocessing import Processfrom multiprocessing import Lock # 进程锁import jsonimport osimport timedef show(i): # 查票读取ticket文件 with open('ticket',mode='r') as f: dic = json.load(f) print('子进程%s,余票:%s'%(os.getpid(),dic['ticket']))def buy_ticket(i,lock): lock.acquire() # 拿钥匙进门 被拿走后 别的进程会在这里阻塞，直到钥匙被还 with open('ticket') as f: dic = json.load(f) time.sleep(0.1) if dic['ticket'] &gt; 0: dic['ticket'] -= 1 print('\033[32m%s 买到票了\033[0m' %i) else: print('\033[31m%s 没买到票\033[0m' %i) time.sleep(0.1) with open('ticket',mode='w') as f: # 修改票结果 json.dump(dic,f) lock.release() # 还钥匙，已经买完票了if __name__ == '__main__': for i in range(10): # 假装有10个人抢票 p = Process(target=show,args=(i,)) p.start() lock = Lock() for i in range(10): p = Process(target=buy_ticket,args=(i,lock)) p.start()# 给某一段代码加上锁 这段代码在这一段时间内只能让一个进程执行# 只要多人同时操作一个数据 就会出现数据安全问题，需要牺牲效率 保证数据安全# &#123;"ticket": 1&#125; 信号量 —— multiprocess.Semaphore1234567891011121314151617181920212223242526272829303132333435363738394041424344# 多进程中的组件 # 同步控制 # 进程间通信 # 进程间的数据共享 # 进程池# ktv 有4个门 20个人同时进出,现在要控制4个人先进# 一套资源 同一时间 只能被N个人访问# 某一段代码 在同一时间 只能被n个进程执行import timeimport randomfrom multiprocessing import Processfrom multiprocessing import Semaphoredef ktv(i,sem): sem.acquire() # 获取钥匙 print('%i 走进KTV' %i) time.sleep(random.randint(10,20)) # 模拟唱歌 1-5秒 print('%i 走出KTV' %i) sem.release() # 还钥匙if __name__ == '__main__': sem = Semaphore(4) # 实例化4把钥匙 for i in range(20): p = Process(target=ktv,args=(i,sem)) p.start()# 限定进程访问的代码 同一时间只能有几个进程来访问# 开一个们 有4把要是 前4个进程进去后 门就观赏了 直到某一个进程出来还钥匙，第5个进程获取进入# lock只有一把钥匙# 信号量有N把钥匙# 结果:# 3 走进KTV# 0 走进KTV# 8 走进KTV# 7 走进KTV# ...同一时间只有4个人# 8 走出KTV# 4 走进KTV# 3 走出KTV# 12 走进KTV 事件 —— multiprocess.Event1234567891011121314151617181920212223242526# 通过一个信号 来控制 多个进程 同时执行或者阻塞# 事件from multiprocessing import Event# 一个信号 可以使所有的进程都进入阻塞状态# 也可以控制 所有的进程 解除阻塞# 一个事件 被创建之后，默认是阻塞状态e = Event() # 创建了一个事件print(e.is_set() ) # 查看一个事件的状态 # Falsee.set() # 将这个时间的状态改为Trueprint(e.is_set() ) # Truee.wait() # 是依据e.is_set()的值，来决定是否阻塞,如果是False就阻塞,True就是不阻塞print(123456) # 正常打印e.clear() # 将事件状态改成falseprint(e.is_set()) # Falsee.wait() # 阻塞print('123456') # 不打印# set 和 clear # 分别用来修改一个事件的状态：True / False# is_set # 用来查看一个事件的状态# wait # 依据事件的状态来决定自己是否阻塞 True:不阻塞，False:阻塞 1234567891011121314151617181920212223242526272829303132# 红绿灯事件# 两个进程，车怎么才能感知到灯？import timeimport randomfrom multiprocessing import Eventfrom multiprocessing import Processdef car(e,i): if not e.is_set(): print('car%s 等红灯'%i) e.wait() # 阻塞,直到得到一个事件状态改变，编程True的信号 print('\033[0;32;40mcar%s 通过\033[0m' %i)def light(e): while True: if e.is_set(): # Ture e.clear() # False print('\033[31m红灯亮了\033[0m') else: e.set() # True print('\033[32m绿灯亮了\033[0m') time.sleep(2)if __name__ == '__main__': e = Event() p = Process(target=light,args=(e,)) p.start() for i in range(20): cars = Process(target=car,args=(e,i)) cars.start() time.sleep(random.random()) # 0 - 1秒 进程间的通信 —— 队列和管道进程间通信:IPC(Inter-Process Communication) 队列 multiprocessing.Queue1234567891011121314151617181920212223242526# 队列 先进先出import timefrom multiprocessing import Queueq = Queue(5)# for i in range(6): # 0 - 5 超过队列大小了 会阻塞# q.put(i)q.put(1)q.put(2)q.put(3)q.put(4)q.put(5)print(q.full()) # True 队列是否满了print(q.get()) # 1print(q.get()) # 2print(q.get()) # 3print(q.get()) # 4print(q.get()) # 5print(q.empty()) # True 队列是否空while True: try: q.get_nowait() except: print('队列已空') time.sleep(1)# 放到满 和 空了再取值 都会阻塞 生产者与消费者模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 队列# 生产者与消费者模型:# 买包子# 蒸包子 # 买包子# 生产数据 # 消费数据# 爬虫 爬500个网页 生产数据快 ——&gt; 放到内存里 # 处理爬虫 处理数据 慢# 1、容器满了就不允许再放# 2、增加处理进程# 3、如果爬取数据慢，比如网络延迟或者需要验证破解,那么增加生产者,解决数据供需不平衡# 生产者 进程# 消费者 进程import timeimport randomimport osfrom multiprocessing import Queuefrom multiprocessing import Process# 消费者def consumer(q,name): # 数据一直处理 while True: food = q.get() if food is None: # 当获取到空了说明生产者完成了所有生产 print('%s 获取到空了' %name) break print('\033[31m%s消费了%s\033[0m' % (name,food)) time.sleep(random.randint(1,3))# 生产者def producer(name,food,q): for i in range(5): time.sleep(random.randint(1,3)) f = '%s生产了%s%s' %(name,food,i) print(f,os.getpid()) q.put(f) # 放到队列中if __name__ == '__main__': q = Queue(20) pro1 = Process(target=producer,args=('小红','包子',q)) pro2 = Process(target=producer,args=('小兰','汽水',q)) c1 = Process(target=consumer,args=(q,'小黑')) c2 = Process(target=consumer,args=(q,'小金')) pro1.start() pro2.start() c1.start() c2.start() pro1.join() pro2.join() q.put(None) # 等生产者都生产完毕后 放入一个空值 q.put(None) # 等生产者都生产完毕后 放入一个空值# Queue 是进程安全的，在队列里的数据只能被一个进程取走# 三个不同的进程 有可能在同一个时间去队列取值，这样是不安全的# None被其中一个进程取走，另外一个并没有拿到，所以会阻塞 JoinableQueue队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import timeimport osimport randomfrom multiprocessing import Processfrom multiprocessing import JoinableQueue# 消费者def consumer(q,name): # 数据一直处理 while True: food = q.get() if food is None: # 当获取到空了说明生产者完成了所有生产 print('%s 获取到空了' %name) break print('\033[31m%s消费了%s\033[0m' % (name,food)) time.sleep(random.randint(1,3)) q.task_done() # count - 1 ,直到队列中的所有数据都执行了task_done# 生产者def producer(name,food,q): for i in range(5): time.sleep(random.randint(1,3)) f = '%s生产了%s%s' %(name,food,i) print(f,os.getpid()) q.put(f) # 放到队列中 count + 1 1.,20 q.join() # 阻塞，直到一听歌队列中的所有数据 全部被处理完毕,这个进程才结束if __name__ == '__main__': q = JoinableQueue(20) pro1 = Process(target=producer,args=('小红','包子',q)) pro2 = Process(target=producer,args=('小兰','汽水',q)) c1 = Process(target=consumer,args=(q,'小黑')) c2 = Process(target=consumer,args=(q,'小金')) pro1.start() pro2.start() c1.daemon = True # 主进程中的代码执行完毕后 该守护进程结束 进程结束了 q.get()也不会阻塞了。 c2.daemon = True c1.start() c2.start() pro1.join() # 感知一个进程的结束 pro2.join() # 生产进程 q.join()结束，需要等待消费者都处理完才能结束# JoinableQueue 比 Queue多了两个方法# 1、获取数据要提交回执 q.task_done() q.join()# c1.daemon = True 守护进程 主进程中的代码执行完毕后 该守护进程结束# 在消费者这一端: # 每次获取一个数据 # 处理一个数据 # 发送一个记号：标志一个数据被处理成功# 在生产者这一端: # 每一次生产一个数据 # 且每一次生产的数据都放在队列里 # 在队列中刻上一个记号 # 当生产者全部生产完毕之后 # join信号:已经停止生产数据,且要等待之前被刻上的记号都被消费完 # 当数据都被处理完事，join阻塞结束# consumer 把所有的任务消耗完# producer 端的join感知到，停止阻塞# 所有的producer 进程结束# 主进程中的p.join结束# 主进程的代码结束# 守护进程(c1,c2消费者进程)结束 管道 multiprocessing.Pipe作用：在进程之间通信 123456789from multiprocessing import Pipe,Processdef func(conn): conn.send('吃了么')if __name__ == '__main__': conn1,conn2 = Pipe() p = Process(target=func,args=(conn1,)) p.start() print(conn2.recv()) 123456789101112131415# 发送多条消息from multiprocessing import Pipe,Processdef func(conn): while True: msg = conn.recv() if msg is None: break print(msg)if __name__ == '__main__': conn1,conn2 = Pipe() p = Process(target=func,args=(conn1,)) p.start() for i in range(20): conn2.send('吃了么%s' %i) conn2.send(None) 1234567891011121314151617181920# 作为两端通信# conn2发送,conn1接收def func(conn1,conn2): conn2.close() while True: try: msg = conn1.recv() print(msg) except EOFError: # 没有数据仍然recv的时候报错 conn1.close() breakif __name__ == '__main__': conn1,conn2 = Pipe() p = Process(target=func,args=(conn1,conn2)) p.start() conn1.close() for i in range(20): conn2.send('吃了么%s' %i) conn2.close() # 主进程两边都关闭 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import timeimport randomfrom multiprocessing import Pipefrom multiprocessing import Processfrom multiprocessing import Lockdef producer(con,pro,name,food): con.close() # 用不到消费者管道 for i in range(6): time.sleep(random.randint(1,3)) f = '%s生产%s %s' %(name,food,i) print(f) pro.send(f) # 生产放入管道 pro.close() # 生产完成后关闭管道def consumer(con,pro,name,lock): pro.close() while True: try: lock.acquire() food = con.recv() # 从管道拿产品 lock.release() print('%s 购买了 %s' %(name,food)) time.sleep(random.randint(1,3)) except EOFError: con.close() breakif __name__ == '__main__': con,pro = Pipe() # 生产者和消费者的管道 lock = Lock() # 加锁 p = Process(target=producer,args=(con,pro,'rubin','汽水')) p.start() c1 = Process(target=consumer,args=(con,pro,'leo',lock)) c1.start() c2 = Process(target=consumer,args=(con,pro,'lex',lock)) c2.start() con.close() pro.close()# pipe 数据不安全性# 生产者 消费者1 1个放1个取# 生产者 消费者1、2 1个放2个取 其他消费也来抢占数据,数据在管道中是混乱的,没被拿走之前，消费者都可以来申请# 多个消费者同时取一个数据，数据不安全# 管道是进程数据不安全的，解决方式：加锁# 队列是进程之间数据安全的，因为队里基于管道+锁 实现的,所以之后会更多使用队列 进程之间的数据共享 multiprocessing.Manager 基于消息传递的并发编程是大势所趋 即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合，通过消息队列交换数据。 这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中。 但进程间应该尽量避免通信，即便需要通信，也应该选择进程安全的工具来避免加锁带来的问题。 以后我们会尝试使用数据库来解决现在进程之间的数据共享问题。 进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的 虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此 12345678910111213141516# 进程之间的数据共享from multiprocessing import Manager,Process,Lockdef func(dic): dic['count'] -= 1 print(dic)if __name__ == '__main__': m = Manager() print(m) # &lt;multiprocessing.managers.SyncManager object at 0x0000000001D7A3C8&gt; dic = m.dict(&#123;'count':100&#125;) # dic会变成数据共享的字典 p_lst = [] p = Process(target=func, args=(dic,)) p.start() p.join() print('主进程:',dic) 1234567891011121314151617181920212223242526def func(dic,lock): lock.acquire() dic['count'] -= 1 lock.release() # print(dic)if __name__ == '__main__': m = Manager() lock = Lock() # 不加锁而操作共享的数据,肯定会出现数据错乱 # print(m) # &lt;multiprocessing.managers.SyncManager object at 0x0000000001D7A3C8&gt; dic = m.dict(&#123;'count':100&#125;) # dic会变成数据共享的字典 p_lst = [] for i in range(50): p = Process(target=func, args=(dic,lock)) p.start() p_lst.append(p) [ i.join() for i in p_lst ] # 等待所以子进程都结束 print('主进程:',dic)# 总结# 进程同步控制：锁、信号量、事件 -- 控制进程怎么执行，能不能一起执行，几个一起执行，什么时候一起执行 -- 控制# 进程间通信：队列和管道 -- 通信# 进程间数据共享: Manager -- 共享# 以后真正会用到的只有，进程控制，通信方面只用队列,# 未来使用 -- kafak,rabbitmq memcache (消息中间件) kafak(大数据消息中间件,会保留数据)# 进程服务器(多台) --&gt; 服务器(memcache) 进程池 Poolmultiprocessing.Pool为什么要有进程池?进程池的概念。 创建进程需要消耗时间，销毁进程也需要消耗时间。不能无限制的根据任务开启或者结束进程。 进程池的概念:定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。 Pool([numprocess [,initializer [, initargs]]]):创建进程池1234# 参数介绍:# 1 numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值# 2 initializer：是每个工作进程启动时要执行的可调用对象，默认为None# 3 initargs：是要传给initializer的参数组 map()方法 进程池和进程效率测试1234567891011121314151617181920212223242526272829# 为什么会有进程池的概念 # 提高效率 # 1、每次开启进程，都需要创建一个新的属于这个进程的内存空间，耗时 # 寄存器 堆栈 都是存储代码和变量的 # 2、进程过多，造成操作系统调度，切换过程较多 # 进程不能无限制的开放，而是需要进程池# 进程池 # python:在还没有启动程序之前，先创建一个属于进程的池子 # 这个池子指定能存放多少个进程 # 先将这些进程创建好 # 有50个任务，池子里有5个进程，任务需要排队，按顺序先执行5个任务，结束后不消失回到进程池里接收新的任务，后面依次执行 # 现象：同一时间操作系统中，只执行了这5个进程，减少了进程开销，使5个进程的内存空间循环被利用 # 信号量，同一时间N个进程执行 ,有点像进程池,区别是信号量多个进程排队，在等着执行一段代码，实际上信号量有N个进程被创建了。 # 一个是进程排队，一个是任务排队。 # 进程池既减少了操作系统的调度,且减少了进程开销。# 高级进程池(弹性伸缩) # python中没有 # n,m 上限和下限 # 3 三个进程 # 用户量增多,+1进程，一直加到上线m 20个,最多到20个 # 当任务不断减少的时候，再减到3个进程 # 好处：有效的介绍操作系统负担，减少进程# 开启进程的个数 # CPU核数 + 1 = 进程开启个数 1234567891011121314151617181920212223242526272829303132333435# 使用进程池import timefrom multiprocessing import Pool,Process# Process 超过5个进程,需要使用进程池def func(n): for i in range(10): print(n + 1)def func2(n): print(n) # ('leo', 1) # rubinif __name__ == '__main__': start = time.time() pool = Pool(5) # 5个进程 # pool.map(func,range(100)) # 100个任务 （方法名,可迭代类型）map方法自带join() pool.map(func2,[('leo',1),'rubin']) # 第二个任务 t1 = time.time() - start # 启100个进程 start = time.time() p_lst = [] for i in range(100): p = Process(target=func,args=(i,)) p_lst.append(p) p.start() for i in p_lst:i.join() t2 = time.time() - start print(t1,t2) # 0.21701264381408691 3.6672096252441406 开启100个进程 并没有5个进程交替执行的快# 进程池提高了执行效率 进程池中的同步和异步调用1234567891011121314151617181920212223242526272829# 进程池的同步调用import timeimport randomimport osfrom multiprocessing import Pooldef func(n): print('start func %s' %n,os.getpid()) time.sleep(1) print('end func %s' %n,os.getpid())if __name__ == '__main__': pool = Pool(5) for i in range(10): # pool.apply(func,args=(i,)) # apply同步提交任务 (方法,参数) pool.apply_async(func,args=(i,)) # apply_async 异步提交任务 async在python就代表着异步 # 真异步，主进程执行完了，不等待子进程 pool.close() # 结束进程池接收任务 pool.join() # 感知进程池中的任务执行结束# start func 0 8572# start func 1 6000# start func 2 1208# start func 3 10492# start func 4 9232 # end func 0 8572# start func 5 8572# ... 123456789101112131415161718192021222324252627282930313233# 使用进程池创建socket_server# serverimport socketfrom multiprocessing import Pooldef func(conn): conn.send(b'hello') print(conn.recv(1024).decode('utf-8')) conn.close()if __name__ == '__main__': pool = Pool(5) sk = socket.socket() sk.bind(('127.0.0.1',8080)) sk.listen() while True: conn,addr = sk.accept() pool.apply_async(func,args=(conn,)) sk.close()# clientimport socketsk = socket.socket()sk.connect(('127.0.0.1',8080))ret =sk.recv(1024).decode('utf-8')print(ret)msg = input('&gt;&gt;&gt;').encode('utf-8')sk.send(msg)sk.close() 进程池的返回值12345678import requestsimport timefrom multiprocessing import Pool# p = Pool()# p.map(funcname,iterable) 默认异步的执行任务,且自带close和join# p.apply 同步调用# p.apply_async 异步调用 和 主进程 完全异步,主进程结束不会等待子进程,需要手动close和join 12345678910111213141516171819# 进程池的返回值# 进程池特有的# 使用队列实现def func(i): time.sleep(0.5) return i*iif __name__ == '__main__': p = Pool(5) res_l = [] for i in range(10): # res = p.apply(func,args=(i,)) # apply的结果就是func的返回值 # print(res) res = p.apply_async(func,args=(i,)) # 异步提交 # print(res.get()) # res进程的对象 get会阻塞等待结果,等着func的结算结果 res_l.append(res) for res in res_l:print(res.get()) # 一次获取5个结果 123456789101112131415# mapdef func(i): time.sleep(0.5) return i*iif __name__ == '__main__': p = Pool(5) ret = p.map(func,range(10)) # map自带join和close print(ret) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 任务都运行完毕后 返回一个列表# map 和 apply，apply_async的区别:# apply_async : 5个5个打印# apply : 一次返回# map : 任务计算完,返回一个列表# 任务很多 使用 apply_async更好 不用等都执行完，拿到结果更快 回调函数 callback123456789101112131415161718192021222324252627import osfrom multiprocessing import Pooldef func1(n): print('in func1',os.getpid()) return n*ndef func2(nn): print('in func2',os.getpid()) print(nn)if __name__ == '__main__': p = Pool(5) print('主进程pid: ',os.getpid()) for i in range(10): p.apply_async(func1,args=(10,),callback=func2) p.close() p.join()# in func1# in func2# 100# 1、执行func1 他的返回值 作为回调函数的参数# 2、执行回调函数 func2# 3、回调函数不传参数,他的参数只能是func1的返回值# 4、回调函数在主进程中执行 回调函数 – 爬虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import requestsfrom multiprocessing import Pool# response = requests.get('https://maoyan.com/board/4')# print(response) # 网页结果对象# # print(response.__dict__)# print(response.status_code) # 200# print(response.text)# 爬虫# 耗时最长 网络延迟# 1、访问网址# 2、将数据从网址上下载下来 urllib * 耗时最长 发送请求，拿到代码，接收代码# 3、数据就是bytes 转成 字符串# 4、处理字符串# 5个进程,任务是200个（访问200个）# 同时跑5个进程,一起享受网络延迟,如果在这个时候处理字符串，那么195个进程都在排队# 如果处理交给主进程来做，这5个进程的处理字符串,那么可以省出5个进程继续下载网页# - 下载网页1# - 下载网页2# - 下载网页3# - 下载网页4# - 下载网页5# ----- 处理字符串# 一般情况下,爬虫的时候，容易用到回调函数# 访问网页，爬取网页的过程用爬虫# 处理数据，使用回调函数# 流程:# 多进程去访问页面，拿到结果,返回url和页面内容# 回调函数打印url和网页内容长度# 使用进程池下载页面# 子进程处理下载页面def get_page(url): res = requests.get(url) if res.status_code == 200 : return url,res.text# 回调函数，接收网页内容# 打印页面内容长度def call_back(args): url,content = args print(url,len(content))if __name__ == '__main__': url_lst = [ 'https://www.baidu.com', 'https://www.sogou.com', 'http://www.sohu.com/', 'https://maoyan.com/board/4', ] p = Pool(5) for url in url_lst: p.apply_async(get_page,args=(url,),callback=call_back) p.close() p.join()# https://www.sogou.com 23447# https://www.baidu.com 2443# http://www.sohu.com/ 180835# https://maoyan.com/board/4 20754]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix自定义脚本监控redis]]></title>
    <url>%2F2019%2F04%2F02%2Fpro2%2F</url>
    <content type="text"><![CDATA[编写监控redis qps 脚本结合zabbix展示之前公司的redis info显示执行了6亿次命令，造成cpu过高问题，现写下shell采集redis执行命令次数和ops然后通过zabbix做监控 监控脚本123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bashREDISCLI="/usr/local/bin/redis-cli"HOST="127.0.0.1"PORT=7007PASS="redis_pwd"if [[ $# == 1 ]];then case $1 in version) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info server | grep -w "redis_version" | awk -F':' '&#123;print $2&#125;'` echo $result ;; connected_clients) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info clients | grep -w "connected_clients" | awk -F':' '&#123;print $2&#125;'` echo $result ;; instantaneous_ops_per_sec) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info Stats | grep -w "instantaneous_ops_per_sec" | awk -F':' '&#123;print $2&#125;'` echo $result ;; total_commands_processed) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info Stats | grep -w "total_commands_processed" | awk -F':' '&#123;print $2&#125;'` echo $result ;; *) echo -e "\033[33mUsage: $0 &#123;version&#125;\033[0m" ;; esacelif [[ $# == 2 ]];then case $2 in keys) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info | grep -w "$1" | grep -w "keys" | awk -F'=|,' '&#123;print $2&#125;'` echo $result ;; *) echo -e "33[33mUsage: $0 &#123;db0 keys|db0 expires|db0 avg_ttl&#125;33[0m" ;; esacfi 在本地做测试1234[work@scripts]$ sh /data/backup/zabbix/scripts/redis_status_7007.sh total_commands_processed11958[work@scripts]$ sh /data/backup/zabbix/scripts/redis_status_7007.sh instantaneous_ops_per_sec0 修改zabbix_agent配置文件1234567vim /etc/zabbix/zabbix_agentd.confInclude=/etc/zabbix/zabbix_agentd.d/ # 简易脚本的执行目录...# 自定义脚本执行UserParameter=Redis_7007.Info[*],/data/backup/zabbix/scripts/redis_status_7007.sh $1 $2UserParameter=Redis_7010.Info[*],/data/backup/zabbix/scripts/redis_status_7010.sh $1 $2 重启zabbix agent服务1sudo /etc/init.d/zabbix-agent restart 在zabbix server端通过get测试12[work@scripts]$ zabbix_get -s 内网监控IP -p 10050 -k "Redis_7007.Info[total_commands_processed]"12051 12[work@scripts]$ zabbix_get -s 内网监控IP -p 10050 -k "Redis_7007.Info[instantaneous_ops_per_sec]"0 在zabbix平台配置监控项和触发器]]></content>
      <categories>
        <category>Linux运维</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看java进程占用cpu过高]]></title>
    <url>%2F2019%2F04%2F01%2Fpro1%2F</url>
    <content type="text"><![CDATA[查看java进程占用cpu过高之前平台出现过一次java进程占用cpu 100%的问题，发现后排查的几率如下: 使用top查找哪个继承占用cpu过高 记录下进程如:14492 把进程的栈dump到文件里，以便后面的分析 1jstack 14492 &gt; cpu0401.log 看看这个进程里面哪些线程在占用cpu 1top -p 14492 -H # 选择占用最高的 PID=5159 接着要看刚才dump出来的cpu日志了，里面会有14492这个进程下面每个线程的栈信息，但是是十六进制显示的，所以先把5159转换成16进制 1printf %0x 5159 # 1427 在cpu日志里找PID=1427的线程 1vim cpu0401.log]]></content>
      <categories>
        <category>Linux运维</category>
      </categories>
      <tags>
        <tag>进程占用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket 网络编程]]></title>
    <url>%2F2019%2F03%2F26%2Fsocket-server%2F</url>
    <content type="text"><![CDATA[tcp协议 和 udp协议TCP（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；电子邮件、文件传输程序。 UDP（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。 socket的基本使用TCP 的socket — 基础对话版12345678910111213141516171819# server端import socketsk = socket.socket() # 创建套接字sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) # 避免重用ip和端口sk.bind(('127.0.0.1',8090)) # 绑定端口sk.listen() # 监听链接conn,addr = sk.accept() # 接收客户端链接ret = conn.recv(1024) # 接收客户端消息print(ret) # 打印客户端消息conn.send(b'hello') # 向客户端发送消息 在网络上传输的只有二进制1010,所以必须是bytes类型ret = conn.recv(1024).decode('utf-8')print(ret)conn.send('吃面条吧'.encode('utf-8'))conn.close() # 关闭客户端链接sk.close() # 关闭服务端 123456789101112131415# client端import socketsk = socket.socket() # 创建客户端套接字sk.connect(('127.0.0.1',8090)) # 链接服务端# 接收|发送消息sk.send(b'hey') # 发送消息ret = sk.recv(1024) # 接收消息print(ret)sk.send('中午吃什么'.encode('utf-8'))ret = sk.recv(1024).decode('utf-8')print(ret)sk.close() 循环对话版12345678910111213141516171819202122232425262728# server端import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端开始监听...')conn,addr = sk.accept() # 获取到一个客户端的链接，已经完成了三次握手建立了一个连接 # 阻塞print('有新的链接进入&#123;&#125;'.format(addr))# 对话while 1: ret = conn.recv(1024).decode('utf-8') # 阻塞，直到收到客户端发来的消息 print(ret) if ret == 'bye': conn.send('bye'.encode('utf-8')) break msg = input('server:&gt;&gt;&gt;') if msg == 'bye': conn.send('bye'.encode('utf-8')) break conn.send(msg.encode('utf-8'))conn.close()sk.close() 1234567891011121314151617# client端import socketsk = socket.socket()sk.connect(('127.0.0.1',8090))while True: msg = input('client:&gt;&gt;&gt;') if msg == 'bye': sk.send('bye'.encode('utf-8')) break sk.send(msg.encode('utf-8')) ret = sk.recv(1024).decode('utf-8') if ret == 'bye': break print(ret)sk.close() 时间戳转换1234567891011121314151617181920212223242526272829303132ip_port = ('127.0.0.1',8090)# server端# server 接收时间戳时间，转化成格式化时间# client 每10秒time.time() 吧时间戳时间发给serverimport sysimport ossys.path.insert(0,os.path.dirname(os.getcwd()))import socketimport timefrom conf import settingssk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(settings.ip_port)sk.listen()print('服务端开始监听...')conn,addr = sk.accept()print('有新的链接进入&#123;&#125;'.format(addr))# 收发消息while 1: res = conn.recv(1024).decode('utf-8') if res == '': break print('client:%s' %res) msg = time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(float(res))) print(type(msg),msg) conn.send(('server:%s' %msg).encode('utf-8'))conn.close()sk.close() 12345678910111213141516171819202122# client端import timeimport socket# msg = time.time()# print(type(msg),msg) # float类型sk = socket.socket()sk.connect(('127.0.0.1',8090))count = 1while 1: if count &gt; 3: break now_time = str(time.time()) print(now_time) sk.send(now_time.encode('utf-8')) ret = sk.recv(1024).decode('utf-8') print(ret) time.sleep(3) count += 1sk.close() UDP 的socket — 基础对话版1234567891011# server import socketsk = socket.socket(type=socket.SOCK_DGRAM) # 创建一个服务器的套接字sk.bind(('127.0.0.1',8090)) # 绑定服务器套接字# 对话(接收与发送)msg,addr = sk.recvfrom(1024)print(msg.decode('utf-8'))sk.sendto(b'bye',addr) # 发送消息要带着地址sk.close() # 关闭服务器套接字 1234567891011# clientimport socketip_port = ('127.0.0.1',8090)sk = socket.socket(type=socket.SOCK_DGRAM)# 对话(接收与发送)sk.sendto(b'hello',ip_port) # 发送消息要带着地址ret,addr = sk.recvfrom(1024)print(ret.decode('utf-8'))sk.close() 在udp的消息通信的时候: 不需要进行监听 (listen) 不需要建立链接 (accept) 在启动服务之后，只能被动的等到客户端发送消息过来 客户端发送消息的同时，还会带着地址信息过来 服务端进行消息服务的时候，不仅需要发送消息，还需要带着对方的地址回去 UDP 实现简易QQ1234567891011121314151617# server import socketudp_sk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)udp_sk.bind(ip_port)print('Bind UDP on 9999...')while True: # 接收数据: data,addr = udp_sk.recvfrom(1024) data = data.decode('utf-8') print(('Received from %s:%s') %(addr,data)) msg = input('server:&gt;&gt;&gt;') udp_sk.sendto(msg.encode('utf-8'),addr)udp_sk.close() 123456789101112131415# client import socketip_port = ('127.0.0.1',9999)udp_sk = socket.socket(type=socket.SOCK_DGRAM)while True: msg = input('client:&gt;&gt;&gt;') msg = '\033[32mform client1:%s\033[0m' %msg udp_sk.sendto(msg.encode('utf-8'),ip_port) data,addr = udp_sk.recvfrom(1024) data = data.decode('utf-8') print(('Received from %s:%s') %(addr,data))udp_sk.close() UDP 实现简易时间同步123456789101112131415161718192021222324# server # server端提供时间同步服务# 接收信息 时间的格式# 将server端时间 转换成 接收到的格式# 返回给clientimport socketimport timesk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)sk.bind(ip_port)print('Bind UDP on 9999...')while True: data,addr = sk.recvfrom(1024) data = data.decode('utf-8') # print(type(data),data) print('form %s:%s' %(addr,data)) # time_str = time.strftime(data,time.localtime(time.time())) time_str = time.strftime(data) print(type(time_str),time_str) sk.sendto(str(time_str).encode('utf-8'),addr)sk.close() 1234567891011121314151617# client import socketsk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)time_format = '%Y-%m-%d %H:%M:%S'sk.sendto(time_format.encode('utf-8'),ip_port)data,addr = sk.recvfrom(1024)data = data.decode('utf-8')print(data)sk.close()# 操作方式:# 1、操作系统定时任务 + python代码# 2、while True + time.sleep 黏包现象subprocess 远程执行命令12345678import subprocessres = subprocess.Popen('dir',shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)print('stdout:' + res.stdout.read().decode('gbk')) # windows默认控制台输出 gbkprint('stderr:' + res.stderr.read().decode('gbk')) # windows默认控制台输出 gbk# stdout=subprocess.PIPE 标准输出放入管道# stderr=subprocess.PIPE 错误输出放入管道# 结果的编码是以当前所在的系统为准的，如果是windows，那么res.stdout.read()读出的就是GBK编码的，在接收端需要用GBK解码 TCP的黏包现象12345678910111213141516171819202122232425# 在server端下发命令import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务器端口8090开始监听')conn,addr = sk.accept()print('有新的链接请求&#123;&#125;'.format(addr))while 1: cmd = input('cmd:&gt;&gt;&gt;') conn.send(cmd.encode('utf-8')) ret = conn.recv(1024).decode('utf-8') # windows控制台是GBK print(ret)conn.close()sk.close()# 执行的命令# 1. dir;ls# 2. ipconfig# 发生的问题:# 象数据没有接收完全 或者 接收多了 这种现象就是“黏包” 12345678910111213141516171819202122# 在client端接收命令并执行返回import socketimport subprocesssk = socket.socket()sk.connect(('127.0.0.1',8090))while True: cmd = sk.recv(1024).decode('gbk') res = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) # print('stdout:' + res.stdout.read().decode('gbk')) # windows默认控制台输出 gbk # print('stderr:' + res.stderr.read().decode('gbk')) # windows默认控制台输出 gbk # 这里的res得到的是gbk格式，需要解码整体转换成str std_out = 'stdout: ' + (res.stdout.read()).decode('gbk') std_err = 'stderr: ' + (res.stderr.read()).decode('gbk') print(type(std_out),std_out) print(type(std_err),std_err) sk.send(std_out.encode('utf-8')) sk.send(std_err.encode('utf-8'))sk.close() UDP的黏包现象12345678910111213141516171819202122232425262728293031# serverimport socketsk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)sk.bind(ip_port)print('Bind UDP on 9999...')data,addr = sk.recvfrom(1024)while 1: cmd = input('cmd:&gt;&gt;&gt;') if cmd == 'q': break sk.sendto(cmd.encode('utf-8'),addr) data,addr = sk.recvfrom(10240) print(data.decode('utf-8'))sk.close()# 操作：# 1. ipconfig# 2. dir# udp# udp不会黏包# udp会丢包# tcp# tcp会黏包# tcp不会丢包# 内部优化算法 让整个程序发送数据和接收数据没有边界 12345678910111213141516171819202122# clientimport socketimport subprocesssk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)sk.sendto('吃了吗？'.encode('utf-8'),ip_port)while 1: cmd,addr = sk.recvfrom(1024) # bytes if cmd == 'q': break res = subprocess.Popen(cmd.decode('gbk'),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) std_out = 'std_out:' + res.stdout.read().decode('gbk') std_err = 'std_err:' + res.stderr.read().decode('gbk') print(std_out) print(std_err) sk.sendto(std_out.encode('utf-8'),addr) sk.sendto(std_err.encode('utf-8'),addr)sk.close() 触发黏包会发生黏包的两种情况 发送方的缓存机制发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据很小，会合到一起，产生粘包） 123456789101112131415161718# server# 1. server 先把数据给操作,操作系统再传给对面的操作系统# 2. client 操作系统把接收到的消息 给client程序# 3. 如果发送了10个数据 由于第一次服务端接收2个，还剩下8个# 4. tcp协议在接收端有缓存机制，直到下次接收再给# 5. 第一次没有全部接收，后面就全发给接收方import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,addr = sk.accept()ret = conn.recv(2)ret2 = conn.recv(10)print(ret) # b'he'print(ret2) # b'llo,egg' 1234567import socketsk = socket.socket()sk.connect(('127.0.0.1',8090))sk.send(b'hello,egg')sk.close() 接收方的缓存机制 1234567891011121314151617# server # 1. 优化算法，连续的小数据包会被合并# 2. windows系统上 客户端在结束的时候会发送一个空消息 低版本会报错# 3. 多个send 小的数据连在一起，会发生黏包现象，是Tcp协议内部的优化算法造成的# 4. 连续使用了send引起的import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,addr = sk.accept()ret = conn.recv(12)print(ret) # b'helloegg'ret2 = conn.recv(12)print(ret2) 1234567891011# clietn import socketimport timesk = socket.socket()sk.connect(('127.0.0.1',8090))sk.send(b'hello')# time.sleep(3)sk.send(b'egg')sk.close() 总结黏包现象黏包现象只发生在tcp协议中： 从表面上看，黏包问题主要是因为发送方和接收方的缓存机制、tcp协议面向流通信的特点。 实际上，主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。 解决黏包发送消息长度 黏包问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个循环接收完所有数据。 存在的问题:程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗。 12345678910111213141516171819202122232425262728# server# 黏包的本质问题 — 你不知道到底要接收多大的数据# 解决: # 首先发送,这个数据到底有多大# 再按照数据的长度,接收数据import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,addr = sk.accept()print('有新的客户端链接&#123;&#125;'.format(addr))while True: cmd = input('server: ').encode('gbk') if cmd == 'q': break conn.send(cmd) num = conn.recv(4) # 接收消息的长度 # print('接收消息长度:%d' %(int(num))) print(num) conn.send(b'ok') # 发送消息应答 ret = conn.recv(int(num)).decode('gbk') # 1024修改成要接收的数据长度 print(ret)conn.close()sk.close() 1234567891011121314151617181920212223# clientimport socketimport subprocesssk = socket.socket()sk.connect(('127.0.0.1',8090))while True: cmd = sk.recv(1024).decode('gbk') res = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) std_out = res.stdout.read() std_err = res.stderr.read() # print(type(std_out)) # &lt;class 'bytes'&gt; # print(type(std_err)) print(str(len(std_out)+len(std_err)).encode('utf-8')) # 得到消息长度 b'455' sk.send(str(len(std_out)+len(std_err)).encode('utf-8')) # 发送消息长度 # 发送一次消息的长度 sk.recv(4096) # 接收应答 sk.send(std_out) sk.send(std_err)sk.close() 进阶方法—使用struct模块12345678910111213141516# struct模块作用:把一个类型，如数字，转成固定长度的bytes# 1、什么是固定长度的bytesimport structret = struct.pack('i',20491) # i 代表int,即将要把一个数字转换成固定长度的bytes类型print(len(ret),ret) # 4 b'\x01\x08\x00\x00' 太长的数据不够位数会有字母和符号代替，超过长度会报错# struct.pack('i',1111111111111)# truct.error: 'i' format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围num = struct.unpack('i',ret)print(type(num),num) # &lt;class 'tuple'&gt; (2049,)print(num[0]) # 2049# 2、为什么要转成固定长度的# 发送数据的时候# 客户端先发送长度，服务端先接收长度 123456789101112131415161718192021222324252627282930# serverimport socketimport structsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,addr = sk.accept()print('有新的客户端链接&#123;&#125;'.format(addr))while True: cmd = input('server:&gt;&gt;&gt;').encode('gbk') if cmd == 'q': conn.send(b'bye') break conn.send(cmd) # 接收消息长度 客户端使用struct固定传值4个bytes num = conn.recv(4) # 4 num = struct.unpack('i',num)[0] # 消息长度大小 print(num) ret = conn.recv(int(num)).decode('gbk') print(ret)conn.close()sk.close() 1234567891011121314151617181920212223242526# clientimport socketimport subprocessimport structsk = socket.socket()sk.connect(('127.0.0.1',8090))while True: cmd = sk.recv(1024).decode('gbk') if cmd == 'q': break res = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) std_out = res.stdout.read() std_err = res.stderr.read() len_num = len(std_out)+len(std_err) num_by = struct.pack('i',len_num) # print(type(num_by),num_by) # &lt;class 'bytes'&gt; b'\xc8\x01\x00\x00' sk.send(num_by) # 发送固定4个字节，消息长度 sk.send(std_out) sk.send(std_err)sk.close() 使用struct解决黏包借助struct模块，我们知道长度数字可以被转换成一个标准大小的4字节数字。因此可以利用这个特点来预先发送数据长度。 我们还可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了） 实现大文件上传和下载1234567891011121314151617181920212223242526272829303132333435363738394041424344# server 接收端import socketimport jsonimport structsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')buffer = 1024 # 按照服务器性能调整conn,addr = sk.accept()print('有新的客户端链接&#123;&#125;'.format(addr))# 1. 接收报头长度pack_head = conn.recv(4) # 接收报头len_head = struct.unpack('i',pack_head)[0] # 使用struct.unpack得到报头长度# print(len_head)# 2. 接收数据报头js_head = conn.recv(len_head).decode('utf-8') # 接收bytes类型的数据报文js_head = json.loads(js_head) # json报文转字典# print(js_head)# 3. 获取文件长度和文件名称file_size = js_head['file_size']file_name = js_head['file_name']# 4. 打开文件,接收数据with open(file_name,mode='wb') as f: while file_size: print(file_size) if file_size &gt;= buffer: context = conn.recv(buffer) f.write(context) file_size -= buffer else: context = conn.recv(buffer) f.write(context) breakconn.close()sk.close() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# client 发送端import socketimport osimport structimport jsonsk = socket.socket()sk.connect(('127.0.0.1',8090))# 发送文件 定制报头# 发送流程:# 1. 先发报头长度# 2. 再发by_head报头# 3. 发送报文# 1. 组织数据字典head = &#123; 'file_name': '01 软件简介 软件分类.avi', 'file_path': 'D:\\', 'file_size': None&#125;file_path = os.path.join(head['file_path'],head['file_name']) # 获取文件路径# print(file_path)file_size = os.path.getsize(file_path) # 获取文件大小head['file_size'] = file_sizehead['all_file_path'] = file_sizebuffer = 4096# 2. 数据报头长度js_head = json.dumps(head,ensure_ascii=False)# print(js_head)by_head = js_head.encode('utf-8')len_head = len(by_head)pack_head = struct.pack('i',len_head)# 3. 发送报头长度sk.send(pack_head)# 4. 发送数据报头sk.send(by_head)# 5. 打开文件发送文件with open(file_path,mode='rb') as f: while file_size: print(file_size) if file_size &gt;= buffer: context = f.read(buffer) sk.send(context) file_size -= buffer else: context = f.read(buffer) sk.send(context) breaksk.close() 自定制报头 发送数据12345678910111213141516171819202122232425262728293031323334# serverimport socketimport structimport jsonsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,adrr = sk.accept()print('有新的客户端链接&#123;&#125;'.format(adrr))while True: cmd = input('server:&gt;&gt;&gt;').encode('gbk') conn.send(cmd) if cmd == 'q': break len_head = conn.recv(4) len_head = struct.unpack('i',len_head)[0] print(int(len_head)) # 接收报头 by_head = conn.recv(int(len_head)).decode('utf-8') head = json.loads(by_head) print(head,type(head)) # 通过报头长度接收消息 res = conn.recv(head['info_size']).decode('gbk') print(res)conn.close()sk.close() 1234567891011121314151617181920212223242526272829303132333435363738394041# clientimport socketimport structimport jsonimport subprocess# 组织报头head = &#123; 'info_size':None&#125;sk = socket.socket()sk.connect(('127.0.0.1',8090))while True: cmd = sk.recv(1024).decode('gbk') if cmd == 'q': break res = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) std_out = res.stdout.read() std_err = res.stderr.read() # 先发报头长度 # 1. 将字典转成by类型 head['info_size'] = len(std_out)+len(std_err) js_head = json.dumps(head,ensure_ascii=False) by_head = js_head.encode('utf-8') # 2. 使用struct将报头长度转成固定字节 len_head = len(by_head) print(len_head) pack_len = struct.pack('i',len_head) # 3. 发送报头长度 sk.send(pack_len) # 4. 发送报头 sk.send(by_head) # 5. 发送信息 sk.send(std_out) sk.send(std_err)sk.close()]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lambda 匿名函数]]></title>
    <url>%2F2019%2F03%2F25%2Fanonymous%2F</url>
    <content type="text"><![CDATA[匿名函数基础语法匿名函数的作用: 为了解决那些功能很简单的需求而设计的一句话函数 语法：func(函数名) = lambda(关键字) 参数:返回值 参数可以有多个，用逗号隔开 匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值 返回值和正常的函数一样可以是任意数据类型 123456# 把以下函数变成匿名函数def add(x,y): return x+y add = lambda x,y:x+yprint(add(1,2)) # 3 匿名函数和其他功能函数合作lambda 常常和几个内置函数一起使用 max min sorted filter map 和max函数配合12345678910111213141516171819202122# 字典取最大值的key# 字典取最大值dic=&#123;'k1':10,'k2':100,'k3':30&#125;ret = max(dic,key=dic.get)print(dic[ret]) # 100# 字典取最大值的键dic2=&#123;'k1':10,'k2':100,'k3':30&#125;ret1 = max(dic2)print(ret1) # k3 key按照文本大小的最大值# 字典取最大值的键dic2=&#123;'k1':10,'k2':100,'k3':30&#125;def max_dict_key(key): return dic2[key]ret = max(dic2,key=max_dict_key)print(ret) # k2# lambda 匿名一句话函数ret = max(dic2,key=lambda key:dic2[key])print(ret) # k2 和filter函数配合123456789101112# filter 配合 lambda#取出数组中大于10的数据 [5,8,11,9,15]def func(x): return x &gt; 10ret = filter(func,[5,8,11,9,15])for i in ret: print(i) # 11 15# lambda 匿名一句话函数ret = filter(lambda x:x &gt; 10,[5,8,11,9,15])for i in ret: print(i) # 11 15 和map函数配合1234567891011121314ret = map(abs,[-1,2,-3,4])for i in ret: print(i) # 1,2,3,4def func_map(x): return x**2ret = map(func_map,[-1,2,-3,4])for i in ret: print('func_map:',i)# lambda 匿名一句话函数ret = map(lambda x:x**2,[-1,2,-3,4])for i in ret: print('func_map_lanbda:',i) 匿名函数面试题12345678# 1.下面程序的输出结果是：d = lambda p:p*2t = lambda p:p*3x = 2x = d(x) # 4x = t(x) # 12x = d(x) # 24print(x) # 24 1234567891011121314151617# 2.现有两元组(('a'),('b')),(('c'),('d')) ,请使用python中匿名函数生成列表[&#123;'a':'c'&#125;,&#123;'b':'d'&#125;]# lambda# zipret = zip((('a'),('b')),(('c'),('d')))# for i in ret:# print(i)# def func(tup):# return &#123;tup[0]:tup[1]&#125;# res = map(func,ret)# for i in res:# print(i)res = map(lambda tup:&#123;tup[0]:tup[1]&#125;,ret)print(list(res)) # [&#123;'a': 'c'&#125;, &#123;'b': 'd'&#125;]]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>匿名函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置函数]]></title>
    <url>%2F2019%2F03%2F19%2Ffunction%2F</url>
    <content type="text"><![CDATA[内置函数什么是内置函数? 就是python给你提供的. 拿来直接用的函数,比如print., input等等.截止 到python版本3.6.2 python一共提供了68个内置函数. 有一些我们已经用过了.有一些还没有用过. 还有一些需要学完了面向对象才能继续学习的. 作用域相关(2) locals() 和 globals() 基于字典的形式获取局部变量和全局变量12print(locals()) # 返回本地作用域中的所有名字print(globals()) # 返回全局作用域中的所有名字 迭代器/生成器相关(3) range(),next() 和 iter()Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。1234567# range# range(10)# range(1,11)# range(1,11,2) # 步长取值print('__iter__' in dir(range)) # True 可迭代的print('__next__' in dir(range)) # False 不是迭代器print('__next__' in dir(iter(range(1,11,2)))) # True next(迭代器),迭代器向下执行一次,内部实际上调用迭代器.__next__()方法iter(可迭代的),用来生成一个迭代器12345678910# next 和 iterl = [1,2,3,4,5]it = iter(l) # 转成迭代器 print(type(it)) # &lt;class 'list_iterator'&gt;while 1: try: print(next(it)) except StopIteration: # 遇到StopIteration就退出循环 break 其他(12) 查看内置属性(1) dir() 默认查看全局空间内的属性，也接受一个参数，查看这个参数内的方法或变量12print(dir()) # 获得当前模块的属性列表print(dir([])) # 查看列表的方法 调用相关(1) callable() callable 用来检查一个对象是否可被调用对于函数、方法、lambda 函式、 类以及实现了 __call__ 方法的类实例, 它都返回 True。123a = 1print(callable(a)) # Falseprint(callable(print)) # True 帮助(1) help() 用于查看函数或模块用途的详细说明在控制台执行help()进入帮助模式。可以随意输入变量或者变量的类型。输入q退出或者直接执行help(o)，o是参数，查看和变量o有关的操作。。。1help(str) 模块相关(1) import() 导入模块1import time 文件操作相关(1) open() 打开一个文件，返回一个文件操作符(文件句柄)操作文件的模式有r,w,a,r+,w+,a+ 共6种，每一种方式都可以用二进制的形式操作(rb,wb,ab,rb+,wb+,ab+)可以用encoding指定编码.123f = open('01 内置函数.py')print(f.writable()) # 判断当前文件是否可写print(f.readable()) # 判断当前文件是否可读 内存相关(2) id() id()函数用于获取对象的内存地址。123# id(o) o是参数，返回一个变量的内存地址a = 100print(id(a)) # 1497027344 hash() 用于获取取一个对象（字符串或者数值等）的哈希值。hash() 函数可以应用于数字、字符串和对象，不能直接应用于 list、set、dictionary。获取到对象的哈希值(int, str, bool, tuple) hash函数会根据一个内部的算法对当前可hash变量进行处理，返回一个int数字。 每一次执行程序，内容相同的变量hash值在这一次执行过程中不会发生改变。1234print(hash(12345)) # 12345print(hash('abcde')) # -5832084034581495945print(hash(('a','b'))) # -3079515087831999849# print(hash(['a',1,'b',2])) # 报错:TypeError: unhashable type: 'list' 不可哈希 输入输出(2) input() 获取用户输入12content = input('&gt;&gt;&gt;')print(type(content),content) # input得到的是字符串类型 print() 打印输出12345# 关键字传参 end默认为'\n'，指定不是回车即可# 这就是我们为什么使用print的时候会出现换行,end的值修改成了空字符串print('我们的祖国是花园\n',end='')print('我们的祖国是花园\n',end='')print('我们的祖国是花园\n') 123# sep 打印多个值之间的分隔符，默认为空格print(1,2,3,4,5) # 1 2 3 4 5 多个值之间空格隔开print(1,2,3,4,5,sep='|') # 1|2|3|4|5 指定分隔符 12345# file: 默认是输出到屏幕，如果设置为文件句柄，输出到文件# flush: 立即把内容输出到流文件，不作缓存f = open('file','w')print('aaa',file=f,flush=True)f.close() 字符串类型代码的执行(3) eval() eval() 将字符串类型的代码执行并返回结果1print(eval('1+2+3+4')) # 10 有返回值 ——有结果的简单计算 exec() exec() 将自字符串类型的代码执行12345print(exec('1+2+3+4')) # None 没有返回值 ——简单的流程控制# exec 和eval都可以执行 字符串类型的代码# 区别是eval有返回值，exec没有# eval只能用在明确知道要执行的代码 compile() 将字符串类型的代码编译。代码对象能够通过exec语句来执行或者eval()进行求值。1234#流程语句使用exec# code1 = 'for i in range(0,10): print (i)'# compile1 = compile(code1,'','exec')# exec (compile1) 1234#简单求值表达式用eval# code2 = '1 + 2 + 3 + 4'# compile2 = compile(code2,'','eval')# print(eval(compile2)) 12345#交互语句用singlecode3 = 'name = input("please input your name:")'compile3 = compile(code3,'','single')exec(compile3)# print(name) # leo 执行exec后就存在name 基础数据类型相关(38)和数字相关(14) bool() bool() 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。int –&gt; bool 非0为True，0为False1234n1 = 10print(bool(n1)) # Truen2 = 0print(bool(n2)) # False int() int() 函数用于将一个字符串或数字转换为整型。​int() 将给定的数据转换成int值. 如果不给值, 返回012345678# int# str 转换成 int 只能转换数字字符串str1 = '10'print(int(str1)) # 10# int 转换成 str 数字可以转换成任何字符串num = 5print(str(num)) float() ﬂoat() 将给定的数据转换成ﬂoat值. 也就是浮点数 浮点数包括: 有限循环小数 无线循环小数 小数包括: 有限循环小数 无线循环小数 无线不循环小数12345# 浮点数# 354.123 == 3.54123 * 10**2 == 35.4123 * 10 在这个过程中点是浮动的 所以才叫浮点数f = 1.78789787079889 # 当小数特别长的时候 就有可能不准了 二进制转小数会有问题就会不准print(float(1)) # 1.0print(float('123') ) # 转换字符串 123.0 complex() complex() 创建一个复数. 第一个参数为实部, 第二个参数为虚部. 或者第一个参数直接 用字符串来描述复数 实数: 有理数 ： 整数 有限循环小数 无线循环小数 无理数 ： 无线不循环小数 π 虚数: 虚无缥缈的数123# python里面的虚数 = 12j (j是单位)# 5 + 12j === 复合的数 == 复数 (复数之间是无法比较大小的)print(complex(1, 2)) # (1+2j) bin() 1print(bin(10)) # 十进制转二进制 # 0b1010 oct() 1print(oct(10)) # 十进制转十进制 # 0o12 hex() 1print(hex(10)) # 十进制转十六进制 # 0xa abs() abs() 函数返回数字的绝对值。123# abs求绝对值 负的转正的 正的还是正的print(abs(-5)) # 5print(abs(10)) # 10 divmod() 12345# divmod 接收两个参数 div 除法 mod 取余# 除余方法# 分页的时候 会用到print(divmod(7,2)) # (3, 1)print(divmod(9,5)) # (1, 4) round() round() 方法返回浮点数x的四舍五入值。1print(round(3.14159,2)) # 3.14 2代表保留两位 支持四舍五入 pow() 1234# pow 求幂运算print(pow(2,3)) # 8print(pow(3,2,1)) # 0 三个参数就是 == 3的2次幂 对 1取余 幂运算之后再取余print(pow(2,3,3)) # 2 sum() ​sum() 求和12345678# sum(iterable[, start])# start 从几开始相加# 列表计算总和后再加10ret = sum([1,2,3],10)print(ret) # 16ret = sum((1,2,3))print(ret) # 6 min() min()计算最小值12345# min(iterable,key,default)# min(*args,key,default)print(min([1,2,3])) # 1print(min(1,2,3)) # 1print(min((1,2,3,-4),key=abs)) # 1 key=abs 以绝对值的方法来计算 max() min()计算最大值12345# max(iterable,key,default)# max(*args,key,default)print(max([1,2,3])) # 3print(max(1,2,3)) # 3print(max((1,2,3,-4),key=abs)) # -4 key=abs 以绝对值的方法来计算 和数据结构相关(24) list() list() 用于将元组或字符串转换为列表。注：元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中。1234str1="Hello World"print(list(str1)) # ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']tup1 = (1,2,3,'leo')print(list(tup1)) # [1, 2, 3, 'leo'] tuple() tuple()函数将列表转换为元组。。12l1= ['Google', 'Taobao', 'Runoob', 'Baidu']print(tuple(l1)) # ('Google', 'Taobao', 'Runoob', 'Baidu') reversed() reversed() 返回一个反向的迭代器12345678910# list.reverse() # 列表的反转方法l2 = [1,2,3,4]l2.reverse()print(l2) # [4, 3, 2, 1] 原本的列表发生变化l3 = [1,2,3,4,5]iter_l = reversed(l3) # 保留原列表,返回一个反向的迭代器print(iter_l) # &lt;list_reverseiterator object at 0x000000000288CF98&gt; 迭代器for i in iter_l: print(i) slice() slice() 函数实现切片对象，主要用在切片操作函数里的参数传递。1234l = (1,2,23,213,5612,342,43)sli = slice(1,5,2) # 切片规则print(l[sli]) # (2, 213)print(l[1:5:2]) # (2, 213) str() str() 将数据转化成字符串1234l4 = [1,2,3]print(str(l4)) # [1, 2, 3]dict4 = &#123;'name':'leo'&#125;print(str(dict4)) # &#123;'name': 'leo'&#125; format() format() 字符串格式化1234567print("&#123;&#125;,&#123;&#125;".format('leo','lex')) # leo,lex 不设置指定位置，按默认顺序print("&#123;0&#125;,&#123;1&#125;,&#123;0&#125;".format('leo','lex')) # leo,lex,leo 设置指定位置print("名字:&#123;name&#125;,年龄&#123;age&#125;".format(name='leo',age='30')) # 名字:leo,年龄30# 通过字典设置参数info = &#123;'name':'leo',"age":29&#125;print("名字:&#123;name&#125;,年龄&#123;age&#125;".format(**info)) # 名字:leo,年龄29 bytes() bytes 将数据转换成bytes类型12345# 拿到的事gbk编码，想要转换成utf-8编码print(bytes('您好',encoding='GBK')) # b'\xc4\xfa\xba\xc3' unicode转成 GBKprint(bytes('您好',encoding='utf-8')) # b'\xe6\x82\xa8\xe5\xa5\xbd' unicode 转 utf-8# gbk -&gt; decode（解码） unicode -&gt; encode(编码) utf-8 bytearray() bytes类型的数组123b_array = bytearray('您好',encoding='utf-8')print(b_array) # bytearray(b'\xe6\x82\xa8\xe5\xa5\xbd')print(b_array[0]) # 230 memoryview() memoryview() 函数返回给定参数的内存查看对象(Momory view)。所谓内存查看对象，是指对支持缓冲区协议的数据进行包装，在不需要复制对象基础上允许Python代码访问。1234ret = memoryview(bytes('你好',encoding='utf-8'))print(len(ret))print(bytes(ret[:3]).decode('utf-8'))print(bytes(ret[3:]).decode('utf-8')) ord() 字符按照unicode转数字123print(ord('A')) # 65print(ord('a')) # 97print(ord('1')) # 49 chr() 数字按照unicode转字符12print(chr(65)) # Aprint(chr(49)) # 1 ascii() 只要是ascii码(字母、数字、符号、拉丁文)就显示，不是的话就打印\u类型12print(ascii('好')) # '\u597d'print(ascii('l')) # l repr() repr格式化,原形毕露12345name = 'egg'print('你好%s' %name) # 你好egg %s ==&gt; strprint('你好%r' %name) # 你好'egg' %r ==&gt; reprprint(repr('1')) # '1'print(repr(1)) # 1 dict() 创造字典12print(dict()) # &#123;&#125;print(dict(a=1,b=2,c=3)) # &#123;'a': 1, 'b': 2, 'c': 3&#125; set() set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等123456x = set('runoob')y = set('google')print((set(['b', 'r', 'u', 'o', 'n']), set(['e', 'o', 'g', 'l'])) ) # 重复的被删除print(x &amp; y) # 交集 &#123;'o'&#125;print(x | y ) # 并集 &#123;'r', 'o', 'l', 'n', 'e', 'u', 'b', 'g'&#125;print(x - y ) # 差集 &#123;'r', 'b', 'n', 'u'&#125; frozenset() 生成一个新的不可变集合,它可以作为字典的key12a = frozenset(range(10)) # 生成一个新的不可变集合b = frozenset('runoob') 重要的内置参数 len() 返回对象的长度或者元素个数1234test = 'abcde'list1 = [1,2,3]print(len(test)) # 5 字符串长度print(len(list1)) # 3 列表元素个数 enumerate() enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中enumerate(sequence, [start=0]) sequence – 一个序列、迭代器或其他支持迭代对象。 start – 下标起始位置。123456seasons = ['Spring', 'Summer', 'Fall', 'Winter']list2 = list(enumerate(seasons))print(list2) # [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]list3 = list(enumerate(seasons, start=1)) # 小标从 1 开始print(list3) # [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] all() 有任何一个空内容就是false123print(all(['a','',123])) # Falseprint(all(['a',123])) # Trueprint(all([0,123])) # False any() 有一个正确的就是True1print(any(['',True,0,[]])) # True zip() zip 拉链方法,如果少一个元素无法对应上，就不加入,以最小的数据类型为准12345678910l1 = [1,2,3]l2 = ['a','b','c','d']t3 = ('*','**',[1,2])d4 = &#123;'k1':'1','k2':'2'&#125;print(zip(l1,l2)) # &lt;zip object at 0x00000000028422C8&gt;for i in zip(l1,l2,t3,d4): print(i)# (1, 'a', '*', 'k1')# (2, 'b', '**', 'k2') filter() filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象,如果要转换为列表，可以使用 list() 来转换。filter() 函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。1234567891011121314151617# 过滤列表中的奇数def is_odd(x): return x % 2 == 1 # 奇数# 第一个参数 函数方法# 第二个参数 可迭代的# 可迭代的里面的每个数据都会传入前面的函数# 根据函数的结算结果筛选,为True的才会留下，最后返回一个迭代器ret = filter(is_odd,[1,3,5,8,10])print(ret) # &lt;filter object at 0x00000000027A8780&gt; 迭代器# for i in ret:# print(i) # 迭代器节省内存print(list(ret)) # [1, 3, 5]# 相当于列表推导式l2 = [i for i in [1,3,5,8,10] if i % 2 == 1]print(l2) # [1, 3, 5] 12345678# 名字有两个e的结果names = ['leo','leex','rubin','lee']def func(name): return name.count('e') &gt;= 2iter_names = filter(func,names)for i in iter_names: print(i) # leex,lee 12345678910# 只保留字符串l3 = [1,'leo',2,'rubin',3]def is_str(s):# if type(s) == str:# return True return type(s) == striter_names = filter(is_str,l3)for i in iter_names: print(i) # leo,rubin 123456789# 删除列表中的None和空字符串l4 = ['test', None, '', 'str', ' ', 'END']def is_none(s): if type(s) != int: return s and str(s).strip()iter_none = filter(is_none,l4)for i in iter_none: print(i) 12345678# 练习：请利用filter()过滤出1~100中平方根是整数的数，即结果应该是：from math import sqrt # 开平方print(sqrt(64)) # 8.0def init_sqrt(num): res = sqrt(num) return res % 1 == 0 # 除1余0就是整数iter_sqrt = filter(init_sqrt,range(1,101))print(list(iter_sqrt)) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] map() Python中的map函数应用于每一个可迭代的项，返回的是一个结果list。如果有其他的可迭代参数传进来，map函数则会把每一个参数都以相应的处理函数进行迭代处理。map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。1234567891011# map 有点像 [i for i in [1,2,3]]ret = map(abs,[-1,-2,3,-8])for i in ret: print(i) # 1,2,3,8# filter 执行了filter之后的记过集合 &lt;= 执行之前的个数 # filter只管筛选，不会改变原来的值# map 执行前后元素个数不变，值变了 # 值可能发生改变 # 要注意配合匿名函数 sorted() 对List、Dict进行排序，Python提供了两个方法对给定的List L进行排序，方法1.用List的成员函数sort进行排序，在本地进行排序，不返回副本方法2.用built-in函数sorted进行排序（从2.4开始），返回副本，原始输入不变1234567891011121314151617181920# sortl = [1,-4,6,5,-10]l.sort(key=abs) # 在原列表的基础上进行排序print(l) # [1, -4, 5, 6, -10]# sorted# 会生成一个新的数据,保留原来数据# 排序的过程中负载的算法不支持产生一个迭代器l = [1,-4,6,5,-10]print(sorted(l)) # [-10, -4, 1, 5, 6] # 生成一个新列表，不改变原列表 占内存print(l) # [1, -4, 6, 5, -10] # 源列表不变# reversed() 倒叙 返回一个反向的迭代器# sorted() 排序 返回listprint(sorted(l,key=abs)) # [1, -4, 5, 6, -10]# 列表按照每一个元素的len排序l = [[1,2],[3,4,5,6],(7,),'123']print(sorted(l,key=len)) # [(7,), [1, 2], '123', [3, 4, 5, 6]]]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器面试题]]></title>
    <url>%2F2019%2F03%2F18%2Fcase-generator%2F</url>
    <content type="text"><![CDATA[生成器面试题12345678910111213141516171819def demo(): # 生成器函数 for i in range(4): yield ig=demo() # 生成器# 生成器表达式g1=(i for i in g) # 没执行g2=(i for i in g1)# 数据类型强转print(list(g1)) # [0, 1, 2, 3] # 执行了,g1生成器找g取值print(list(g2)) # [] # g2找g1拿值，g1已经没有值了.所以是空,把g1注释掉,g2就有值了# 一个生成器里面的能用只能取一次,你不找他要，他也不会给你# g1=(i for i in g) 没干活，因为他返回了个 生成器#def g1():# for i in g:# yield i 123456789101112131415161718192021222324252627def add(n,i): return n+idef test(): for i in range(4): yield ig=test()for n in [1,10]: g=(add(n,i) for i in g) # 生成器表达式# 当遇见这种问题的时候 先将循拆开# for循环套生成器表达式# n = 1# g=(add(n,i) for i in g) # test()# n = 10# g=(add(n,i) for i in g) # (add(n,i) for i in g)# 2 带入方程# g=(add(n,i) for i in test())# g=(add(n,i) for i in (add(10,i) for i in test()))# n = 10# g=(add(n,i) for i in (add(10,(0,1,2,3))# n = 10# g=(add(10,i) for i in (10,11,12,13))# 20,21,22,23print(list(g)) # 开始执行 12345678910111213141516171819202122def add(n,i): return n+idef test(): for i in range(4): yield ig=test()for n in [1,10,5]: g=(add(n,i) for i in g) # 生成器表达式# n = 1# g=(add(n,i) for i in test())# n = 10# g=(add(n,i) for i in (add(n,i) for i in test()))# n = 5# g=(add(n,i) for i in (add(n,i) for i in (add(n,i) for i in test())))# g=(add(n,i) for i in (add(n,i) for i in (add(n,i) for i in (0,1,2,3))))# g=(add(n,i) for i in (add(n,i) for i in (5,6,7,8)))# g=(add(n,i) for i in (10,11,12,13)# 15,16,17,18print(list(g)) # 开始执行]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种推导式]]></title>
    <url>%2F2019%2F03%2F15%2Fcomprehensions%2F</url>
    <content type="text"><![CDATA[推导式的套路: 新的列表 = [ 每一个元素或者是和元素相关的操作 for 元素 in 可迭代数据类型 ] # 遍历之后挨个处理 新的列表 = [ 满足条件的元素相关的操作 for 元素 in 可迭代数据类型 if 元素相关的条件 ] # 筛选功能 列表推导式12345678910111213141516171819202122# 例一：30以内所有能被3整除的数l = [ i for i in range(30) if i % 3 == 0 ]print(l)# 例二：30以内所有能被3整除的数的平方l = [ i**2 for i in range(30) if i % 3 == 0 ]print(l)# 例三:找到嵌套列表中名字含有两个‘e’的所有名字names = [['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe'], ['Alice', 'Jill', 'Ana', 'Wendy', 'Jennifer', 'Sherry', 'Eva']]# 常规循环#for l in names:# for name in l:# if name.count('e') &gt;= 2:# print(name)# 二维列表# 注意遍历顺序，这是实现的关键l = [name for l in names for name in l if name.count('e') &gt;= 2]print(l) 字典推导式12345678910111213141516171819# 字典推导式# 例一：将一个字典的key和value对调mcase = &#123;'a': 10, 'b': 34&#125;# 常规循环# for k in mcase:# mcase[k] : k # v : k# print(mcase)mcase = &#123;mcase[k]:k for k in mcase&#125;print(mcase)# 例二：合并大小写对应的value值，将k统一成小写# 所有的推导式都从for开始看mcase = &#123;'a': 10, 'b': 34, 'A': 7, 'Z': 3&#125;# &#123;'a':10+7,'b':34,'z':3&#125;mcase_frequency = &#123;k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()&#125;# 拿到所有key# key值就是要小写k.lower():# mcase.get(k.lower(), 0)没有小写的就默认写一个0 + mcase.get(k.upper(), 0) 相当于小写+大写的值,没有就给0print(mcase_frequency) 集合推导式12345# 集合推导式 可以替重# &#123;&#125;# 例：计算列表中每个值的平方，自带去重功能squared = &#123;x**2 for x in [1, -1, 2]&#125;print(squared) # -1的平方和1的平方一样 所以去重之后2个结果，如果是列表就不会自动去重 总结各种推导式:生成器 列表 字典 集合 遍历 筛选 带if 优点 推导式能让你的代码更简洁， 可读性提高 惰性运算: 懒 不去找他要值不会执行，要一个执行一个 生成器(自己写的，可见)和迭代器（不可见的，python提供）特点 同一个迭代器,从头到尾取值只能取一次 不找他要值的时候不干活 练习1234567891011121314151617# 例1: 过滤掉长度小于3的字符串列表，并将剩下的转换成大写字母names = ['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe']new_l = [name.upper() for name in names if len(name) &gt; 3]print(new_l)# 例2: 求(x,y)其中x是0-5之间的偶数，y是0-5之间的奇数组成的元祖列表l1 = [(x,y) for x in range(5) if x%2==0 for y in range(5) if y %2==1]l2 = [(x,y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]print(l1)print(l2)# 求M中3,6,9组成的列表M = [[1,2,3],[4,5,6],[7,8,9]]# for i in M:# print(i[2])l3 = [row[2] for row in M]print(l3)]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>列表推导式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 装饰器]]></title>
    <url>%2F2019%2F03%2F13%2Fdecorator%2F</url>
    <content type="text"><![CDATA[简单的装饰器使用比如现在公司有一个需求，每个函数都要计算运行时间，我们可以调用time模块实现一个简单的计算执行时间的方法 1234567891011import time# 统计每个函数的执行时间 1def func(): start_time = time.time() print('func 1') time.sleep(3) now_time = time.time() return now_time - start_timeret = func() # func 1print(ret) # 3.000171661376953 那如果要是有200多个函数呢，难道要一个个加入，然后在一个个删除？我们想到计算时间可以单独写一个函数去调用。123456789101112# 调用统计时间函数def timmer(f): start_time = time.time() f() end_time = time.time() print(end_time - start_time)def func(): time.sleep(3) print('func 1')timmer(func) 这样以后的200个函数都要使用timmer去调用执行么？也是不合理的，应该是func方法来调用时间函数，比较合理。 装饰器的形成过程1234567891011121314151617181920# 我们想要做到的:# 1 不想修改函数的调用方式 但是还想再原来的函数前后添加功能# 2 timmer就是一个装饰器函数，只是对一个函数 有一些装饰作用def func(): time.sleep(3) print('func 1')# 调用统计时间函数# 闭包 内部函数inner,调用了外部变量f,f是传进来的def timmer(f): # 装饰器函数 def inner(): start_time = time.time() f() # 被装饰的函数 end_time = time.time() print(end_time - start_time) return innerfunc = timmer(func)func() 运行过程流程图: 原来的函数为func 最后我还是要调用func 中间增加的计时功能timmer 通过func = timmer(func) 和 闭包函数 来进行修饰 最终通过闭包函数来返回内部函数 交给 外部的func接收，接收的变量还是原本func的方法 最后执行外部的func()，他会自动去找装饰函数inner(),再去找到原本被装饰的函数func() 总结:装饰器的本质：一个闭包函数装饰器的功能：在不修改原函数及其调用方式的情况下对原函数功能进行扩展装饰器的意义： 装饰器既没有改变函数的调用方式，又在函数的前后增加了装饰功能 开放封闭原则开放: 对扩展是开放的,任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。 封闭: 对修改是封闭的,因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对其进行了修改，很有可能影响其他已经在使用该函数的用户。 装饰器完美的遵循了这个开放封闭原则 语法糖@装饰器函数 == 重新定义被装饰函数=装饰器函数（被装饰函数）12345678910111213141516171819import timedef timmer(f): # 装饰器函数 def inner(): start_time = time.time() f() # 被装饰的函数 end_time = time.time() print(end_time - start_time) return inner# 语法糖 @timmer 让代码更好看 更便捷# 在被装饰的函数上面贴着加上 @装饰器函数名 # 就相当于写了func = timmer(func)@timmerdef func(): time.sleep(3) print('func 1')# func = timmer(func)func() 装饰带返回值的函数的装饰器12345678910111213141516171819202122import timedef timmer(f): # 装饰器函数 def inner(): start_time = time.time() ret = f() # 被装饰的函数 带有返回值 end_time = time.time() print(end_time - start_time) return ret # 返回被装饰的函数的返回值 return inner@timmerdef func(): time.sleep(3) print('func 1') return '新年好' # 被装饰的函数的返回值# func = timmer(func)ret = func()print(ret)# 因为现在的func不是原来的func 而是inner ，所有要对inner中增加返回值# 现在的func就是inner,ret接收的事inner的返回值 装饰带一个参数的函数12345678910111213def wrapper(func): def inner(name): ret = func(name) return ret return inner@wrapper # func = wrapper(func)def func(name): return '新年好,%s'%nameret = func('leo')print(ret) 接收万能参数装饰器1234567891011121314151617def wrapper(func): def inner(*args,**kwargs): # print('函数被装饰之前要做的事') print(*args) # leo python print(kwargs) # &#123;'age': 30&#125; print(kwargs['age']) # 30 ret = func(*args,**kwargs) # print('函数被装饰之前要做的事') return ret return inner@wrapperdef func(name,course,age): return '大家好,我是%s,今年%d,现在正在学习%s'%(name,age,course)ret = func('leo','python',age=30)print(ret) # 大家好,我是leo,今年30,现在正在学习python 装饰器的固定格式123456789101112131415161718import time# 单纯就叫装饰器的时候 -- wrapperdef wrapper(f): # 装饰器函数,f是被装饰的函数,装饰器函数里面的参数永远是被装饰的函数 def inner(*args,**kwargs): # 内部函数inner,*args,**kwargs动态参数原封不动的传给被装饰的函数 # 被装饰函数执行之前要做的事 ret = f(*args,**kwargs) # 被装饰的函数,执行完成后，给外面返回值 # 被装饰函数执行之后要做的事 return ret return inner # 对应内部函数inner 不加括号执行@wrapper # func = timmer(func)def func(a,b): time.sleep(2) print('func1',a,b) return '新年好'ret = func(1,2)print(ret) 1234567891011def wrapper(func): # func = qqxing def inner(*args,**kwargs): ret = func(*args,**kwargs) # 被装饰的函数 qqxing return ret return inner@wrapper # qqxing = wrapper(qqxing)def qqxing(a,b): print(123)ret = qqxing(1,2) # 实际上执行的是inner() 装饰器的固定格式 - wraps首先先了解函数的name和doc方法:函数名.__name__ = 查看字符串格式的函数名函数名.__doc__ = 查看函数注释123456789def wahaha(): ''' 一个打印娃哈哈的函数 :return: ''' print('娃哈哈')print(wahaha.__name__) # 查看字符串格式的函数名print(wahaha.__doc__) # 查看函数注释 在执行使用装饰器之后，我们打印函数的name发现是装饰器的函数名称了，这个时候就需要使用wraps来解决。12345678910111213141516171819202122232425from functools import wrapsdef wrapper(func): # func = holiday @wraps(func) # 装饰inner函数 def inner(*args,**kwargs): print('在被装饰的函数执行前做的事') ret = func(*args,**kwargs) print('在被装饰的函数执行后做的事') return ret return inner@wrapper # holiday = wrapper(holiday)def holiday(day): ''' 这是一个放假通知 :param day: :return: ''' return '还有%s天放假'%dayprint(holiday.__name__) # inner...因为现在的holiday已经是inner了，由于之前说装饰器最好不要影响被装饰的函数，需要用wraps装饰inner函数,才可以正常显示回去print(holiday.__doc__)ret = holiday(3) # innerprint(ret)# wraps并不影响wrapper装饰器的使用 带参数的装饰器比如现在有500个函数,都使用装饰器，那么怎么一次性的去控制500个装饰器的增加和删除，怎么办？我们可以使用带参数的参数器，通过标志位参数去控制装饰器是否执行。带参数的装饰器，也就是三层装饰器，在外部多一次调用传入状态标记。123456789101112131415161718192021222324252627282930import timeFLAGE = True # 标识位，True执行，Fales不执行def timmer_out(flag): # 在原有装饰器之外再来一层 def timmer(func): def inner(*args,**kwargs): if flag: # 如果flag = True 那么我就走装饰器，否则我就只运行被装饰的函数 start_time = time.time() ret = func(*args,**kwargs) end_time = time.time() print(end_time - start_time) return ret else: ret = func(*args, **kwargs) return ret return inner return timmer# timmer = timmer_out(FLAGE)@timmer_out(FLAGE)def wahaha(): time.sleep(2) print('wahaha')@timmer_out(FLAGE)def qqxing(): time.sleep(1) print('qqxing')ret = wahaha()ret = qqxing() 多个装饰器装饰一个函数多个装饰器执行的过程有点像套娃，装饰器在后的先执行装饰1234567891011121314151617181920212223242526272829303132def wrapper1(func): # f def inner1(): print('wrapper1装饰器 start') # 3 func() # 执行f # 4 print('wrapper1装饰器 end') # 5 return inner1def wrapper2(func): # inner1 def inner2(): print('wrapper2装饰器 start') # 1 先执行他 func() # inner1() # 2 print('wrapper2装饰器 end') # 6 return inner2# 先看装饰器执行先后@wrapper2 # f = wrapper2(f)==&gt; f = inner1 ==&gt; inner1 = wrapper2(inner1) ==&gt; inner2 ，传进去的是inner1,最后返回得到的是inner2@wrapper1 # f = wrapper1(f) = inner1def f(): print('in f')f() # ==&gt; 调用开始现在是 inner2# wrapper2装饰器 start# wrapper1装饰器 start# in f# wrapper1装饰器 end# wrapper2装饰器 end# 1. 先看装饰器执行先后，wrapper2没有找到要被修饰的函数，所以现在wrapper1# 2. f = wrapper1(f) = inner1# 3. # f(下面赢变成inner1) ==&gt; inner1 = wrapper2(inner1) = inner2，但是传进去的是inner1, 有时候会遇见两个需求: 记录用户的登录情况 记录函数的执行时间仔细思考下先后执行顺序:先登录成功之后 才能开始执行程序记录函数的执行时间]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 迭代器]]></title>
    <url>%2F2019%2F03%2F11%2Fiterator%2F</url>
    <content type="text"><![CDATA[for循环是如何工作的当我们拥有一个列表 l = [1,2,3,4,5],想取列表中的内容，有几种方式？ 1234# 1 通过索引下标和切片取值l = [1,2,3,4,5]print(l[0]) # 1print(l[0:2]) # [1, 2] 123# 2 通过for循环取值for i in l: print(i) 他们的区别是，使用索引取值可以取到任意位置的值，前提是我知道这个值在什么位置，而for循环是取到每一个值，不需要关心这个值在什么位置，也不能跳过任何一个值去取其他位置的值，我们可以称作循环遍历。那么for循环到底是怎么工作的呢？ 都有哪些数据类型可以被for循环123456789101112131415for s in 'abcde': print(s) # 返回字符串中每一个字符 a b c d edic = &#123;'name':'leo','age':26&#125;for key in dic: print(key) # 默认返回字典中的键 name , agefor value in dic.values(): print(value) # 返回字典中的值 leo,26 for k,v in dic.items(): print(k,v) # 返回字典中的键值对 name leo age 26for i in 12345: print(i) # TypeError: 'int' object is not iterable 当我们循环数字类型的时候报错了，说int类型不是 iterable（可迭代的） 迭代和可迭代协议通过对数字类型的报错，不可被for循环的数据类型会报错 不是一个可迭代的，那么是不是说可迭代的数据类型就可以被for循环，如何判断数据类型是否可以被迭代？123456789101112131415161718from collections import Iterablel = [1,2,3,4]t = (1,2,3,4)d = &#123;1:2,3:4&#125;s = &#123;1,2,3,4&#125;num = 123money = 10.10print(isinstance(l,Iterable)) # Trueprint(isinstance(t,Iterable)) # Trueprint(isinstance(d,Iterable)) # Trueprint(isinstance(s,Iterable)) # Trueprint(isinstance(num,Iterable)) # Falseprint(isinstance(money,Iterable)) # False# 下面这三种也是可以被循环遍历# f = open() # range()# enumerate 枚举 可以将某个数据集内的数据“一个挨着一个的取出来”，就叫做迭代总结出一条规律来：能被for循环的就是“可迭代的”。但是如果正着想，for怎么知道谁是可迭代的呢？为什么能被for循环？ 123456789101112131415# 为什么能够被循环# dir 可以返回这个数据类型的拥有的所有方法# 查看列表、字典、字符串、和range的双下方法 有什么共同方法# 求交集ret = set(dir([]))&amp;set(dir(&#123;&#125;))&amp;set(dir(''))&amp;set(dir(range(10)))print(ret) # 我们找一个和iterable比较相似的方法， '__iter__',# 我们再来看看无法被迭代的数据类型 有没有__iter__方法print('__iter__' in dir(int)) # Falseprint('__iter__' in dir(bool)) # Falseprint('__iter__' in dir(list)) # Trueprint('__iter__' in dir(dict)) # Trueprint('__iter__' in dir(set)) # Trueprint('__iter__' in dir(tuple)) # Trueprint('__iter__' in dir(range(10))) # Trueprint('__iter__' in dir(enumerate([]))) # True 再总结出一条新的规律: 能被for循环的就是“可迭代的”,只要是能被for循环的数据类型，就一定拥有__iter__双下方法 双下方法__iter__做了什么123456789101112131415161718print([].__iter__()) # &lt;list_iterator object at 0x0000000002308940&gt; 迭代器 iterator# [].__iter__() 得到了一个list_iterator# 那么迭代器有什么作用呢？让我们来看看列表list和转换成列表_迭代器所有方法的差集print(set(dir([].__iter__()))- set(dir([])) ) # &#123;'__setstate__', '__length_hint__', '__next__'&#125;# 迭代器多出来的这三个方法的作用:#__length_hint__ 获取迭代器中元素的长度# print([1,2,3,4,5].__iter__().__length_hint__()) # 5 元素个数# __setstate__ 可以指定从其他位置取值# __next__ 一个一个的取值# 迭代器取值l = [1,2,3] # 列表iterator = l.__iter__() # iterator现在是一个迭代器,他内部有.__next__()方法print(iterator.__next__()) # 1print(iterator.__next__()) # 2print(iterator.__next__()) # 3print(iterator.__next__()) # 报错 StopIteration 通过上面的例子我们发现,当一个可迭代的对象调用了iter()方法会生成一个 iterator (迭代器) 迭代器中含有_next__()方法，他可以一个一个的取值,如果我们一直取next取到迭代器里已经没有元素了，就会抛出一个异常StopIteration，告诉我们，列表中已经没有有效的元素了 可迭代协议 与 迭代器协议根据上面的例子我们总结出以下概念： 能被for循环的数据类型都是 可迭代的 (iterable) 当这个数据类型调用.__iter__()方法会生成一个 迭代器(iterator) 迭代器.next()可以一个一个的取值 for循环其实就是在使用迭代器，只有是可迭代对象或者迭代器，才能用for循环 for循环的本质就是迭代器 12345for i in l: pass # 首先会去找l.__iter__() ==&gt; iterator = l.__iter__() # i = iterator.__next__() # 当没有值的时候 自动停止结束 也不会报错 12345# 模拟for循环l = [1,2,3,4,5]iterator = l.__iter__() # 变成一个迭代器while True: print(iterator.__next__()) 可迭代协议: 只要含有__iter__()方法的都是可迭代的迭代器协议: 内部含有__next__()方法和__iter__()方法的就是迭代器 可迭代的不一定就是迭代器 迭代器：内部有__iter__和__next__方法 ，所以他一定是可迭代的 可迭代的不一定是迭代器，要看有没有__next__方法12345678910from collections import Iterablefrom collections import Iteratorprint(isinstance([],Iterable)) # 可迭代的 # Trueprint(isinstance([],Iterator)) # 迭代器 # False ,list是可迭代的，但不是一个迭代器print('__iter__' in dir(range(12))) # Trueprint('__next__' in dir(range(12))) # Falseprint(isinstance(range(100000000),Iterable)) # Trueprint(isinstance(range(100000000),Iterator)) # False , range是可迭代器，但不是一个迭代器，因为它没有__next__()方法 迭代器的好处 迭代器会从容器类型中 一个一个的取值，会把所有的值都取到。 它可以节省内存空间,迭代器并不会在内存中再占用一大块内存，而是随着循环每次生成一个,或者每次next()每次给我一个12# print(range(10000000)) # 很快，但是并不会在内存中真正的生成数据# print(list(range(10000000))) # 强制转列表会导致崩溃,list是真正存在并存储在内存里 ，range是要一个给一个]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 生成器]]></title>
    <url>%2F2019%2F03%2F11%2Fgenerator%2F</url>
    <content type="text"><![CDATA[什么是生成器之前我们学习过迭代器，它的好处之一就是可以节省能存，在某些情况下，我们需要自己定义一个方法去实现迭代器功能，这个方法就是生成器。在Python中生成器又分成两类: 生成器函数 生成器表达式 生成器函数生成器Generator： 本质：迭代器(所以自带了iter方法和next方法，不需要我们去实现) 特点：惰性运算,开发者自定义 生成器函数：一个包含yield关键字的函数就是一个生成器函数。yield可以为我们从函数中返回值，但是yield又不同于return，return的执行意味着程序的结束，调用生成器函数不会得到返回的具体的值，而是得到一个可迭代的对象。每一次获取这个可迭代对象的值，就能推动函数的执行，获取新的返回值。直到函数执行结束。 1234567891011121314# 只要含有yield关键字的函数都是生成器函数# yield 必须写在函数里，且无法和return共用def generator(): a = 1 yield a b = 2 yield b g = generator() # 得到一个“生成器”作为返回值print(g) # &lt;generator object generator at 0x0000000001E9A308&gt; generator 生成器# g.__next__ # 生成器带有__next__方法和__iter__方法# g.__iter__ # 生成器是迭代器 用next方法取值print(g.__next__()) # 1print(g.__next__()) # 2 运行过程总结： 由于函数中有yield，所以现在内存中会有一个生成器函数 generator g = generator() 发生了函数调用，生成器函数的特点：函数中的代码不执行 g 得到了一个生成器 生成器里面即有iter方法也有next方法，说明它其实是一个迭代器 生成器就可以使用next方法取值,这时程序才第一次触发了生成器里面的代码 yield 不会结束函数，return会直接结束 生成器函数的使用生成器的最大好处就是不会在内存中一次性的生成所有数据1234567891011121314151617181920212223def factoy(): for i in range(100): yield '生成%s次'%ig = factoy()# __next__() ,一次一次的提取print(g.__next__())print(g.__next__())print(g.__next__())# for循环遍历提取for i in g: print(i)# 取50次g = factoy()count = 0for i in g: count += 1 print(i) if count &gt; 50: breakprint('*****',g.__next__()) # ***** 生成51次 可以继续从生成器中取值 列表为什么不能继续取值123456789101112131415161718192021# 列表是可迭代的,并不是一个迭代器,在两次for循环的时候会产生两个迭代器# for循环自动将可迭代的转换成迭代器l = [1,2,3,4,5]for i in l: print(i) # 1,2 if i == 2: breakfor i in l: print(i) # 1,2,3,4,5 # 获取两个生成器l = [1,2,3,4,5]def generator(): for i in l: yield i g = generator()g1 = generator()print(g,g1) # &lt;generator object generator at 0x0000000001F7A150&gt; &lt;generator object generator at 0x0000000001F7A200&gt;print(g.__next__()) # 1print(g1.__next__()) # 1 拿到两个生成器，自己执行自己的 监听文件的输入123456789101112def tail(filename): f = open(filename, encoding='utf-8') while True: line = f.readline() # 每次读一行 if line.strip(): # 不为空就打印 # print('****',line.strip('\n')) yield line.strip() # 返回这行g = tail('file') # 获取生成器for i in g: if 'python' in i: print('*****',i,'*****') # 可以对这个结果做任何操作了,用生成器实现就可以想要的结果 爬虫时的使用123456789101112131415161718192021222324252627def parse_one_page(html): rule = re.compile( '&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?' 'releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;' ,re.S) items = re.findall(rule, html) # 通过findall方法根据规则得到html文本 # print(items) for item in items: yield &#123; 'index':item[0], 'image':item[1], 'title':item[2].strip(), 'actor':item[3].strip(), 'time':item[4].strip(), 'score':item[5].strip() + item[6].strip() &#125; # 循环整个html文本列表,每一条数据都生成yield返回一个字典，里面拼接成想要的数据类型# 使用的时候传递一个页面进去，循环调用生成器，item里就是生成的每条数据def main(offset): url = 'https://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) # print(html) for item in parse_one_page(html): print(item) write_to_file(item) 生成器函数的进阶数据类型的强制转换 — 列表(生成器)1234567891011121314def generator(): for i in range(20): yield 'wahaha%s'%ig = generator()# list(g)# list是列表，代表将g生成器直接转换成列表，列表中的每一个值都是实际存在的# 一个一个从生成器里取出来，全部取完放入列表，列表会在内存中生成print(list(g))# ['wahaha0', 'wahaha1', 'wahaha2', 'wahaha3'...'wahaha19']# 从生成器取值的几个方法： # next # for # 数据类型的强制转换 (不推荐，占用内存) 123456789101112def generator(): print(123) yield 1 print(456) yield 2 print(789)g = generator() # 得到一个生成器ret = g.__next__()print('***',ret) # 先打印123，然后拿到yield返回的1print('***',ret)print('***',ret) # 执行了789,由于后面没有yield,会报错StopIteration 生成器函数 — send123456789101112131415161718192021222324def generator(): print(123) send_msg = yield 1 print('======',send_msg) yield 2g = generator()ret = g.__next__()print('***',ret)ret = g.send('send_hello')print('***',ret)# 123# *** 1# ====== send_hello# *** 2# send用法总结# 1. send的获取下一个值的效果与next基本一致# 2. 只是在获取下一个值的时候给上一个yield的位置,传递一个数据# 使用send的注意事项# 1. 第一次使用生成器的时候,必须使用next获取下一个值# 2. 最后一个yield 不能接收外部的值,但是可以在接收arg=yield 2...最后返回一个空yield send实例 — 计算移动平均值123456789101112131415161718192021# 接收一次值计算平均值# 移动平均值# num: 10 20 30# avg: 10 15 20# 公式: avg = num / countdef avg_generator(): sum = 0 count = 0 avg = 0 num = yield # 第一次返回空，为了后面send传值(num)进来,10 sum += num # 总数有更新 10 count += 1 # 次数更新 avg = sum / count yield avg # send执行到这avg_g = avg_generator()avg_g.__next__() # 使用send第一次必须next，得到空avg1 = avg_g.send(10) # 传值(num)10进去print(avg1) 那么如何多次计算呢，需要加上循环123456789101112131415161718192021222324252627# 移动平均值# num: 10 20 30# avg: 10 15 20# 公式: avg = num / countdef avg_generator(): sum = 0 count = 0 avg = 0 while 1: # num = yield # 第一次返回空，为了后面send传值(num)进来,10 num = yield avg # 第一次的avg = 0 ，num = 传值 sum += num # 总数有更新 10 count += 1 # 次数更新 avg = sum / countavg_g = avg_generator()avg_g.__next__() # 使用send第一次必须next，得到空avg = avg_g.send(10) # 传值(num)10进去avg = avg_g.send(20)avg = avg_g.send(30)print(avg)# 每次计算方法:# 如果我加上while循环,现在我有两个yield,第一次结束到yield avg,第二次执行什么？# 如果执行next num = yield 相当于 num = 0# 下面再用一次send 传值20 再返回打印 计算移动平均值(2)_预激协程的装饰器123456789101112131415161718192021222324252627# 计算移动平均值# 用装饰器 激活__next__()def init(func): def inner(*args,**kwargs): g = func(*args,**kwargs) # g = generator() 拿到装饰器 g.__next__() # 执行__next__() return g # 返回装饰器 return inner@init # avg_generator = init(avg_generator) ==&gt; innerdef avg_generator(): sum = 0 count = 0 avg = 0 while True: # num = yield num = yield avg # num = 10,20,30 sum += num # sum = 10,30,60 count += 1 # count = 1,2,3 avg = sum / count # avg = 10,15,20g = avg_generator() # inner() # 执行这里 得到一个执行过next的装饰器# g.__next__() # 我不在这调用 而是在装饰器里avg = g.send(10) # 开始向生成器里里传值avg = g.send(20)avg = g.send(30)print(avg) yield fromyield from : 从一个容器类型里取值,不需要一个个返回，而是集体返回接收123456789101112131415# python 3# 将结果按个返回def generator(): a = 'abcde' b = '12345' # 单个字符串返回 for i in a: yield i for i in b: yield ig = generator()# print(g.__next__())for i in g: print(i) 12345678910111213# yield from 将结果按个返回def generator(): a = 'abcde' l = [1,2,3,4,5] # 单个字符串返回 yield from a # 生成器函数语法 yield from lg = generator()for i in g: print(i)# yield from 从一个容器类型里取值,不需要一个个返回，而是集体返回接收 1234567# 将两个类型的数据list转化成同一个def generator(): yield from range(0,5) yield from 'abcde'l = list(generator())print(l) # [0, 1, 2, 3, 4, 'a', 'b', 'c', 'd', 'e'] 生成器表达式列表推导式我们先写一个获取鸡蛋的程序1234egg_list = []for i in range(10): egg_list.append('鸡蛋%s'%i)print(egg_list) 在这里循环获取得到一个鸡蛋筐(列表),里面存着10个鸡蛋,列表推导式的写法如下12345egg_list = ['鸡蛋%s' %i for i in range(10)]print(egg_list)# 1. for i in range(10) 循环# 2. 将想要的 放在for前面# 3. 用列表括起来 列表推导式可以做一些简单的循环工作,那么这个时候我们就想,列表生成后可是存在内存里的，那如果是大数据怎么办，很占用内存，占用内存我们就想到了 生成器 生成器推导式生成器表达式 与 列表表达式 的不同 括号不一样 返回的值不一样 列表推导式得到的还是一个列表，一次性得到所有的值，占用内存 生成器表达式几乎不占用内存，但是不能直接应用,需要遍历循环取值，程序应该更关心内存123456789101112131415161718192021# 生成器表达式g = (i for i in range(10))print(g) # &lt;generator object &lt;genexpr&gt; at 0x0000000001EB92B0&gt; 生成器for i in g: print(i)# 获取鸡蛋例子egg_g = ('鸡蛋%s'%i for i in range(10)) # 生成器表达式for i in egg_g: # 相当于老母鸡,然后下蛋 print(i) # 每个数字都取平方# g里面的代码一句话没执行，直到for循环取值__next__,for循环每走一次,上面的range10的循环才走一次g = (i*i for i in range(10))for i in g: print(i) #列表解析sum([i for i in range(100000000)])#内存占用大,机器容易卡死#生成器表达式sum(i for i in range(100000000))#几乎不占内存 迭代器与生成器总结可迭代对象: 拥有__iter__方法 特点：惰性运算 例如: range(), str, list, tuple, dict, set 迭代器Iterator： 拥有__iter__方法和__next__方法 例如: iter(range()), iter(str), iter(list), iter(tuple), iter(dict), iter(set), reversed(list_o), map(func,list_o), filter(func, list_o), file_o 生成器Generator：本质：迭代器，所以拥有__iter__方法和__next__方法特点：惰性运算, 开发者自定义 使用生成器的优点： 延迟计算，一次返回一个结果。也就是说，它不会一次生成所有的结果，这对于大数据量处理，将会非常有用。 提高代码可读性]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 包的使用]]></title>
    <url>%2F2019%2F03%2F05%2Fpackage%2F</url>
    <content type="text"><![CDATA[什么是包包就是把解决一类问题的模块放在同一个文件目录里，这个文件目录就叫做包包是一种通过使用‘.模块名’来组织python模块名称空间的方式。 包的导入方法 – import1234567891011121314151617soft/ ├── bin │ ├── __init__.py│ └── start.py ├── core │ ├── __init__.py│ └── Manage.py │ └── login() └── cook.py 最外层是soft软件工程目录 bin 和 core 是两个包 bin 下有着start.py 程序入口文件 core 下有着Manage模块,里面带有一个login( )方法 整个目录还有一个cook.py文件 在soft目录下 12345678910# 想要在start.py 使用 Manage的login()方法# 通过查看sys.path路径发现只能找到soft的bin目录,所以不能直接import core,需要从soft开始import sysprint(sys.path) # D:\\PycharmProjects\\Notes\\soft\\binimport soft.core.Managesoft.core.Manage.login() # login in Manageimport soft.core.Manage as MM.login() # login in Manage 关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如,soft.core.Manage但都必须遵循这个原则。 对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。 from … import …123456789import osimport sys# 把soft目录加入到sys.path里去，然后就可以直接找到coresys.path.append(os.path.dirname(os.getcwd()))print(sys.path) # 'D:\\PycharmProjects\\Notes\\soft'from core import ManageManage.login() # login in Manage 1234567891011# 在core包下的文件引入其他包中的方法或者配置# 记得由于我们执行开始是在start.py中执行,所以一定要在里面导入路径# settings 文件中加入 DB_PATH = 'D:\PycharmProjects\Notes\soft\db'# Manageimport osfrom conf import settingsdef login(): print('login in Manage') file_name = os.path.join(settings.DB_PATH,'info.log') with open(file_name,'w') as f: f.write('Hello') 需要注意的是from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误可以用import导入内置或者第三方模块（已经在sys.path中），但是要绝对避免使用import来导入自定义包的子模块(没有在sys.path中)，应该使用from… import …的绝对或者相对导入,且包的相对导入只能用from的形式。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 模块的使用]]></title>
    <url>%2F2019%2F03%2F04%2Fmodule%2F</url>
    <content type="text"><![CDATA[什么是模块在Python中，一个.py文件就被称之为一个模块 模块的调用模块一旦被调用，即相当于执行另外一个另外一个py文件中的代码，多次import导入同一个模块，只会执行一次。 模块的导入 – import1234# demo.pymoney = 100def read(): print('in read',money) 12345678# func.pyimport demodef read(): print('my read func')money = 200read() # 自己本地的print(demo.money) # 调用模块的demo.read() # 调用模块的 模块导入流程 先从sys.modules里查看是否已经被导入 如果没有被导入就依据sys.path路径去寻找模块 找到了就导入，没有找到就报错 创建这个模块的命名空间 执行文件,把文件中的名字都放到命名空间中 sys.modules会加入这个模块，当这个模块再被impoet时就不会被重复导入 123456import sysimport demo# sys.modules 是一个字典，内部包含模块名与模块对象的映射，该字典决定了导入模块时是否需要重新导入print(sys.modules.keys())# sys.path 是python的搜索模块的路径listprint(sys.path) 导入模块的顺序 内置模块 time,re 扩展模块 pip3安装的 django 自定义模块 demo 单独导入 – from…import…123from time import sleepsleep(1)print('hey') 123456from demo import read,moneymoney = 200def read(): print('my read',money)read() # my read 200print(money) # 200 查看结果1. 如果本地有read()方法则优先调用本地的。2. 即使导入了money这个变量也无法替代本地变量,会发生冲突。为什么要使用 from…import?1. import是导入了模块里面的所有名字 比较占用内存。2. 导入一个变量进来，占用的内容较少,只要不用重名即可。 1234# 导入多个名字from demo import money,readprint(money) # 100print(read) # &lt;function read at 0x0000000000B62620&gt; 1234567891011121314151617# 导入全部* 配合 __all__# 如果在模块中定义了__all__ 那么如果import * ，只有存在这个列表中的名字才能调用# import demo 不受这个约束# demo__all__ = ['money','read'] # 只和 from demo import * 能配合起来money = 100def read(): print('in read',money)def read2(): print('in read2',money)# funcfrom demo import *print(money) # 100read() # in read 100read2() # NameError: name 'read2' is not defined 把模块当做脚本执行我们可以通过模块的全局变量name来查看模块名：12345# demo2print(__name__) # __main__# funcimport demo2 # demo2 当我在文件中import demo2的时候,demo2中的print(__name__)执行返回的是demo2 当我在demo模块中print(__name__)的时候返回的是 __main__ 在哪个页面页面上点的run 在哪个页面上就是__main__ 如果不在本页面上执行,在其他页面上调用模块名导入执行,那么就返回模块名 if name == ‘main‘: 作用:用来控制.py文件在不同的应用场景下执行不同的逻辑123456789101112131415# demo2def login(): print('正在执行登录程序')if __name__ == '__main__': print('in demo2.py') # in demo2.py ret = login() # 正在执行登录程序 print(ret) # None # funcimport demo2ret = demo2.login() # 正在执行登录程序print(ret) # None# 这样就符合了：模块导入的时候什么都不执行,所有想做的都放在模块里面去,在执行程序的时候就不会受影响，也能调用模块中想要的名字]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Readme]]></title>
    <url>%2F2019%2F03%2F04%2FReadme%2F</url>
    <content type="text"></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
