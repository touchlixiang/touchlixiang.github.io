<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[zabbix自定义脚本监控redis]]></title>
    <url>%2F2019%2F04%2F02%2Fpro2%2F</url>
    <content type="text"><![CDATA[编写监控redis qps 脚本结合zabbix展示之前公司的redis info显示执行了6亿次命令，造成cpu过高问题，现写下shell采集redis执行命令次数和ops然后通过zabbix做监控 监控脚本123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bashREDISCLI="/usr/local/bin/redis-cli"HOST="127.0.0.1"PORT=7007PASS="redis_pwd"if [[ $# == 1 ]];then case $1 in version) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info server | grep -w "redis_version" | awk -F':' '&#123;print $2&#125;'` echo $result ;; connected_clients) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info clients | grep -w "connected_clients" | awk -F':' '&#123;print $2&#125;'` echo $result ;; instantaneous_ops_per_sec) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info Stats | grep -w "instantaneous_ops_per_sec" | awk -F':' '&#123;print $2&#125;'` echo $result ;; total_commands_processed) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info Stats | grep -w "total_commands_processed" | awk -F':' '&#123;print $2&#125;'` echo $result ;; *) echo -e "\033[33mUsage: $0 &#123;version&#125;\033[0m" ;; esacelif [[ $# == 2 ]];then case $2 in keys) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info | grep -w "$1" | grep -w "keys" | awk -F'=|,' '&#123;print $2&#125;'` echo $result ;; *) echo -e "33[33mUsage: $0 &#123;db0 keys|db0 expires|db0 avg_ttl&#125;33[0m" ;; esacfi 在本地做测试1234[work@scripts]$ sh /data/backup/zabbix/scripts/redis_status_7007.sh total_commands_processed11958[work@scripts]$ sh /data/backup/zabbix/scripts/redis_status_7007.sh instantaneous_ops_per_sec0 修改zabbix_agent配置文件1234567vim /etc/zabbix/zabbix_agentd.confInclude=/etc/zabbix/zabbix_agentd.d/ # 简易脚本的执行目录...# 自定义脚本执行UserParameter=Redis_7007.Info[*],/data/backup/zabbix/scripts/redis_status_7007.sh $1 $2UserParameter=Redis_7010.Info[*],/data/backup/zabbix/scripts/redis_status_7010.sh $1 $2 重启zabbix agent服务1sudo /etc/init.d/zabbix-agent restart 在zabbix server端通过get测试12[work@scripts]$ zabbix_get -s 内网监控IP -p 10050 -k "Redis_7007.Info[total_commands_processed]"12051 12[work@scripts]$ zabbix_get -s 内网监控IP -p 10050 -k "Redis_7007.Info[instantaneous_ops_per_sec]"0 在zabbix平台配置监控项和触发器]]></content>
      <categories>
        <category>Linux运维</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看java进程占用cpu过高]]></title>
    <url>%2F2019%2F04%2F01%2Fpro1%2F</url>
    <content type="text"><![CDATA[查看java进程占用cpu过高之前平台出现过一次java进程占用cpu 100%的问题，发现后排查的几率如下: 使用top查找哪个继承占用cpu过高 记录下进程如:14492 把进程的栈dump到文件里，以便后面的分析 1jstack 14492 &gt; cpu0401.log 看看这个进程里面哪些线程在占用cpu 1top -p 14492 -H # 选择占用最高的 PID=5159 接着要看刚才dump出来的cpu日志了，里面会有14492这个进程下面每个线程的栈信息，但是是十六进制显示的，所以先把5159转换成16进制 1printf %0x 5159 # 1427 在cpu日志里找PID=1427的线程 1vim cpu0401.log]]></content>
      <categories>
        <category>Linux运维</category>
      </categories>
      <tags>
        <tag>进程占用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket 网络编程]]></title>
    <url>%2F2019%2F03%2F26%2Fsocket-server%2F</url>
    <content type="text"><![CDATA[tcp协议 和 udp协议TCP（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；电子邮件、文件传输程序。 UDP（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。 socket的基本使用TCP 的socket — 基础对话版12345678910111213141516171819# server端import socketsk = socket.socket() # 创建套接字sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) # 避免重用ip和端口sk.bind(('127.0.0.1',8090)) # 绑定端口sk.listen() # 监听链接conn,addr = sk.accept() # 接收客户端链接ret = conn.recv(1024) # 接收客户端消息print(ret) # 打印客户端消息conn.send(b'hello') # 向客户端发送消息 在网络上传输的只有二进制1010,所以必须是bytes类型ret = conn.recv(1024).decode('utf-8')print(ret)conn.send('吃面条吧'.encode('utf-8'))conn.close() # 关闭客户端链接sk.close() # 关闭服务端 123456789101112131415# client端import socketsk = socket.socket() # 创建客户端套接字sk.connect(('127.0.0.1',8090)) # 链接服务端# 接收|发送消息sk.send(b'hey') # 发送消息ret = sk.recv(1024) # 接收消息print(ret)sk.send('中午吃什么'.encode('utf-8'))ret = sk.recv(1024).decode('utf-8')print(ret)sk.close() 循环对话版12345678910111213141516171819202122232425262728# server端import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端开始监听...')conn,addr = sk.accept() # 获取到一个客户端的链接，已经完成了三次握手建立了一个连接 # 阻塞print('有新的链接进入&#123;&#125;'.format(addr))# 对话while 1: ret = conn.recv(1024).decode('utf-8') # 阻塞，直到收到客户端发来的消息 print(ret) if ret == 'bye': conn.send('bye'.encode('utf-8')) break msg = input('server:&gt;&gt;&gt;') if msg == 'bye': conn.send('bye'.encode('utf-8')) break conn.send(msg.encode('utf-8'))conn.close()sk.close() 1234567891011121314151617# client端import socketsk = socket.socket()sk.connect(('127.0.0.1',8090))while True: msg = input('client:&gt;&gt;&gt;') if msg == 'bye': sk.send('bye'.encode('utf-8')) break sk.send(msg.encode('utf-8')) ret = sk.recv(1024).decode('utf-8') if ret == 'bye': break print(ret)sk.close() 时间戳转换1234567891011121314151617181920212223242526272829303132ip_port = ('127.0.0.1',8090)# server端# server 接收时间戳时间，转化成格式化时间# client 每10秒time.time() 吧时间戳时间发给serverimport sysimport ossys.path.insert(0,os.path.dirname(os.getcwd()))import socketimport timefrom conf import settingssk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(settings.ip_port)sk.listen()print('服务端开始监听...')conn,addr = sk.accept()print('有新的链接进入&#123;&#125;'.format(addr))# 收发消息while 1: res = conn.recv(1024).decode('utf-8') if res == '': break print('client:%s' %res) msg = time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(float(res))) print(type(msg),msg) conn.send(('server:%s' %msg).encode('utf-8'))conn.close()sk.close() 12345678910111213141516171819202122# client端import timeimport socket# msg = time.time()# print(type(msg),msg) # float类型sk = socket.socket()sk.connect(('127.0.0.1',8090))count = 1while 1: if count &gt; 3: break now_time = str(time.time()) print(now_time) sk.send(now_time.encode('utf-8')) ret = sk.recv(1024).decode('utf-8') print(ret) time.sleep(3) count += 1sk.close() UDP 的socket — 基础对话版1234567891011# server import socketsk = socket.socket(type=socket.SOCK_DGRAM) # 创建一个服务器的套接字sk.bind(('127.0.0.1',8090)) # 绑定服务器套接字# 对话(接收与发送)msg,addr = sk.recvfrom(1024)print(msg.decode('utf-8'))sk.sendto(b'bye',addr) # 发送消息要带着地址sk.close() # 关闭服务器套接字 1234567891011# clientimport socketip_port = ('127.0.0.1',8090)sk = socket.socket(type=socket.SOCK_DGRAM)# 对话(接收与发送)sk.sendto(b'hello',ip_port) # 发送消息要带着地址ret,addr = sk.recvfrom(1024)print(ret.decode('utf-8'))sk.close() 在udp的消息通信的时候: 不需要进行监听 (listen) 不需要建立链接 (accept) 在启动服务之后，只能被动的等到客户端发送消息过来 客户端发送消息的同时，还会带着地址信息过来 服务端进行消息服务的时候，不仅需要发送消息，还需要带着对方的地址回去 UDP 实现简易QQ1234567891011121314151617# server import socketudp_sk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)udp_sk.bind(ip_port)print('Bind UDP on 9999...')while True: # 接收数据: data,addr = udp_sk.recvfrom(1024) data = data.decode('utf-8') print(('Received from %s:%s') %(addr,data)) msg = input('server:&gt;&gt;&gt;') udp_sk.sendto(msg.encode('utf-8'),addr)udp_sk.close() 123456789101112131415# client import socketip_port = ('127.0.0.1',9999)udp_sk = socket.socket(type=socket.SOCK_DGRAM)while True: msg = input('client:&gt;&gt;&gt;') msg = '\033[32mform client1:%s\033[0m' %msg udp_sk.sendto(msg.encode('utf-8'),ip_port) data,addr = udp_sk.recvfrom(1024) data = data.decode('utf-8') print(('Received from %s:%s') %(addr,data))udp_sk.close() UDP 实现简易时间同步123456789101112131415161718192021222324# server # server端提供时间同步服务# 接收信息 时间的格式# 将server端时间 转换成 接收到的格式# 返回给clientimport socketimport timesk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)sk.bind(ip_port)print('Bind UDP on 9999...')while True: data,addr = sk.recvfrom(1024) data = data.decode('utf-8') # print(type(data),data) print('form %s:%s' %(addr,data)) # time_str = time.strftime(data,time.localtime(time.time())) time_str = time.strftime(data) print(type(time_str),time_str) sk.sendto(str(time_str).encode('utf-8'),addr)sk.close() 1234567891011121314151617# client import socketsk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)time_format = '%Y-%m-%d %H:%M:%S'sk.sendto(time_format.encode('utf-8'),ip_port)data,addr = sk.recvfrom(1024)data = data.decode('utf-8')print(data)sk.close()# 操作方式:# 1、操作系统定时任务 + python代码# 2、while True + time.sleep 黏包现象subprocess 远程执行命令12345678import subprocessres = subprocess.Popen('dir',shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)print('stdout:' + res.stdout.read().decode('gbk')) # windows默认控制台输出 gbkprint('stderr:' + res.stderr.read().decode('gbk')) # windows默认控制台输出 gbk# stdout=subprocess.PIPE 标准输出放入管道# stderr=subprocess.PIPE 错误输出放入管道# 结果的编码是以当前所在的系统为准的，如果是windows，那么res.stdout.read()读出的就是GBK编码的，在接收端需要用GBK解码 TCP的黏包现场12345678910111213141516171819202122232425# 在server端下发命令import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务器端口8090开始监听')conn,addr = sk.accept()print('有新的链接请求&#123;&#125;'.format(addr))while 1: cmd = input('cmd:&gt;&gt;&gt;') conn.send(cmd.encode('utf-8')) ret = conn.recv(1024).decode('utf-8') # windows控制台是GBK print(ret)conn.close()sk.close()# 执行的命令# 1. dir;ls# 2. ipconfig# 发生的问题:# 象数据没有接收完全 或者 接收多了 这种现象就是“黏包” 12345678910111213141516171819202122# 在client端接收命令并执行返回import socketimport subprocesssk = socket.socket()sk.connect(('127.0.0.1',8090))while True: cmd = sk.recv(1024).decode('gbk') res = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) # print('stdout:' + res.stdout.read().decode('gbk')) # windows默认控制台输出 gbk # print('stderr:' + res.stderr.read().decode('gbk')) # windows默认控制台输出 gbk # 这里的res得到的是gbk格式，需要解码整体转换成str std_out = 'stdout: ' + (res.stdout.read()).decode('gbk') std_err = 'stderr: ' + (res.stderr.read()).decode('gbk') print(type(std_out),std_out) print(type(std_err),std_err) sk.send(std_out.encode('utf-8')) sk.send(std_err.encode('utf-8'))sk.close() UDP的黏包现象12345678910111213141516171819202122232425262728293031# serverimport socketsk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)sk.bind(ip_port)print('Bind UDP on 9999...')data,addr = sk.recvfrom(1024)while 1: cmd = input('cmd:&gt;&gt;&gt;') if cmd == 'q': break sk.sendto(cmd.encode('utf-8'),addr) data,addr = sk.recvfrom(10240) print(data.decode('utf-8'))sk.close()# 操作：# 1. ipconfig# 2. dir# udp# udp不会黏包# udp会丢包# tcp# tcp会黏包# tcp不会丢包# 内部优化算法 让整个程序发送数据和接收数据没有边界 12345678910111213141516171819202122# clientimport socketimport subprocesssk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)sk.sendto('吃了吗？'.encode('utf-8'),ip_port)while 1: cmd,addr = sk.recvfrom(1024) # bytes if cmd == 'q': break res = subprocess.Popen(cmd.decode('gbk'),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) std_out = 'std_out:' + res.stdout.read().decode('gbk') std_err = 'std_err:' + res.stderr.read().decode('gbk') print(std_out) print(std_err) sk.sendto(std_out.encode('utf-8'),addr) sk.sendto(std_err.encode('utf-8'),addr)sk.close()]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lambda 匿名函数]]></title>
    <url>%2F2019%2F03%2F25%2Fanonymous%2F</url>
    <content type="text"><![CDATA[匿名函数基础语法匿名函数的作用: 为了解决那些功能很简单的需求而设计的一句话函数 语法：func(函数名) = lambda(关键字) 参数:返回值 参数可以有多个，用逗号隔开 匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值 返回值和正常的函数一样可以是任意数据类型 123456# 把以下函数变成匿名函数def add(x,y): return x+y add = lambda x,y:x+yprint(add(1,2)) # 3 匿名函数和其他功能函数合作lambda 常常和几个内置函数一起使用 max min sorted filter map 和max函数配合12345678910111213141516171819202122# 字典取最大值的key# 字典取最大值dic=&#123;'k1':10,'k2':100,'k3':30&#125;ret = max(dic,key=dic.get)print(dic[ret]) # 100# 字典取最大值的键dic2=&#123;'k1':10,'k2':100,'k3':30&#125;ret1 = max(dic2)print(ret1) # k3 key按照文本大小的最大值# 字典取最大值的键dic2=&#123;'k1':10,'k2':100,'k3':30&#125;def max_dict_key(key): return dic2[key]ret = max(dic2,key=max_dict_key)print(ret) # k2# lambda 匿名一句话函数ret = max(dic2,key=lambda key:dic2[key])print(ret) # k2 和filter函数配合123456789101112# filter 配合 lambda#取出数组中大于10的数据 [5,8,11,9,15]def func(x): return x &gt; 10ret = filter(func,[5,8,11,9,15])for i in ret: print(i) # 11 15# lambda 匿名一句话函数ret = filter(lambda x:x &gt; 10,[5,8,11,9,15])for i in ret: print(i) # 11 15 和map函数配合1234567891011121314ret = map(abs,[-1,2,-3,4])for i in ret: print(i) # 1,2,3,4def func_map(x): return x**2ret = map(func_map,[-1,2,-3,4])for i in ret: print('func_map:',i)# lambda 匿名一句话函数ret = map(lambda x:x**2,[-1,2,-3,4])for i in ret: print('func_map_lanbda:',i) 匿名函数面试题12345678# 1.下面程序的输出结果是：d = lambda p:p*2t = lambda p:p*3x = 2x = d(x) # 4x = t(x) # 12x = d(x) # 24print(x) # 24 1234567891011121314151617# 2.现有两元组(('a'),('b')),(('c'),('d')) ,请使用python中匿名函数生成列表[&#123;'a':'c'&#125;,&#123;'b':'d'&#125;]# lambda# zipret = zip((('a'),('b')),(('c'),('d')))# for i in ret:# print(i)# def func(tup):# return &#123;tup[0]:tup[1]&#125;# res = map(func,ret)# for i in res:# print(i)res = map(lambda tup:&#123;tup[0]:tup[1]&#125;,ret)print(list(res)) # [&#123;'a': 'c'&#125;, &#123;'b': 'd'&#125;]]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>匿名函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置函数]]></title>
    <url>%2F2019%2F03%2F19%2Ffunction%2F</url>
    <content type="text"><![CDATA[内置函数什么是内置函数? 就是python给你提供的. 拿来直接用的函数,比如print., input等等.截止 到python版本3.6.2 python一共提供了68个内置函数. 有一些我们已经用过了.有一些还没有用过. 还有一些需要学完了面向对象才能继续学习的. 作用域相关(2) locals() 和 globals() 基于字典的形式获取局部变量和全局变量12print(locals()) # 返回本地作用域中的所有名字print(globals()) # 返回全局作用域中的所有名字 迭代器/生成器相关(3) range(),next() 和 iter()Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。1234567# range# range(10)# range(1,11)# range(1,11,2) # 步长取值print('__iter__' in dir(range)) # True 可迭代的print('__next__' in dir(range)) # False 不是迭代器print('__next__' in dir(iter(range(1,11,2)))) # True next(迭代器),迭代器向下执行一次,内部实际上调用迭代器.__next__()方法iter(可迭代的),用来生成一个迭代器12345678910# next 和 iterl = [1,2,3,4,5]it = iter(l) # 转成迭代器 print(type(it)) # &lt;class 'list_iterator'&gt;while 1: try: print(next(it)) except StopIteration: # 遇到StopIteration就退出循环 break 其他(12) 查看内置属性(1) dir() 默认查看全局空间内的属性，也接受一个参数，查看这个参数内的方法或变量12print(dir()) # 获得当前模块的属性列表print(dir([])) # 查看列表的方法 调用相关(1) callable() callable 用来检查一个对象是否可被调用对于函数、方法、lambda 函式、 类以及实现了 __call__ 方法的类实例, 它都返回 True。123a = 1print(callable(a)) # Falseprint(callable(print)) # True 帮助(1) help() 用于查看函数或模块用途的详细说明在控制台执行help()进入帮助模式。可以随意输入变量或者变量的类型。输入q退出或者直接执行help(o)，o是参数，查看和变量o有关的操作。。。1help(str) 模块相关(1) import() 导入模块1import time 文件操作相关(1) open() 打开一个文件，返回一个文件操作符(文件句柄)操作文件的模式有r,w,a,r+,w+,a+ 共6种，每一种方式都可以用二进制的形式操作(rb,wb,ab,rb+,wb+,ab+)可以用encoding指定编码.123f = open('01 内置函数.py')print(f.writable()) # 判断当前文件是否可写print(f.readable()) # 判断当前文件是否可读 内存相关(2) id() id()函数用于获取对象的内存地址。123# id(o) o是参数，返回一个变量的内存地址a = 100print(id(a)) # 1497027344 hash() 用于获取取一个对象（字符串或者数值等）的哈希值。hash() 函数可以应用于数字、字符串和对象，不能直接应用于 list、set、dictionary。获取到对象的哈希值(int, str, bool, tuple) hash函数会根据一个内部的算法对当前可hash变量进行处理，返回一个int数字。 每一次执行程序，内容相同的变量hash值在这一次执行过程中不会发生改变。1234print(hash(12345)) # 12345print(hash('abcde')) # -5832084034581495945print(hash(('a','b'))) # -3079515087831999849# print(hash(['a',1,'b',2])) # 报错:TypeError: unhashable type: 'list' 不可哈希 输入输出(2) input() 获取用户输入12content = input('&gt;&gt;&gt;')print(type(content),content) # input得到的是字符串类型 print() 打印输出12345# 关键字传参 end默认为'\n'，指定不是回车即可# 这就是我们为什么使用print的时候会出现换行,end的值修改成了空字符串print('我们的祖国是花园\n',end='')print('我们的祖国是花园\n',end='')print('我们的祖国是花园\n') 123# sep 打印多个值之间的分隔符，默认为空格print(1,2,3,4,5) # 1 2 3 4 5 多个值之间空格隔开print(1,2,3,4,5,sep='|') # 1|2|3|4|5 指定分隔符 12345# file: 默认是输出到屏幕，如果设置为文件句柄，输出到文件# flush: 立即把内容输出到流文件，不作缓存f = open('file','w')print('aaa',file=f,flush=True)f.close() 字符串类型代码的执行(3) eval() eval() 将字符串类型的代码执行并返回结果1print(eval('1+2+3+4')) # 10 有返回值 ——有结果的简单计算 exec() exec() 将自字符串类型的代码执行12345print(exec('1+2+3+4')) # None 没有返回值 ——简单的流程控制# exec 和eval都可以执行 字符串类型的代码# 区别是eval有返回值，exec没有# eval只能用在明确知道要执行的代码 compile() 将字符串类型的代码编译。代码对象能够通过exec语句来执行或者eval()进行求值。1234#流程语句使用exec# code1 = 'for i in range(0,10): print (i)'# compile1 = compile(code1,'','exec')# exec (compile1) 1234#简单求值表达式用eval# code2 = '1 + 2 + 3 + 4'# compile2 = compile(code2,'','eval')# print(eval(compile2)) 12345#交互语句用singlecode3 = 'name = input("please input your name:")'compile3 = compile(code3,'','single')exec(compile3)# print(name) # leo 执行exec后就存在name 基础数据类型相关(38)和数字相关(14) bool() bool() 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。int –&gt; bool 非0为True，0为False1234n1 = 10print(bool(n1)) # Truen2 = 0print(bool(n2)) # False int() int() 函数用于将一个字符串或数字转换为整型。​int() 将给定的数据转换成int值. 如果不给值, 返回012345678# int# str 转换成 int 只能转换数字字符串str1 = '10'print(int(str1)) # 10# int 转换成 str 数字可以转换成任何字符串num = 5print(str(num)) float() ﬂoat() 将给定的数据转换成ﬂoat值. 也就是浮点数 浮点数包括: 有限循环小数 无线循环小数 小数包括: 有限循环小数 无线循环小数 无线不循环小数12345# 浮点数# 354.123 == 3.54123 * 10**2 == 35.4123 * 10 在这个过程中点是浮动的 所以才叫浮点数f = 1.78789787079889 # 当小数特别长的时候 就有可能不准了 二进制转小数会有问题就会不准print(float(1)) # 1.0print(float('123') ) # 转换字符串 123.0 complex() complex() 创建一个复数. 第一个参数为实部, 第二个参数为虚部. 或者第一个参数直接 用字符串来描述复数 实数: 有理数 ： 整数 有限循环小数 无线循环小数 无理数 ： 无线不循环小数 π 虚数: 虚无缥缈的数123# python里面的虚数 = 12j (j是单位)# 5 + 12j === 复合的数 == 复数 (复数之间是无法比较大小的)print(complex(1, 2)) # (1+2j) bin() 1print(bin(10)) # 十进制转二进制 # 0b1010 oct() 1print(oct(10)) # 十进制转十进制 # 0o12 hex() 1print(hex(10)) # 十进制转十六进制 # 0xa abs() abs() 函数返回数字的绝对值。123# abs求绝对值 负的转正的 正的还是正的print(abs(-5)) # 5print(abs(10)) # 10 divmod() 12345# divmod 接收两个参数 div 除法 mod 取余# 除余方法# 分页的时候 会用到print(divmod(7,2)) # (3, 1)print(divmod(9,5)) # (1, 4) round() round() 方法返回浮点数x的四舍五入值。1print(round(3.14159,2)) # 3.14 2代表保留两位 支持四舍五入 pow() 1234# pow 求幂运算print(pow(2,3)) # 8print(pow(3,2,1)) # 0 三个参数就是 == 3的2次幂 对 1取余 幂运算之后再取余print(pow(2,3,3)) # 2 sum() ​sum() 求和12345678# sum(iterable[, start])# start 从几开始相加# 列表计算总和后再加10ret = sum([1,2,3],10)print(ret) # 16ret = sum((1,2,3))print(ret) # 6 min() min()计算最小值12345# min(iterable,key,default)# min(*args,key,default)print(min([1,2,3])) # 1print(min(1,2,3)) # 1print(min((1,2,3,-4),key=abs)) # 1 key=abs 以绝对值的方法来计算 max() min()计算最大值12345# max(iterable,key,default)# max(*args,key,default)print(max([1,2,3])) # 3print(max(1,2,3)) # 3print(max((1,2,3,-4),key=abs)) # -4 key=abs 以绝对值的方法来计算 和数据结构相关(24) list() list() 用于将元组或字符串转换为列表。注：元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中。1234str1="Hello World"print(list(str1)) # ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']tup1 = (1,2,3,'leo')print(list(tup1)) # [1, 2, 3, 'leo'] tuple() tuple()函数将列表转换为元组。。12l1= ['Google', 'Taobao', 'Runoob', 'Baidu']print(tuple(l1)) # ('Google', 'Taobao', 'Runoob', 'Baidu') reversed() reversed() 返回一个反向的迭代器12345678910# list.reverse() # 列表的反转方法l2 = [1,2,3,4]l2.reverse()print(l2) # [4, 3, 2, 1] 原本的列表发生变化l3 = [1,2,3,4,5]iter_l = reversed(l3) # 保留原列表,返回一个反向的迭代器print(iter_l) # &lt;list_reverseiterator object at 0x000000000288CF98&gt; 迭代器for i in iter_l: print(i) slice() slice() 函数实现切片对象，主要用在切片操作函数里的参数传递。1234l = (1,2,23,213,5612,342,43)sli = slice(1,5,2) # 切片规则print(l[sli]) # (2, 213)print(l[1:5:2]) # (2, 213) str() str() 将数据转化成字符串1234l4 = [1,2,3]print(str(l4)) # [1, 2, 3]dict4 = &#123;'name':'leo'&#125;print(str(dict4)) # &#123;'name': 'leo'&#125; format() format() 字符串格式化1234567print("&#123;&#125;,&#123;&#125;".format('leo','lex')) # leo,lex 不设置指定位置，按默认顺序print("&#123;0&#125;,&#123;1&#125;,&#123;0&#125;".format('leo','lex')) # leo,lex,leo 设置指定位置print("名字:&#123;name&#125;,年龄&#123;age&#125;".format(name='leo',age='30')) # 名字:leo,年龄30# 通过字典设置参数info = &#123;'name':'leo',"age":29&#125;print("名字:&#123;name&#125;,年龄&#123;age&#125;".format(**info)) # 名字:leo,年龄29 bytes() bytes 将数据转换成bytes类型12345# 拿到的事gbk编码，想要转换成utf-8编码print(bytes('您好',encoding='GBK')) # b'\xc4\xfa\xba\xc3' unicode转成 GBKprint(bytes('您好',encoding='utf-8')) # b'\xe6\x82\xa8\xe5\xa5\xbd' unicode 转 utf-8# gbk -&gt; decode（解码） unicode -&gt; encode(编码) utf-8 bytearray() bytes类型的数组123b_array = bytearray('您好',encoding='utf-8')print(b_array) # bytearray(b'\xe6\x82\xa8\xe5\xa5\xbd')print(b_array[0]) # 230 memoryview() memoryview() 函数返回给定参数的内存查看对象(Momory view)。所谓内存查看对象，是指对支持缓冲区协议的数据进行包装，在不需要复制对象基础上允许Python代码访问。1234ret = memoryview(bytes('你好',encoding='utf-8'))print(len(ret))print(bytes(ret[:3]).decode('utf-8'))print(bytes(ret[3:]).decode('utf-8')) ord() 字符按照unicode转数字123print(ord('A')) # 65print(ord('a')) # 97print(ord('1')) # 49 chr() 数字按照unicode转字符12print(chr(65)) # Aprint(chr(49)) # 1 ascii() 只要是ascii码(字母、数字、符号、拉丁文)就显示，不是的话就打印\u类型12print(ascii('好')) # '\u597d'print(ascii('l')) # l repr() repr格式化,原形毕露12345name = 'egg'print('你好%s' %name) # 你好egg %s ==&gt; strprint('你好%r' %name) # 你好'egg' %r ==&gt; reprprint(repr('1')) # '1'print(repr(1)) # 1 dict() 创造字典12print(dict()) # &#123;&#125;print(dict(a=1,b=2,c=3)) # &#123;'a': 1, 'b': 2, 'c': 3&#125; set() set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等123456x = set('runoob')y = set('google')print((set(['b', 'r', 'u', 'o', 'n']), set(['e', 'o', 'g', 'l'])) ) # 重复的被删除print(x &amp; y) # 交集 &#123;'o'&#125;print(x | y ) # 并集 &#123;'r', 'o', 'l', 'n', 'e', 'u', 'b', 'g'&#125;print(x - y ) # 差集 &#123;'r', 'b', 'n', 'u'&#125; frozenset() 生成一个新的不可变集合,它可以作为字典的key12a = frozenset(range(10)) # 生成一个新的不可变集合b = frozenset('runoob') 重要的内置参数 len() 返回对象的长度或者元素个数1234test = 'abcde'list1 = [1,2,3]print(len(test)) # 5 字符串长度print(len(list1)) # 3 列表元素个数 enumerate() enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中enumerate(sequence, [start=0]) sequence – 一个序列、迭代器或其他支持迭代对象。 start – 下标起始位置。123456seasons = ['Spring', 'Summer', 'Fall', 'Winter']list2 = list(enumerate(seasons))print(list2) # [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]list3 = list(enumerate(seasons, start=1)) # 小标从 1 开始print(list3) # [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] all() 有任何一个空内容就是false123print(all(['a','',123])) # Falseprint(all(['a',123])) # Trueprint(all([0,123])) # False any() 有一个正确的就是True1print(any(['',True,0,[]])) # True zip() zip 拉链方法,如果少一个元素无法对应上，就不加入,以最小的数据类型为准12345678910l1 = [1,2,3]l2 = ['a','b','c','d']t3 = ('*','**',[1,2])d4 = &#123;'k1':'1','k2':'2'&#125;print(zip(l1,l2)) # &lt;zip object at 0x00000000028422C8&gt;for i in zip(l1,l2,t3,d4): print(i)# (1, 'a', '*', 'k1')# (2, 'b', '**', 'k2') filter() filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象,如果要转换为列表，可以使用 list() 来转换。filter() 函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。1234567891011121314151617# 过滤列表中的奇数def is_odd(x): return x % 2 == 1 # 奇数# 第一个参数 函数方法# 第二个参数 可迭代的# 可迭代的里面的每个数据都会传入前面的函数# 根据函数的结算结果筛选,为True的才会留下，最后返回一个迭代器ret = filter(is_odd,[1,3,5,8,10])print(ret) # &lt;filter object at 0x00000000027A8780&gt; 迭代器# for i in ret:# print(i) # 迭代器节省内存print(list(ret)) # [1, 3, 5]# 相当于列表推导式l2 = [i for i in [1,3,5,8,10] if i % 2 == 1]print(l2) # [1, 3, 5] 12345678# 名字有两个e的结果names = ['leo','leex','rubin','lee']def func(name): return name.count('e') &gt;= 2iter_names = filter(func,names)for i in iter_names: print(i) # leex,lee 12345678910# 只保留字符串l3 = [1,'leo',2,'rubin',3]def is_str(s):# if type(s) == str:# return True return type(s) == striter_names = filter(is_str,l3)for i in iter_names: print(i) # leo,rubin 123456789# 删除列表中的None和空字符串l4 = ['test', None, '', 'str', ' ', 'END']def is_none(s): if type(s) != int: return s and str(s).strip()iter_none = filter(is_none,l4)for i in iter_none: print(i) 12345678# 练习：请利用filter()过滤出1~100中平方根是整数的数，即结果应该是：from math import sqrt # 开平方print(sqrt(64)) # 8.0def init_sqrt(num): res = sqrt(num) return res % 1 == 0 # 除1余0就是整数iter_sqrt = filter(init_sqrt,range(1,101))print(list(iter_sqrt)) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] map() Python中的map函数应用于每一个可迭代的项，返回的是一个结果list。如果有其他的可迭代参数传进来，map函数则会把每一个参数都以相应的处理函数进行迭代处理。map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。1234567891011# map 有点像 [i for i in [1,2,3]]ret = map(abs,[-1,-2,3,-8])for i in ret: print(i) # 1,2,3,8# filter 执行了filter之后的记过集合 &lt;= 执行之前的个数 # filter只管筛选，不会改变原来的值# map 执行前后元素个数不变，值变了 # 值可能发生改变 # 要注意配合匿名函数 sorted() 对List、Dict进行排序，Python提供了两个方法对给定的List L进行排序，方法1.用List的成员函数sort进行排序，在本地进行排序，不返回副本方法2.用built-in函数sorted进行排序（从2.4开始），返回副本，原始输入不变1234567891011121314151617181920# sortl = [1,-4,6,5,-10]l.sort(key=abs) # 在原列表的基础上进行排序print(l) # [1, -4, 5, 6, -10]# sorted# 会生成一个新的数据,保留原来数据# 排序的过程中负载的算法不支持产生一个迭代器l = [1,-4,6,5,-10]print(sorted(l)) # [-10, -4, 1, 5, 6] # 生成一个新列表，不改变原列表 占内存print(l) # [1, -4, 6, 5, -10] # 源列表不变# reversed() 倒叙 返回一个反向的迭代器# sorted() 排序 返回listprint(sorted(l,key=abs)) # [1, -4, 5, 6, -10]# 列表按照每一个元素的len排序l = [[1,2],[3,4,5,6],(7,),'123']print(sorted(l,key=len)) # [(7,), [1, 2], '123', [3, 4, 5, 6]]]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器面试题]]></title>
    <url>%2F2019%2F03%2F18%2Fcase-generator%2F</url>
    <content type="text"><![CDATA[生成器面试题12345678910111213141516171819def demo(): # 生成器函数 for i in range(4): yield ig=demo() # 生成器# 生成器表达式g1=(i for i in g) # 没执行g2=(i for i in g1)# 数据类型强转print(list(g1)) # [0, 1, 2, 3] # 执行了,g1生成器找g取值print(list(g2)) # [] # g2找g1拿值，g1已经没有值了.所以是空,把g1注释掉,g2就有值了# 一个生成器里面的能用只能取一次,你不找他要，他也不会给你# g1=(i for i in g) 没干活，因为他返回了个 生成器#def g1():# for i in g:# yield i 123456789101112131415161718192021222324252627def add(n,i): return n+idef test(): for i in range(4): yield ig=test()for n in [1,10]: g=(add(n,i) for i in g) # 生成器表达式# 当遇见这种问题的时候 先将循拆开# for循环套生成器表达式# n = 1# g=(add(n,i) for i in g) # test()# n = 10# g=(add(n,i) for i in g) # (add(n,i) for i in g)# 2 带入方程# g=(add(n,i) for i in test())# g=(add(n,i) for i in (add(10,i) for i in test()))# n = 10# g=(add(n,i) for i in (add(10,(0,1,2,3))# n = 10# g=(add(10,i) for i in (10,11,12,13))# 20,21,22,23print(list(g)) # 开始执行 12345678910111213141516171819202122def add(n,i): return n+idef test(): for i in range(4): yield ig=test()for n in [1,10,5]: g=(add(n,i) for i in g) # 生成器表达式# n = 1# g=(add(n,i) for i in test())# n = 10# g=(add(n,i) for i in (add(n,i) for i in test()))# n = 5# g=(add(n,i) for i in (add(n,i) for i in (add(n,i) for i in test())))# g=(add(n,i) for i in (add(n,i) for i in (add(n,i) for i in (0,1,2,3))))# g=(add(n,i) for i in (add(n,i) for i in (5,6,7,8)))# g=(add(n,i) for i in (10,11,12,13)# 15,16,17,18print(list(g)) # 开始执行]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种推导式]]></title>
    <url>%2F2019%2F03%2F15%2Fcomprehensions%2F</url>
    <content type="text"><![CDATA[推导式的套路: 新的列表 = [ 每一个元素或者是和元素相关的操作 for 元素 in 可迭代数据类型 ] # 遍历之后挨个处理 新的列表 = [ 满足条件的元素相关的操作 for 元素 in 可迭代数据类型 if 元素相关的条件 ] # 筛选功能 列表推导式12345678910111213141516171819202122# 例一：30以内所有能被3整除的数l = [ i for i in range(30) if i % 3 == 0 ]print(l)# 例二：30以内所有能被3整除的数的平方l = [ i**2 for i in range(30) if i % 3 == 0 ]print(l)# 例三:找到嵌套列表中名字含有两个‘e’的所有名字names = [['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe'], ['Alice', 'Jill', 'Ana', 'Wendy', 'Jennifer', 'Sherry', 'Eva']]# 常规循环#for l in names:# for name in l:# if name.count('e') &gt;= 2:# print(name)# 二维列表# 注意遍历顺序，这是实现的关键l = [name for l in names for name in l if name.count('e') &gt;= 2]print(l) 字典推导式12345678910111213141516171819# 字典推导式# 例一：将一个字典的key和value对调mcase = &#123;'a': 10, 'b': 34&#125;# 常规循环# for k in mcase:# mcase[k] : k # v : k# print(mcase)mcase = &#123;mcase[k]:k for k in mcase&#125;print(mcase)# 例二：合并大小写对应的value值，将k统一成小写# 所有的推导式都从for开始看mcase = &#123;'a': 10, 'b': 34, 'A': 7, 'Z': 3&#125;# &#123;'a':10+7,'b':34,'z':3&#125;mcase_frequency = &#123;k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()&#125;# 拿到所有key# key值就是要小写k.lower():# mcase.get(k.lower(), 0)没有小写的就默认写一个0 + mcase.get(k.upper(), 0) 相当于小写+大写的值,没有就给0print(mcase_frequency) 集合推导式12345# 集合推导式 可以替重# &#123;&#125;# 例：计算列表中每个值的平方，自带去重功能squared = &#123;x**2 for x in [1, -1, 2]&#125;print(squared) # -1的平方和1的平方一样 所以去重之后2个结果，如果是列表就不会自动去重 总结各种推导式:生成器 列表 字典 集合 遍历 筛选 带if 优点 推导式能让你的代码更简洁， 可读性提高 惰性运算: 懒 不去找他要值不会执行，要一个执行一个 生成器(自己写的，可见)和迭代器（不可见的，python提供）特点 同一个迭代器,从头到尾取值只能取一次 不找他要值的时候不干活 练习1234567891011121314151617# 例1: 过滤掉长度小于3的字符串列表，并将剩下的转换成大写字母names = ['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe']new_l = [name.upper() for name in names if len(name) &gt; 3]print(new_l)# 例2: 求(x,y)其中x是0-5之间的偶数，y是0-5之间的奇数组成的元祖列表l1 = [(x,y) for x in range(5) if x%2==0 for y in range(5) if y %2==1]l2 = [(x,y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]print(l1)print(l2)# 求M中3,6,9组成的列表M = [[1,2,3],[4,5,6],[7,8,9]]# for i in M:# print(i[2])l3 = [row[2] for row in M]print(l3)]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>列表推导式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 装饰器]]></title>
    <url>%2F2019%2F03%2F13%2Fdecorator%2F</url>
    <content type="text"><![CDATA[简单的装饰器使用比如现在公司有一个需求，每个函数都要计算运行时间，我们可以调用time模块实现一个简单的计算执行时间的方法 1234567891011import time# 统计每个函数的执行时间 1def func(): start_time = time.time() print('func 1') time.sleep(3) now_time = time.time() return now_time - start_timeret = func() # func 1print(ret) # 3.000171661376953 那如果要是有200多个函数呢，难道要一个个加入，然后在一个个删除？我们想到计算时间可以单独写一个函数去调用。123456789101112# 调用统计时间函数def timmer(f): start_time = time.time() f() end_time = time.time() print(end_time - start_time)def func(): time.sleep(3) print('func 1')timmer(func) 这样以后的200个函数都要使用timmer去调用执行么？也是不合理的，应该是func方法来调用时间函数，比较合理。 装饰器的形成过程1234567891011121314151617181920# 我们想要做到的:# 1 不想修改函数的调用方式 但是还想再原来的函数前后添加功能# 2 timmer就是一个装饰器函数，只是对一个函数 有一些装饰作用def func(): time.sleep(3) print('func 1')# 调用统计时间函数# 闭包 内部函数inner,调用了外部变量f,f是传进来的def timmer(f): # 装饰器函数 def inner(): start_time = time.time() f() # 被装饰的函数 end_time = time.time() print(end_time - start_time) return innerfunc = timmer(func)func() 运行过程流程图: 原来的函数为func 最后我还是要调用func 中间增加的计时功能timmer 通过func = timmer(func) 和 闭包函数 来进行修饰 最终通过闭包函数来返回内部函数 交给 外部的func接收，接收的变量还是原本func的方法 最后执行外部的func()，他会自动去找装饰函数inner(),再去找到原本被装饰的函数func() 总结:装饰器的本质：一个闭包函数装饰器的功能：在不修改原函数及其调用方式的情况下对原函数功能进行扩展装饰器的意义： 装饰器既没有改变函数的调用方式，又在函数的前后增加了装饰功能 开放封闭原则开放: 对扩展是开放的,任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。 封闭: 对修改是封闭的,因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对其进行了修改，很有可能影响其他已经在使用该函数的用户。 装饰器完美的遵循了这个开放封闭原则 语法糖@装饰器函数 == 重新定义被装饰函数=装饰器函数（被装饰函数）12345678910111213141516171819import timedef timmer(f): # 装饰器函数 def inner(): start_time = time.time() f() # 被装饰的函数 end_time = time.time() print(end_time - start_time) return inner# 语法糖 @timmer 让代码更好看 更便捷# 在被装饰的函数上面贴着加上 @装饰器函数名 # 就相当于写了func = timmer(func)@timmerdef func(): time.sleep(3) print('func 1')# func = timmer(func)func() 装饰带返回值的函数的装饰器12345678910111213141516171819202122import timedef timmer(f): # 装饰器函数 def inner(): start_time = time.time() ret = f() # 被装饰的函数 带有返回值 end_time = time.time() print(end_time - start_time) return ret # 返回被装饰的函数的返回值 return inner@timmerdef func(): time.sleep(3) print('func 1') return '新年好' # 被装饰的函数的返回值# func = timmer(func)ret = func()print(ret)# 因为现在的func不是原来的func 而是inner ，所有要对inner中增加返回值# 现在的func就是inner,ret接收的事inner的返回值 装饰带一个参数的函数12345678910111213def wrapper(func): def inner(name): ret = func(name) return ret return inner@wrapper # func = wrapper(func)def func(name): return '新年好,%s'%nameret = func('leo')print(ret) 接收万能参数装饰器1234567891011121314151617def wrapper(func): def inner(*args,**kwargs): # print('函数被装饰之前要做的事') print(*args) # leo python print(kwargs) # &#123;'age': 30&#125; print(kwargs['age']) # 30 ret = func(*args,**kwargs) # print('函数被装饰之前要做的事') return ret return inner@wrapperdef func(name,course,age): return '大家好,我是%s,今年%d,现在正在学习%s'%(name,age,course)ret = func('leo','python',age=30)print(ret) # 大家好,我是leo,今年30,现在正在学习python 装饰器的固定格式123456789101112131415161718import time# 单纯就叫装饰器的时候 -- wrapperdef wrapper(f): # 装饰器函数,f是被装饰的函数,装饰器函数里面的参数永远是被装饰的函数 def inner(*args,**kwargs): # 内部函数inner,*args,**kwargs动态参数原封不动的传给被装饰的函数 # 被装饰函数执行之前要做的事 ret = f(*args,**kwargs) # 被装饰的函数,执行完成后，给外面返回值 # 被装饰函数执行之后要做的事 return ret return inner # 对应内部函数inner 不加括号执行@wrapper # func = timmer(func)def func(a,b): time.sleep(2) print('func1',a,b) return '新年好'ret = func(1,2)print(ret) 1234567891011def wrapper(func): # func = qqxing def inner(*args,**kwargs): ret = func(*args,**kwargs) # 被装饰的函数 qqxing return ret return inner@wrapper # qqxing = wrapper(qqxing)def qqxing(a,b): print(123)ret = qqxing(1,2) # 实际上执行的是inner() 装饰器的固定格式 - wraps首先先了解函数的name和doc方法:函数名.__name__ = 查看字符串格式的函数名函数名.__doc__ = 查看函数注释123456789def wahaha(): ''' 一个打印娃哈哈的函数 :return: ''' print('娃哈哈')print(wahaha.__name__) # 查看字符串格式的函数名print(wahaha.__doc__) # 查看函数注释 在执行使用装饰器之后，我们打印函数的name发现是装饰器的函数名称了，这个时候就需要使用wraps来解决。12345678910111213141516171819202122232425from functools import wrapsdef wrapper(func): # func = holiday @wraps(func) # 装饰inner函数 def inner(*args,**kwargs): print('在被装饰的函数执行前做的事') ret = func(*args,**kwargs) print('在被装饰的函数执行后做的事') return ret return inner@wrapper # holiday = wrapper(holiday)def holiday(day): ''' 这是一个放假通知 :param day: :return: ''' return '还有%s天放假'%dayprint(holiday.__name__) # inner...因为现在的holiday已经是inner了，由于之前说装饰器最好不要影响被装饰的函数，需要用wraps装饰inner函数,才可以正常显示回去print(holiday.__doc__)ret = holiday(3) # innerprint(ret)# wraps并不影响wrapper装饰器的使用 带参数的装饰器比如现在有500个函数,都使用装饰器，那么怎么一次性的去控制500个装饰器的增加和删除，怎么办？我们可以使用带参数的参数器，通过标志位参数去控制装饰器是否执行。带参数的装饰器，也就是三层装饰器，在外部多一次调用传入状态标记。123456789101112131415161718192021222324252627282930import timeFLAGE = True # 标识位，True执行，Fales不执行def timmer_out(flag): # 在原有装饰器之外再来一层 def timmer(func): def inner(*args,**kwargs): if flag: # 如果flag = True 那么我就走装饰器，否则我就只运行被装饰的函数 start_time = time.time() ret = func(*args,**kwargs) end_time = time.time() print(end_time - start_time) return ret else: ret = func(*args, **kwargs) return ret return inner return timmer# timmer = timmer_out(FLAGE)@timmer_out(FLAGE)def wahaha(): time.sleep(2) print('wahaha')@timmer_out(FLAGE)def qqxing(): time.sleep(1) print('qqxing')ret = wahaha()ret = qqxing() 多个装饰器装饰一个函数多个装饰器执行的过程有点像套娃，装饰器在后的先执行装饰1234567891011121314151617181920212223242526272829303132def wrapper1(func): # f def inner1(): print('wrapper1装饰器 start') # 3 func() # 执行f # 4 print('wrapper1装饰器 end') # 5 return inner1def wrapper2(func): # inner1 def inner2(): print('wrapper2装饰器 start') # 1 先执行他 func() # inner1() # 2 print('wrapper2装饰器 end') # 6 return inner2# 先看装饰器执行先后@wrapper2 # f = wrapper2(f)==&gt; f = inner1 ==&gt; inner1 = wrapper2(inner1) ==&gt; inner2 ，传进去的是inner1,最后返回得到的是inner2@wrapper1 # f = wrapper1(f) = inner1def f(): print('in f')f() # ==&gt; 调用开始现在是 inner2# wrapper2装饰器 start# wrapper1装饰器 start# in f# wrapper1装饰器 end# wrapper2装饰器 end# 1. 先看装饰器执行先后，wrapper2没有找到要被修饰的函数，所以现在wrapper1# 2. f = wrapper1(f) = inner1# 3. # f(下面赢变成inner1) ==&gt; inner1 = wrapper2(inner1) = inner2，但是传进去的是inner1, 有时候会遇见两个需求: 记录用户的登录情况 记录函数的执行时间仔细思考下先后执行顺序:先登录成功之后 才能开始执行程序记录函数的执行时间]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 迭代器]]></title>
    <url>%2F2019%2F03%2F11%2Fiterator%2F</url>
    <content type="text"><![CDATA[for循环是如何工作的当我们拥有一个列表 l = [1,2,3,4,5],想取列表中的内容，有几种方式？ 1234# 1 通过索引下标和切片取值l = [1,2,3,4,5]print(l[0]) # 1print(l[0:2]) # [1, 2] 123# 2 通过for循环取值for i in l: print(i) 他们的区别是，使用索引取值可以取到任意位置的值，前提是我知道这个值在什么位置，而for循环是取到每一个值，不需要关心这个值在什么位置，也不能跳过任何一个值去取其他位置的值，我们可以称作循环遍历。那么for循环到底是怎么工作的呢？ 都有哪些数据类型可以被for循环123456789101112131415for s in 'abcde': print(s) # 返回字符串中每一个字符 a b c d edic = &#123;'name':'leo','age':26&#125;for key in dic: print(key) # 默认返回字典中的键 name , agefor value in dic.values(): print(value) # 返回字典中的值 leo,26 for k,v in dic.items(): print(k,v) # 返回字典中的键值对 name leo age 26for i in 12345: print(i) # TypeError: 'int' object is not iterable 当我们循环数字类型的时候报错了，说int类型不是 iterable（可迭代的） 迭代和可迭代协议通过对数字类型的报错，不可被for循环的数据类型会报错 不是一个可迭代的，那么是不是说可迭代的数据类型就可以被for循环，如何判断数据类型是否可以被迭代？123456789101112131415161718from collections import Iterablel = [1,2,3,4]t = (1,2,3,4)d = &#123;1:2,3:4&#125;s = &#123;1,2,3,4&#125;num = 123money = 10.10print(isinstance(l,Iterable)) # Trueprint(isinstance(t,Iterable)) # Trueprint(isinstance(d,Iterable)) # Trueprint(isinstance(s,Iterable)) # Trueprint(isinstance(num,Iterable)) # Falseprint(isinstance(money,Iterable)) # False# 下面这三种也是可以被循环遍历# f = open() # range()# enumerate 枚举 可以将某个数据集内的数据“一个挨着一个的取出来”，就叫做迭代总结出一条规律来：能被for循环的就是“可迭代的”。但是如果正着想，for怎么知道谁是可迭代的呢？为什么能被for循环？ 123456789101112131415# 为什么能够被循环# dir 可以返回这个数据类型的拥有的所有方法# 查看列表、字典、字符串、和range的双下方法 有什么共同方法# 求交集ret = set(dir([]))&amp;set(dir(&#123;&#125;))&amp;set(dir(''))&amp;set(dir(range(10)))print(ret) # 我们找一个和iterable比较相似的方法， '__iter__',# 我们再来看看无法被迭代的数据类型 有没有__iter__方法print('__iter__' in dir(int)) # Falseprint('__iter__' in dir(bool)) # Falseprint('__iter__' in dir(list)) # Trueprint('__iter__' in dir(dict)) # Trueprint('__iter__' in dir(set)) # Trueprint('__iter__' in dir(tuple)) # Trueprint('__iter__' in dir(range(10))) # Trueprint('__iter__' in dir(enumerate([]))) # True 再总结出一条新的规律: 能被for循环的就是“可迭代的”,只要是能被for循环的数据类型，就一定拥有__iter__双下方法 双下方法__iter__做了什么123456789101112131415161718print([].__iter__()) # &lt;list_iterator object at 0x0000000002308940&gt; 迭代器 iterator# [].__iter__() 得到了一个list_iterator# 那么迭代器有什么作用呢？让我们来看看列表list和转换成列表_迭代器所有方法的差集print(set(dir([].__iter__()))- set(dir([])) ) # &#123;'__setstate__', '__length_hint__', '__next__'&#125;# 迭代器多出来的这三个方法的作用:#__length_hint__ 获取迭代器中元素的长度# print([1,2,3,4,5].__iter__().__length_hint__()) # 5 元素个数# __setstate__ 可以指定从其他位置取值# __next__ 一个一个的取值# 迭代器取值l = [1,2,3] # 列表iterator = l.__iter__() # iterator现在是一个迭代器,他内部有.__next__()方法print(iterator.__next__()) # 1print(iterator.__next__()) # 2print(iterator.__next__()) # 3print(iterator.__next__()) # 报错 StopIteration 通过上面的例子我们发现,当一个可迭代的对象调用了iter()方法会生成一个 iterator (迭代器) 迭代器中含有_next__()方法，他可以一个一个的取值,如果我们一直取next取到迭代器里已经没有元素了，就会抛出一个异常StopIteration，告诉我们，列表中已经没有有效的元素了 可迭代协议 与 迭代器协议根据上面的例子我们总结出以下概念： 能被for循环的数据类型都是 可迭代的 (iterable) 当这个数据类型调用.__iter__()方法会生成一个 迭代器(iterator) 迭代器.next()可以一个一个的取值 for循环其实就是在使用迭代器，只有是可迭代对象或者迭代器，才能用for循环 for循环的本质就是迭代器 12345for i in l: pass # 首先会去找l.__iter__() ==&gt; iterator = l.__iter__() # i = iterator.__next__() # 当没有值的时候 自动停止结束 也不会报错 12345# 模拟for循环l = [1,2,3,4,5]iterator = l.__iter__() # 变成一个迭代器while True: print(iterator.__next__()) 可迭代协议: 只要含有__iter__()方法的都是可迭代的迭代器协议: 内部含有__next__()方法和__iter__()方法的就是迭代器 可迭代的不一定就是迭代器 迭代器：内部有__iter__和__next__方法 ，所以他一定是可迭代的 可迭代的不一定是迭代器，要看有没有__next__方法12345678910from collections import Iterablefrom collections import Iteratorprint(isinstance([],Iterable)) # 可迭代的 # Trueprint(isinstance([],Iterator)) # 迭代器 # False ,list是可迭代的，但不是一个迭代器print('__iter__' in dir(range(12))) # Trueprint('__next__' in dir(range(12))) # Falseprint(isinstance(range(100000000),Iterable)) # Trueprint(isinstance(range(100000000),Iterator)) # False , range是可迭代器，但不是一个迭代器，因为它没有__next__()方法 迭代器的好处 迭代器会从容器类型中 一个一个的取值，会把所有的值都取到。 它可以节省内存空间,迭代器并不会在内存中再占用一大块内存，而是随着循环每次生成一个,或者每次next()每次给我一个12# print(range(10000000)) # 很快，但是并不会在内存中真正的生成数据# print(list(range(10000000))) # 强制转列表会导致崩溃,list是真正存在并存储在内存里 ，range是要一个给一个]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 生成器]]></title>
    <url>%2F2019%2F03%2F11%2Fgenerator%2F</url>
    <content type="text"><![CDATA[什么是生成器之前我们学习过迭代器，它的好处之一就是可以节省能存，在某些情况下，我们需要自己定义一个方法去实现迭代器功能，这个方法就是生成器。在Python中生成器又分成两类: 生成器函数 生成器表达式 生成器函数生成器Generator： 本质：迭代器(所以自带了iter方法和next方法，不需要我们去实现) 特点：惰性运算,开发者自定义 生成器函数：一个包含yield关键字的函数就是一个生成器函数。yield可以为我们从函数中返回值，但是yield又不同于return，return的执行意味着程序的结束，调用生成器函数不会得到返回的具体的值，而是得到一个可迭代的对象。每一次获取这个可迭代对象的值，就能推动函数的执行，获取新的返回值。直到函数执行结束。 1234567891011121314# 只要含有yield关键字的函数都是生成器函数# yield 必须写在函数里，且无法和return共用def generator(): a = 1 yield a b = 2 yield b g = generator() # 得到一个“生成器”作为返回值print(g) # &lt;generator object generator at 0x0000000001E9A308&gt; generator 生成器# g.__next__ # 生成器带有__next__方法和__iter__方法# g.__iter__ # 生成器是迭代器 用next方法取值print(g.__next__()) # 1print(g.__next__()) # 2 运行过程总结： 由于函数中有yield，所以现在内存中会有一个生成器函数 generator g = generator() 发生了函数调用，生成器函数的特点：函数中的代码不执行 g 得到了一个生成器 生成器里面即有iter方法也有next方法，说明它其实是一个迭代器 生成器就可以使用next方法取值,这时程序才第一次触发了生成器里面的代码 yield 不会结束函数，return会直接结束 生成器函数的使用生成器的最大好处就是不会在内存中一次性的生成所有数据1234567891011121314151617181920212223def factoy(): for i in range(100): yield '生成%s次'%ig = factoy()# __next__() ,一次一次的提取print(g.__next__())print(g.__next__())print(g.__next__())# for循环遍历提取for i in g: print(i)# 取50次g = factoy()count = 0for i in g: count += 1 print(i) if count &gt; 50: breakprint('*****',g.__next__()) # ***** 生成51次 可以继续从生成器中取值 列表为什么不能继续取值123456789101112131415161718192021# 列表是可迭代的,并不是一个迭代器,在两次for循环的时候会产生两个迭代器# for循环自动将可迭代的转换成迭代器l = [1,2,3,4,5]for i in l: print(i) # 1,2 if i == 2: breakfor i in l: print(i) # 1,2,3,4,5 # 获取两个生成器l = [1,2,3,4,5]def generator(): for i in l: yield i g = generator()g1 = generator()print(g,g1) # &lt;generator object generator at 0x0000000001F7A150&gt; &lt;generator object generator at 0x0000000001F7A200&gt;print(g.__next__()) # 1print(g1.__next__()) # 1 拿到两个生成器，自己执行自己的 监听文件的输入123456789101112def tail(filename): f = open(filename, encoding='utf-8') while True: line = f.readline() # 每次读一行 if line.strip(): # 不为空就打印 # print('****',line.strip('\n')) yield line.strip() # 返回这行g = tail('file') # 获取生成器for i in g: if 'python' in i: print('*****',i,'*****') # 可以对这个结果做任何操作了,用生成器实现就可以想要的结果 爬虫时的使用123456789101112131415161718192021222324252627def parse_one_page(html): rule = re.compile( '&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?' 'releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;' ,re.S) items = re.findall(rule, html) # 通过findall方法根据规则得到html文本 # print(items) for item in items: yield &#123; 'index':item[0], 'image':item[1], 'title':item[2].strip(), 'actor':item[3].strip(), 'time':item[4].strip(), 'score':item[5].strip() + item[6].strip() &#125; # 循环整个html文本列表,每一条数据都生成yield返回一个字典，里面拼接成想要的数据类型# 使用的时候传递一个页面进去，循环调用生成器，item里就是生成的每条数据def main(offset): url = 'https://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) # print(html) for item in parse_one_page(html): print(item) write_to_file(item) 生成器函数的进阶数据类型的强制转换 — 列表(生成器)1234567891011121314def generator(): for i in range(20): yield 'wahaha%s'%ig = generator()# list(g)# list是列表，代表将g生成器直接转换成列表，列表中的每一个值都是实际存在的# 一个一个从生成器里取出来，全部取完放入列表，列表会在内存中生成print(list(g))# ['wahaha0', 'wahaha1', 'wahaha2', 'wahaha3'...'wahaha19']# 从生成器取值的几个方法： # next # for # 数据类型的强制转换 (不推荐，占用内存) 123456789101112def generator(): print(123) yield 1 print(456) yield 2 print(789)g = generator() # 得到一个生成器ret = g.__next__()print('***',ret) # 先打印123，然后拿到yield返回的1print('***',ret)print('***',ret) # 执行了789,由于后面没有yield,会报错StopIteration 生成器函数 — send123456789101112131415161718192021222324def generator(): print(123) send_msg = yield 1 print('======',send_msg) yield 2g = generator()ret = g.__next__()print('***',ret)ret = g.send('send_hello')print('***',ret)# 123# *** 1# ====== send_hello# *** 2# send用法总结# 1. send的获取下一个值的效果与next基本一致# 2. 只是在获取下一个值的时候给上一个yield的位置,传递一个数据# 使用send的注意事项# 1. 第一次使用生成器的时候,必须使用next获取下一个值# 2. 最后一个yield 不能接收外部的值,但是可以在接收arg=yield 2...最后返回一个空yield send实例 — 计算移动平均值123456789101112131415161718192021# 接收一次值计算平均值# 移动平均值# num: 10 20 30# avg: 10 15 20# 公式: avg = num / countdef avg_generator(): sum = 0 count = 0 avg = 0 num = yield # 第一次返回空，为了后面send传值(num)进来,10 sum += num # 总数有更新 10 count += 1 # 次数更新 avg = sum / count yield avg # send执行到这avg_g = avg_generator()avg_g.__next__() # 使用send第一次必须next，得到空avg1 = avg_g.send(10) # 传值(num)10进去print(avg1) 那么如何多次计算呢，需要加上循环123456789101112131415161718192021222324252627# 移动平均值# num: 10 20 30# avg: 10 15 20# 公式: avg = num / countdef avg_generator(): sum = 0 count = 0 avg = 0 while 1: # num = yield # 第一次返回空，为了后面send传值(num)进来,10 num = yield avg # 第一次的avg = 0 ，num = 传值 sum += num # 总数有更新 10 count += 1 # 次数更新 avg = sum / countavg_g = avg_generator()avg_g.__next__() # 使用send第一次必须next，得到空avg = avg_g.send(10) # 传值(num)10进去avg = avg_g.send(20)avg = avg_g.send(30)print(avg)# 每次计算方法:# 如果我加上while循环,现在我有两个yield,第一次结束到yield avg,第二次执行什么？# 如果执行next num = yield 相当于 num = 0# 下面再用一次send 传值20 再返回打印 计算移动平均值(2)_预激协程的装饰器123456789101112131415161718192021222324252627# 计算移动平均值# 用装饰器 激活__next__()def init(func): def inner(*args,**kwargs): g = func(*args,**kwargs) # g = generator() 拿到装饰器 g.__next__() # 执行__next__() return g # 返回装饰器 return inner@init # avg_generator = init(avg_generator) ==&gt; innerdef avg_generator(): sum = 0 count = 0 avg = 0 while True: # num = yield num = yield avg # num = 10,20,30 sum += num # sum = 10,30,60 count += 1 # count = 1,2,3 avg = sum / count # avg = 10,15,20g = avg_generator() # inner() # 执行这里 得到一个执行过next的装饰器# g.__next__() # 我不在这调用 而是在装饰器里avg = g.send(10) # 开始向生成器里里传值avg = g.send(20)avg = g.send(30)print(avg) yield fromyield from : 从一个容器类型里取值,不需要一个个返回，而是集体返回接收123456789101112131415# python 3# 将结果按个返回def generator(): a = 'abcde' b = '12345' # 单个字符串返回 for i in a: yield i for i in b: yield ig = generator()# print(g.__next__())for i in g: print(i) 12345678910111213# yield from 将结果按个返回def generator(): a = 'abcde' l = [1,2,3,4,5] # 单个字符串返回 yield from a # 生成器函数语法 yield from lg = generator()for i in g: print(i)# yield from 从一个容器类型里取值,不需要一个个返回，而是集体返回接收 1234567# 将两个类型的数据list转化成同一个def generator(): yield from range(0,5) yield from 'abcde'l = list(generator())print(l) # [0, 1, 2, 3, 4, 'a', 'b', 'c', 'd', 'e'] 生成器表达式列表推导式我们先写一个获取鸡蛋的程序1234egg_list = []for i in range(10): egg_list.append('鸡蛋%s'%i)print(egg_list) 在这里循环获取得到一个鸡蛋筐(列表),里面存着10个鸡蛋,列表推导式的写法如下12345egg_list = ['鸡蛋%s' %i for i in range(10)]print(egg_list)# 1. for i in range(10) 循环# 2. 将想要的 放在for前面# 3. 用列表括起来 列表推导式可以做一些简单的循环工作,那么这个时候我们就想,列表生成后可是存在内存里的，那如果是大数据怎么办，很占用内存，占用内存我们就想到了 生成器 生成器推导式生成器表达式 与 列表表达式 的不同 括号不一样 返回的值不一样 列表推导式得到的还是一个列表，一次性得到所有的值，占用内存 生成器表达式几乎不占用内存，但是不能直接应用,需要遍历循环取值，程序应该更关心内存123456789101112131415161718192021# 生成器表达式g = (i for i in range(10))print(g) # &lt;generator object &lt;genexpr&gt; at 0x0000000001EB92B0&gt; 生成器for i in g: print(i)# 获取鸡蛋例子egg_g = ('鸡蛋%s'%i for i in range(10)) # 生成器表达式for i in egg_g: # 相当于老母鸡,然后下蛋 print(i) # 每个数字都取平方# g里面的代码一句话没执行，直到for循环取值__next__,for循环每走一次,上面的range10的循环才走一次g = (i*i for i in range(10))for i in g: print(i) #列表解析sum([i for i in range(100000000)])#内存占用大,机器容易卡死#生成器表达式sum(i for i in range(100000000))#几乎不占内存 迭代器与生成器总结可迭代对象: 拥有__iter__方法 特点：惰性运算 例如: range(), str, list, tuple, dict, set 迭代器Iterator： 拥有__iter__方法和__next__方法 例如: iter(range()), iter(str), iter(list), iter(tuple), iter(dict), iter(set), reversed(list_o), map(func,list_o), filter(func, list_o), file_o 生成器Generator：本质：迭代器，所以拥有__iter__方法和__next__方法特点：惰性运算, 开发者自定义 使用生成器的优点： 延迟计算，一次返回一个结果。也就是说，它不会一次生成所有的结果，这对于大数据量处理，将会非常有用。 提高代码可读性]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 包的使用]]></title>
    <url>%2F2019%2F03%2F05%2Fpackage%2F</url>
    <content type="text"><![CDATA[什么是包包就是把解决一类问题的模块放在同一个文件目录里，这个文件目录就叫做包包是一种通过使用‘.模块名’来组织python模块名称空间的方式。 包的导入方法 – import1234567891011121314151617soft/ ├── bin │ ├── __init__.py│ └── start.py ├── core │ ├── __init__.py│ └── Manage.py │ └── login() └── cook.py 最外层是soft软件工程目录 bin 和 core 是两个包 bin 下有着start.py 程序入口文件 core 下有着Manage模块,里面带有一个login( )方法 整个目录还有一个cook.py文件 在soft目录下 12345678910# 想要在start.py 使用 Manage的login()方法# 通过查看sys.path路径发现只能找到soft的bin目录,所以不能直接import core,需要从soft开始import sysprint(sys.path) # D:\\PycharmProjects\\Notes\\soft\\binimport soft.core.Managesoft.core.Manage.login() # login in Manageimport soft.core.Manage as MM.login() # login in Manage 关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如,soft.core.Manage但都必须遵循这个原则。 对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。 from … import …123456789import osimport sys# 把soft目录加入到sys.path里去，然后就可以直接找到coresys.path.append(os.path.dirname(os.getcwd()))print(sys.path) # 'D:\\PycharmProjects\\Notes\\soft'from core import ManageManage.login() # login in Manage 1234567891011# 在core包下的文件引入其他包中的方法或者配置# 记得由于我们执行开始是在start.py中执行,所以一定要在里面导入路径# settings 文件中加入 DB_PATH = 'D:\PycharmProjects\Notes\soft\db'# Manageimport osfrom conf import settingsdef login(): print('login in Manage') file_name = os.path.join(settings.DB_PATH,'info.log') with open(file_name,'w') as f: f.write('Hello') 需要注意的是from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误可以用import导入内置或者第三方模块（已经在sys.path中），但是要绝对避免使用import来导入自定义包的子模块(没有在sys.path中)，应该使用from… import …的绝对或者相对导入,且包的相对导入只能用from的形式。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 模块的使用]]></title>
    <url>%2F2019%2F03%2F04%2Fmodule%2F</url>
    <content type="text"><![CDATA[什么是模块在Python中，一个.py文件就被称之为一个模块 模块的调用模块一旦被调用，即相当于执行另外一个另外一个py文件中的代码，多次import导入同一个模块，只会执行一次。 模块的导入 – import1234# demo.pymoney = 100def read(): print('in read',money) 12345678# func.pyimport demodef read(): print('my read func')money = 200read() # 自己本地的print(demo.money) # 调用模块的demo.read() # 调用模块的 模块导入流程 先从sys.modules里查看是否已经被导入 如果没有被导入就依据sys.path路径去寻找模块 找到了就导入，没有找到就报错 创建这个模块的命名空间 执行文件,把文件中的名字都放到命名空间中 sys.modules会加入这个模块，当这个模块再被impoet时就不会被重复导入 123456import sysimport demo# sys.modules 是一个字典，内部包含模块名与模块对象的映射，该字典决定了导入模块时是否需要重新导入print(sys.modules.keys())# sys.path 是python的搜索模块的路径listprint(sys.path) 导入模块的顺序 内置模块 time,re 扩展模块 pip3安装的 django 自定义模块 demo 单独导入 – from…import…123from time import sleepsleep(1)print('hey') 123456from demo import read,moneymoney = 200def read(): print('my read',money)read() # my read 200print(money) # 200 查看结果1. 如果本地有read()方法则优先调用本地的。2. 即使导入了money这个变量也无法替代本地变量,会发生冲突。为什么要使用 from…import?1. import是导入了模块里面的所有名字 比较占用内存。2. 导入一个变量进来，占用的内容较少,只要不用重名即可。 1234# 导入多个名字from demo import money,readprint(money) # 100print(read) # &lt;function read at 0x0000000000B62620&gt; 1234567891011121314151617# 导入全部* 配合 __all__# 如果在模块中定义了__all__ 那么如果import * ，只有存在这个列表中的名字才能调用# import demo 不受这个约束# demo__all__ = ['money','read'] # 只和 from demo import * 能配合起来money = 100def read(): print('in read',money)def read2(): print('in read2',money)# funcfrom demo import *print(money) # 100read() # in read 100read2() # NameError: name 'read2' is not defined 把模块当做脚本执行我们可以通过模块的全局变量name来查看模块名：12345# demo2print(__name__) # __main__# funcimport demo2 # demo2 当我在文件中import demo2的时候,demo2中的print(__name__)执行返回的是demo2 当我在demo模块中print(__name__)的时候返回的是 __main__ 在哪个页面页面上点的run 在哪个页面上就是__main__ 如果不在本页面上执行,在其他页面上调用模块名导入执行,那么就返回模块名 if name == ‘main‘: 作用:用来控制.py文件在不同的应用场景下执行不同的逻辑123456789101112131415# demo2def login(): print('正在执行登录程序')if __name__ == '__main__': print('in demo2.py') # in demo2.py ret = login() # 正在执行登录程序 print(ret) # None # funcimport demo2ret = demo2.login() # 正在执行登录程序print(ret) # None# 这样就符合了：模块导入的时候什么都不执行,所有想做的都放在模块里面去,在执行程序的时候就不会受影响，也能调用模块中想要的名字]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Readme]]></title>
    <url>%2F2019%2F03%2F04%2FReadme%2F</url>
    <content type="text"></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
