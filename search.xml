<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BOM 和 DOM 对象]]></title>
    <url>%2F2019%2F06%2F12%2Fweb-object%2F</url>
    <content type="text"><![CDATA[基础知识 JavaScript分为 ECMAScript，DOM，BOM。 BOM （Browser Object Model）是指浏览器对象模型，它使 JavaScript 有能力与浏览器进行“对话”。 DOM （Document Object Model）是指文档对象模型，通过它，可以访问HTML文档的所有元素(标签)。 BOM 对象BOM（Browser Object Mode）浏览器对象模型，是Javascript的重要组成部分。它提供了一系列对象用于与浏览器窗口进行交互，这些对象通常统称为BOM。 window 对象 – BOM核心1、它表示整个浏览器窗口，主要用来操作浏览器窗口2、所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。3、全局变量是 window 对象的属性。全局函数是 window 对象的方法。4、Window对象是客户端JavaScript最高层对象之一，由于window对象是其它大部分对象的共同祖先，在调用window对象的方法和属性时，可以省略window对象的引用。例如：window.document.write()可以简写成：document.write()。 所有浏览器都支持 window 对象。 概念上讲.一个html文档对应一个window对象。 功能上讲: 控制浏览器窗口的。 使用上讲: window对象不需要创建对象,直接使用即可。 12345// 一些常用的Window方法：window.innerHeight - 浏览器窗口的内部高度window.innerWidth - 浏览器窗口的内部宽度window.open() - 打开新窗口window.close() - 关闭当前窗口 window 的子对象navigator对象（了解即可）12345// 浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息。navigator.appName // Web浏览器全称navigator.appVersion // Web浏览器厂商和版本的详细字符串navigator.userAgent // 客户端绝大部分信息navigator.platform // 浏览器运行所在的操作系统 screen对象（了解即可）123// 屏幕对象，不常用。screen.availWidth - 可用的屏幕宽度screen.availHeight - 可用的屏幕高度 history对象（了解即可）123// 浏览历史对象，包含了用户对当前页面的浏览历史，但我们无法查看具体的地址，可以简单的用来前进或后退一个页面。history.forward() history.back() location对象12345678910// 用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。location.herf = 'url地址'location.hostname // 返回 web 主机的域名location.pathname // 返回当前页面的路径和文件名location.port // 返回 web 主机的端口 （80 或 443）location.portocol // 返回页面使用的web协议。 http:或https:location.href // 获取当前的URLlocation.href = 'http://www.baidu.com' // 跳转到指定的URLlocation.reload() // 重新加载当前页面 弹出框1234// JavaScript 中创建三种消息框：警告框、确认框、提示框。alert('提示信息'); // 警告框confirm("确认信息"); // 确认框prompt("请在下方输入","你的答案"); // 提示框 定时器 setTimeout() 和 clearTimeout() 在指定时间之后执行一次相应函数。 setInterval() 和 clearInterval() 在指定的周期（以毫秒计）来调用函数或计算表达式。 123456789101112// 一定时间间隔之后执行// 语法: var t=setTimeout("JS语句",毫秒)var t = setTimeout("alert('发送成功')",3000)// 函数定时执行function func()&#123; alert('发送成功')&#125;var t = setTimeout(func,3000)// 取消setTimeout设置clearTimeout(t) 123456789// 每隔多少秒执行一次// 语法：var t = setInterval("JS语句",时间间隔)function foo()&#123; console.log(1)&#125;;var t = setInterval(foo,1000)// 取消setInterval设置clearInterval(t); DOM 对象 DOM（Document Object Model）是一套对文档的内容进行抽象和概念化的方法。 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被构造为对象的树。 HTML DOM 树 dom树是为了展示文档中各个对象之间的关系，用于对象的导航。 DOM都有哪一些内容 HTML 文档中的每个成分都是一个节点。 DOM标准规定HTML文档中的每个成分都是一个节点(node)： 文档节点(document对象)：代表整个文档 元素节点(element 对象)：代表一个元素（标签） 文本节点(text对象)：代表元素（标签）中的文本 属性节点(attribute对象)：代表一个属性，元素（标签）才有属性 注释是注释节点(comment对象) JS 操作DOM JavaScript 可以通过DOM创建动态的 HTML JavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 查找标签直接查找12// 通过id查找标签document.getElementById("d1") 12// 根据class属性获取所有标签document.getElementsByClassName("p1") 12// 根据标签名获取标签合集document.getElementsByTagName("div") 间接查找123456parentElement // 父节点标签元素children // 所有子标签firstElementChild // 第一个子标签元素lastElementChild // 最后一个子标签元素nextElementSibling // 下一个兄弟标签元素previousElementSibling // 上一个兄弟标签元素 1234567// 查找父节点// 子节点.parentElementvar d3Ele = document.getElementById("d3")d3Ele.parentElement// &lt;div id=​"d2"&gt;​…​&lt;/div&gt;​d3Ele.parentElement.parentElement// &lt;body&gt;​…​&lt;/body&gt;​ 12345// 查找所有子标签// 父节点.childrenvar d2Ele = document.getElementById("d2")d2Ele.childrend2Ele.childNodes 123456// 第一个子标签元素 和 最后一个var d2Ele = document.getElementById("d2")d2Ele.firstElementChild // &lt;div id=​"d3"&gt;​d2里面的d3​&lt;/div&gt;​d2Ele.lastElementChild// &lt;div id=​"d5"&gt;​d2里面的d5​&lt;/div&gt;​ 123456// 下一个兄弟标签元素 和 上一个var d4Ele = document.getElementById("d4")d4Ele.previousElementSibling// &lt;div id=​"d3"&gt;​d2里面的d3​&lt;/div&gt;​d4Ele.nextElementSibling// &lt;div id=​"d5"&gt;​d2里面的d5​&lt;/div&gt;​ 节点操作创建节点12// 语法：createElement(标签名)var divEle = document.createElement("div"); 添加节点1234// 追加一个子节点（作为最后的子节点）// somenode.appendChild(newnode)；// 把增加的节点放到某个节点的前边。// somenode.insertBefore(newnode,某个节点); 1234567var imgEle = document.createElement("img") // 创建img节点// 给igm节点添加一个src属性imgEle.src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1560341306312&amp;di=67d00a7580c18d13000ced0c9df87e35&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2Fd487c4c496b952e7463a9ac2a041643a.jpeg"// 添加img节点到d1标签中var d1Ele = document.getElementById("d1")d1Ele.appendChild(imgEle) // 把创建好的imgEle添加到id=d1的标签内部 123456789// 在某个标签前面添加 insertBefore(要插入的新标签，哪个标签之前)var divEle = document.createElement("div") // 创建新的div标签divEle.innerText = "大家好" // 添加文本"大家好"var d4Ele = document.getElementById("d4") // 找到要加入的父标签var d2Ele = document.getElementById("d2") // 找到要加入到前面的子标签d2.insertBefore(divEle,d4Ele) // 在d4标签之前加入新div标签&lt;div&gt;​大家好​&lt;/div&gt;​ 删除节点1234567// 语法:somenode.removeChild(要删除的节点)// 获得要删除的元素，通过父元素调用该方法删除。var d2Ele = document.getElementById("d2")d2Ele.firstElementChild// &lt;div id=​"d3"&gt;​d2里面的d3​&lt;/div&gt;​var sonEle = d2Ele.firstElementChild;d2Ele.removeChild(sonEle) 替换节点123456789// 语法:somenode.replaceChild(newnode, 某个节点);var d2Ele = document.getElementById("d2")var sonEle = d2Ele.firstElementChild;var aEle = document.createElement("a")aEle.innerText="点我""点我"aEle.href="http://www.baidu.com""http://www.baidu.com"d2Ele.replaceChild(aEle,sonEle) 属性操作获取属性123// 获取元素节点中指定属性的属性值var d2Ele = document.getElementById("d2")d2Ele.getAttribute("id") 设置属性123456789// 默认属性都可以修改 d2Ele.setAttribute("age",18)d2.getAttribute("age")"18"// 自带的属性还可以直接.属性名来获取和设置imgEle.src="..."aEle.innerText="点我"aEle.href="http://www.baidu.com" 删除属性123d2.removeAttribute("age")d2.getAttribute("age")null 文本操作 innerHTML 和 innerText的区别: * innerHTML:子标签和子标签的内容都取出来,主要记这个:快速添加简单的标签 * innerText:只取标签之间的内容 获取标签文本12345678910// 获取标签内的文本信息var d2Ele = document.getElementById("d2")d2Ele.innerText// "d2里面的d3// d2里面的d4// d2里面的d5"var d4Ele = document.getElementById("d4")d4Ele.innerText// "d2里面的d4" 替换标签文本1d2Ele.innerText = "全部修改" // 修改文本内容 连子标签都没了,只剩下了文本 获取标签和文本12345678// 获取d2下面所有html内容,包括标签和文本var d2Ele = document.getElementById("d2")d2Ele.innerHTML//"// &lt;div id="d3"&gt;d2里面的d3&lt;/div&gt;// &lt;div id="d4"&gt;d2里面的d4&lt;/div&gt;// &lt;div id="d5"&gt;d2里面的d5&lt;/div&gt;//" 快速添加简单的标签12// 原先的标签会被替换d2Ele.innerHTML = "&lt;p&gt;我是新的p标签&lt;/p&gt;"]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2019%2F05%2F29%2Fjavascript%2F</url>
    <content type="text"><![CDATA[JavaScript 介绍 完整的 JavaScript 实现是由以下 3 个不同部分组成的: 核心（ECMAScript） 文档对象模型（DOM） Document object model (整合js，css，html) 浏览器对象模型（BOM） Broswer object model（整合js和浏览器） Javascript 在开发中绝大多数情况是基于对象的.也是面向对象的. ECMAScriptECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。 ES6就是指ECMAScript 6。 简单地说，ECMAScript 描述了以下内容： 语法 类型 语句 关键字 保留字 运算符 对象 (封装 继承 多态) 基于对象的语言.使用对象. JavaScript 概述 JavaScript是脚本语言, 将JS插入 HTML 页面后，可由所有的现代浏览器执行。 JS跑在浏览器上，他的解释器就是浏览器，有浏览器就能跑 JS。 JavaScript 基础JS 引入方式 JS文件是在后端写的，浏览器通过网络从后端拿过来，然后在执行，如果找不到JS文件浏览器并不会报错 直接编写 123&lt;script&gt; alert('hello')&lt;/script&gt; 文件引入 1&lt;script src="jojo.js"&gt;&lt;/script&gt; JS 语言规范注释1// 单行注释 1/* 我是多行注释 */ 结束符 js语句之间有分号(;)为结束符,python通过缩进 JS 语言基础变量声明 js属于动态类型。(同一个变量可以存不同数据类型的值) 声明变量使用 var 变量名; 的格式来进行声明。 一行可以声明多个变量.并且可以是不同类型。 JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。 js中$也可以做变量名。12var userName = 'leo';var userName = 'leo',age = 28,city="beijing"; 注意 变量名是区分大小写的。 推荐使用驼峰式命名规则。Camel 标记法首字母是小写的，接下来的字母都以大写字符开头。例如：var myTestValue = 0, mySecondValue = “hi”; 保留字不能用做变量名。 保留字列表12345678910111213141516171819202122232425262728293031abstractbooleanbytecharclassconstdebuggerdoubleenumexportextendsfinalfloatgotoimplementsimportintinterfacelongnativepackageprivateprotectedpublicshortstaticsupersynchronizedthrowstransientvolatile JS 数据类型 JS 动态类型 JS属于动态类型语言 动态类型：声明变量即可以是字符串也可以是数字 静态类型，在声明变量的时候，声明类型，严谨，执行效率快，不用判断变量，范围缩小 1234567891011var x typeof(x)"undefined"var name = "leo"typeof(name)"string"var age = 28typeof(age)"number" 数值(Number) JavaScript不区分整型和浮点型，就只有一种数字类型。 12345678910var n1 = 28var n2 = 28.00var n3 = NaN ### NaN，表示不是一个数字（Not a Number）。typeof(n1)"number"typeof(n2)"number"typeof(n3)"number" 123var name = 'leo'parseInt(name) ### 表示强转后，结果并不是一个数字NaN 字符串(String) 字符串拼接用 + 号 12345var s1 = "jojo"var s2 = "bobo"var s3 = s1+s2console.log(s3)### jojobobo 字符串的常用方法 布尔值(Boolean) 区别于Python，true和false都是小写。 “”(空字符串)、0、null、undefined、NaN都是false 12var a = true;var b = false; null和undefined null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null; undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。 函数无明确的返回值时，返回的也是undefined。 null表示变量的值是空，undefined则表示只声明了变量，但还没有赋值。 123null == undefined弱等于 10 == "10"强等于 10 === "10" 1234567var ageageundefinedtypeof age"undefined" 对象(Object) JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…此外，JavaScript 允许自定义对象。 JavaScript 提供多个内建对象，比如 String、Date、Array 等等。 对象只是带有属性和方法的特殊数据类型。 数组: 数组对象的作用是：使用单独的变量名来存储一系列的值。类似于Python中的列表。 12var l1 = ['a','b','c','d','e']console.log(l1[1]) 常用方法: 遍历数组中的元素: 12345678for (var i=0;i&lt;l1.length;i++)&#123; console.log(i)&#125;01234 字典对象: 1234567891011var person = &#123; name : 'leo', age : 18&#125;;undefinedperson.name"leo"person.age18person&#123;name: "leo", age: 18&#125; 运算符算数运算符+ - * / % ++ -- 比较运算符&gt; &gt;= &lt; &lt;= != == === !== 12345678910111213141510 == '10'true ### 弱等于10 === '10'false ### 强等于,既判断类型又判断值 ,一般使用强等于null == undefinedtruenull === undefinedfalsetypeof null"object"typeof undefined"undefined" 逻辑运算符&amp;&amp; || !1与and 或or 非! 赋值运算符= += -= *= /=1234567var n = 1n = 22n += 24n -= 13 流程控制if-else if-else12345678var a = 5;if (a &gt; 5)&#123; console.log(" a &gt; 5");&#125;else if (a &lt; 5)&#123; console.log(" a &lt; 5");&#125;else&#123; console.log(" a = 5");&#125; switch1234567891011121314// 获取今天周几var day = new Date().getDay();switch (day)&#123; case 0: console.log("Sunday"); break; case 1: console.log("Monday"); break;default: console.log("...")&#125;Monday switch中的case子句通常都会加break语句，否则程序会继续执行后续case中的语句。 for1234567891011var l1 = [1,2,'leo']for (var i = 0;i &lt; l1.length;i++)&#123; console.log(i) // 索引 console.log(l1[i]) // 值&#125;01122leo while123456// 循环要有一个准确的终止条件var age = 10;while (age &lt; 18)&#123; console.log("可以进入"); age += 1&#125; 三元运算123456### pythona = 10b = 5c = a if a &gt; b else bprint(c)10 123456// jsvar a = 10;var b = 20;var c = a &gt; b ? a:b// 问号 ？ 前面是条件，后面是取值,成立取a，不成立取b(冒号后面的值) 函数函数定义123456789// 普通函数 带参函数function func(a,b) &#123; console.log(a); console.log(b); return a + b // 返回值&#125;ret = func(10,20) // 函数执行 接收返回值console.log('a + b = ' + ret) 123456789// 匿名函数 没有函数名,存在变量里var func2 = function (a,b) &#123; console.log(a); console.log(b); return a + b&#125;ret = func2(10,20)console.log('a + b = ' + ret) 123456789101112131415// 参数个数function func(a,b) &#123; console.log(a); console.log(b); return a + b&#125;// ret = func(10,20,30)// 多一个参数传进来 并不会报错 继续执行ret = func(10)// 少一个参数传进来 b = undefined , a + b = NaN// 也就是说b被声明了，但是没有赋值,相加的结果是NANconsole.log('a + b = ' + ret) 12345// 立即执行函数(function (a,b) &#123; console.log('立即执行函数') console.log(a+b)&#125;)(10,20); arguments 参数12345678910111213141516171819// arguments参数 有点像 python中的args 他可以用来接收多个参数// arguments 找到所有传进的参数 == *argsfunction func(a,b) &#123; console.log(arguments); console.log('参数个数:' + arguments.length); var ret = 0; for (var i = 0;i&lt;arguments.length;i++)&#123; ret += arguments[i] &#125; return ret // 3个参数相加之和&#125;ret = func(10,20,30)console.log(ret)// Arguments(3) [10, 20, 30, callee: ƒ, Symbol(Symbol.iterator): ƒ]// 参数个数:3// 60 函数的全局变量和局部变量 局部变量：121. 在JavaScript函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它（该变量的作用域是函数内部）。2. 只要函数运行完毕，本地变量就会被删除。 全局变量：11. 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 变量生存周期：1231. JavaScript变量的生命期从它们被声明的时间开始。2. 局部变量会在函数运行以后被删除。3. 全局变量会在页面关闭后被删除。 作用域 变量的查找顺序: 121. 函数的调用，要往回找，找到函数的定义阶段2. 变量首先在 函数的内部找 -&gt; 内部找不到就往外找 -&gt; 直到找到全局为止，全局都没有就是undefined。 12345678910var city = "BeiJing";function f() &#123; var city = "ShangHai"; function inner()&#123; var city = "ShenZhen"; console.log(city); &#125; inner();&#125;f(); //输出结果是？ ShenZhen 12345678910var city = "BeiJing";function Bar() &#123; console.log(city);&#125;function f() &#123; var city = "ShangHai"; return Bar;&#125;var ret = f();ret(); // 打印结果是？ BeiJing 1234567891011// 闭包var city = "BeiJing";function f()&#123; var city = "ShangHai"; function inner()&#123; console.log(city); &#125; return inner;&#125;var ret = f();ret(); // ShangHai 词法分析（尝试理解）123451.分析(函数内部变量的定义过程) 1.先看参数 2.看有没有局部变量 3.看有没有函数定义2.执行(实际执行代码) JavaScript中在调用函数的那一瞬间，会先进行词法分析。 当函数 调用 的前一瞬间，会先形成一个激活对象：Avtive Object（AO），并会分析以下3个方面： 1231:函数参数，如果有，则将此参数赋值给AO，且值为undefined。如果没有，则不做任何操作。2:函数局部变量，如果AO上有同名的值，则不做任何操作。如果没有，则将此变量赋值给AO，并且值为undefined。3:函数声明，如果AO上有，则会将AO上的对象覆盖。如果没有，则不做任何操作。 函数内部无论是使用参数还是使用局部变量都到AO上找。1234567891011121314var age = 18;function foo()&#123; console.log(age); var age = 22; console.log(age);&#125;foo(); // 问：执行foo()之后的结果是？// 分析:// 1.函数没有参数// 2.有局部变量 age 那么 ao.age = undefined// 3.有变量赋值 age = 22// 第一个age = undefined // 第二个age = 22 123456789101112131415161718192021var age = 18;function foo()&#123; console.log(age); var age = 22; console.log(age); function age()&#123; console.log("呵呵"); &#125; console.log(age);&#125;foo(); // 执行后的结果是？// 分析:// 1 没有参数// 2.age = undefined// 3.age = 22// 4.function age = ao.age = function age()...// 1. function age()...// 2. 22 // 3 .22 同理第三个输出的还是22, 因为中间再没有改变age值的语句了 内置对象和方法对象的属性 JavaScript中的所有事物都是对象：字符串、数字、数组、日期，等等。 123456789// 字符串对象创建// var 变量 = “字符串”// var 字串对象名称 = new String (字符串)var name1 = "leo"var name2 = new String("Leo")typeof name1"string"typeof name2"object" 1234567// 数组对象创建var l1 = [1,2,3]var l2 = new Array(1,2,3)l1(3) [1, 2, 3]l2(3) [1, 2, 3] 123456789101112// 数字类型对象创建var n1 = 28n128var n2 = new Number(30)n2Number &#123;30&#125;typeof n1"number"typeof n2"object" 自定义对象123456789101112131415161718192021// 第一种方法 直接创建// 自定义对象var person = &#123; "name":"leo", "age":28&#125;console.log(person)console.log(typeof person)console.log(person.name)console.log(person.age)// 循环遍历对象属性for (var i in person)&#123; console.log(i) // 键 console.log(person[i]) // 值&#125;// 注意:// 1. 键不用加引号,加上也不出错 &#123;name:"leo",age:28&#125;// 2. 值如果是字符串，必须写双引号 12345678// 第二种方法 new 关键字创建var person = new Object()person.name = "leo"person.age = 28person.city = "北京"console.log(person.name + person.age)var index3 = 'city' // 刚巧我有一个变量的值是对象里面的键console.log(person[index3]) // 变量取值 内置对象Date对象 内置对象相当于python当中的内置模块 1234567// 创建Date对象// Date对象var d1 = new Date();console.log(d1); // Tue Jun 11 2019 18:04:34 GMT+0800 (中国标准时间)console.log(typeof d1); // objectconsole.log(d1.toLocaleString()); // 2019/6/11 下午6:04:34 字符串时间console.log(typeof d1.toLocaleString()); // string 1234567// 生成指定时间的date对象var d2 = new Date("2019/06/11 18:10");var d3 = new Date("2019-06-11 18:10");var d4 = new Date("2019/06/11 18:10");console.log(d2.toLocaleString()); // 转成字符串格式的 本地时间 2019/6/11 下午6:10:00console.log(d3.toLocaleString()); // 2019/6/11 下午6:10:00console.log(d4.toUTCString()); // Tue, 11 Jun 2019 10:10:00 GMT UTC时间 1234567891011// Date对象的方法var d = new Date();console.log(d.getDate()); //获取日console.log(d.getDay ()); //获取星期console.log(d.getMonth ()); //获取月（0-11）console.log(d.getFullYear ()); //获取完整年份console.log(d.getHours ()); //获取小时console.log(d.getMinutes ()); //获取分钟console.log(d.getSeconds ()); //获取秒console.log(d.getMilliseconds ()); //获取毫秒console.log(d.getTime ()); //返回累计毫秒数(从1970/1/1午夜) 123456789101112131415161718192021222324// 编写代码，将当前日期按“2017-12-27 11:11 星期三”格式输出。var weekday = &#123; "0":"星期日", "1":"星期一", "2":"星期二", "3":"星期三", "4":"星期四", "5":"星期五", "6":"星期六"&#125;function get_day() &#123; var d = new Date() var year = d.getFullYear() var month = d.getMonth()+1; // 月份是0-11 所以加1 var day = d.getDay(); var h = d.getHours(); var m = d.getMinutes() &lt; 10 ? "0" + d.getMinutes():d.getMinutes(); // 三元运算 如果分钟&lt;10 在前面加个0 var week_day = weekday[d.getDay()] var strTime = `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;h&#125;:$&#123;m&#125; $&#123;week_day&#125;`; console.log(strTime)&#125;get_day() JSON对象12345678910// 字符串转成对象var person = '&#123;"name":"leo","age":28&#125;' // 字符串var json_s = JSON.parse(person)console.log(json_s)console.log(typeof json_s) // object// 对象转换成字符串var ob_s = JSON.stringify(json_s)console.log(ob_s)console.log(typeof ob_s) // string Math对象 同样Math用于数据科学计算 123456789101112abs(x); //返回数的绝对值。exp(x); //返回 e 的指数。floor(x); //对数进行下舍入。log(x); //返回数的自然对数（底为e）。max(x,y); //返回 x 和 y 中的最高值。min(x,y); //返回 x 和 y 中的最低值。pow(x,y); //返回 x 的 y 次幂。random(); //返回 0 ~ 1 之间的随机数。round(x); //把数四舍五入为最接近的整数。sin(x); //返回数的正弦。sqrt(x); //返回数的平方根。tan(x); //返回角的正切。 12var n = -100console.log(Math.abs(n)) RegExp对象12345678910111213141516// 创建正则对象方式1// 参数1 正则表达式(不能有空格)// 参数2 匹配模式：常用g(全局匹配;找到所有匹配，而不是在第一个匹配后停止)和i(忽略大小写)// 例子:用户名,只能是英文字母、数字和_，并且首字母必须是英文字母。长度最短不能少于6位 最长不能超过12位。// ^[a-zA-Z][a-zA-Z0-9_]&#123;5,12&#125;// 创建RegExp对象方式（逗号后面不要加空格）var reg1 = new RegExp("^[a-zA-Z][a-zA-Z0-9_]&#123;5,12&#125;$");var str1 = "abcde" // 待匹配字符串: 5位字符组成var str2 = "abcdef" // 待匹配字符串: 6位字符组成var str3 = "1abcdef" // 待匹配字符串: 7位字符组成,数字开头//RegExp对象的test方法，测试一个字符串是否符合对应的正则规则，返回值是true或false。console.log(reg1.test(str1)) // false 开头占1位，后面如果是4个字符，满足不了 &#123;5，12&#125;console.log(reg1.test(str2)) // true 1+5console.log(reg1.test(str3)) // false 不能数字开头 1234567// 第二种写法 /正则/// 创建方式2// /填写正则表达式/匹配模式（逗号后面不要加空格）=var reg2 = /^[a-zA-Z][a-zA-Z0-9_]&#123;5,12&#125;$/;var str2 = 'abcdef'console.log(reg2.test(str2)) 1234567// String对象与正则结合的4个方法var s2 = "hello world";s2.match(/o/g); // ["o", "o"] 查找字符串中 符合正则 的内容s2.search(/h/g); // 0 查找字符串中符合正则表达式的内容位置s2.split(/o/g); // ["hell", " w", "rld"] 按照正则表达式对字符串进行切割s2.replace(/o/g, "s"); // "hells wsrld" 对字符串按照正则进行替换 1234// 坑1console.log("==============================================================")// 正则表达式之间 不能有空格 &#123;5, 11&#125; 要不然就被崩//console.log(/^[a-zA-Z][a-zA-Z0-9]&#123;5, 11&#125;$/.test('xiaoqiang')) 12345678// 坑2// test 不传值 相当于传了一个 undefined// test() 就把undefined 当成是 "undefined" 来判断console.log("==============================================================")console.log(/^[a-zA-Z][a-zA-Z0-9]&#123;5,11&#125;$/.test())console.log(/^[0-9a-zA-Z][a-zA-Z0-9]&#123;5,11&#125;$/.test())console.log(/^[0-9a-zA-Z][a-zA-Z0-9]&#123;5,11&#125;$/.test(undefined))console.log(/^[0-9][a-zA-Z0-9]&#123;5,11&#125;$/.test()) 123456789101112131415161718192021222324252627// 字符串替换 不是改变原来的字符串,需要生成新的字符串var ss = 'Leo'var s3 = ss.replace("o","x")console.log(s3)// 正则 全部替换g 忽略大小写i// JS正则的两种模式:// 1. g 表示全局// 2. i 忽略大小写var ss = 'AbAcad'var s4 = ss.replace(/A/gi,"哈哈哈")console.log(s4)// 坑3// 当正则表达式使用了全局模式(g)时,并且你还让他去检测一个字符串// 此时会引出 lastIndex 记录上次匹配成功位置,并把下一次要开始效验的位置记住// 所以一般不要设置全局// a开头后面2-4位字符// console.log(/^a[a-zA-Z]&#123;2,4&#125;$/g.test("alex"))// console.log(/^a[a-zA-Z]&#123;2,4&#125;$/g.test("alex"))var r = /alex/g;console.log(r.test("alex")) // tureconsole.log(r.lastIndex) // 4console.log(r.test("alex")) // false 从头开始console.log(r.lastIndex) // 0]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F05%2F20%2Fweb-css%2F</url>
    <content type="text"><![CDATA[CSS 介绍 CSS（Cascading Style Sheet，层叠样式表)定义如何显示HTML元素。 当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化（渲染）。 HTML定义了页面的框架，CSS样式表用来装饰页面。 思维导图: https://www.processon.com/mindmap/5a2f4ec4e4b0abb143af4a08 CSS 语法 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 声明又包括属性和属性值。每个声明之后用分号结束。 选择器 {样式1;样式2} h1 {color:red; font-size:14px;} CSS引入方式行内样式 行内式是在标记的style属性中设定CSS样式,不推荐大规模使用。 1&lt;p style="color: blue"&gt;杰尼龟&lt;/p&gt; 内部样式 嵌入式是将CSS样式集中写在网页的&lt;head&gt;&lt;/head&gt;标签对的&lt;style&gt;&lt;/style&gt;标签对中。格式如下： 12345678910&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;style&gt; p &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt; 外部样式(推荐) 外部样式就是将css写在一个单独的文件中，然后在页面进行引入即可。推荐使用此方式。 123456789### link语句在&lt;head&gt;&lt;/head&gt;&gt;下使用&lt;link rel="stylesheet" href="index.css"&gt;### index.css/* 标签选择器 */p &#123; color: red; font-size: 48px;&#125; CSS 选择器 CSS选择器的作用: 查找标签 基本选择器 标签选择器123/* 标签选择器 *//*适用于：批量、统一、默认的样式*/p &#123; color: red;&#125; ID选择器123/* ID选择器 # *//*适用于：给特定标签设置特定样式*/#p2 &#123;color: blue;&#125; 类选择器123/* 类选择器 . *//*适用于：给某一些标签摄者相同的样式*/.c1 &#123;color: yellow;&#125; 123# 注意:# 样式类名不要用数字开头（有的浏览器不认）。# 标签中的class属性如果有多个，要用空格分隔。 通用选择器 通配选择器 * 会找到body里面所有的标签，包括body标签，所以页面整体都会被找到 12/* 类选择器 */* &#123;color: pink;&#125; 组合选择器后代选择器 空格分割 1234/* d1下的所有p标签被找到 */#d1 p &#123; color: red;&#125; 子代选择器 &gt; 只找儿子 1234/* id是d1标签 所有儿子是p标签 */#d1&gt;p&#123; color: green;&#125; 毗邻选择器 + 找紧挨着的兄弟标签 只往下找 1234/* 选择所有紧接着div元素之后的p标签 */div+p&#123; color: yellow;&#125; 弟弟选择器 只要是兄弟标签1234/* div后面的所有的p标签 */div~p&#123; color: blue;&#125; 分组和嵌套分组 当多个元素的样式相同的时候，我们没有必要重复地为每个元素都设置样式，可以通过在多个选择器之间使用逗号分隔的分组选择器来统一设置元素样式。 , 代表 或 123div, p&#123; color: red;&#125; 上面的代码为div标签和p标签统一设置字体为红色。通常，我们会分两行来写，更清晰,但是别忘记加上逗号: 1234div, p&#123; color: red;&#125; 嵌套 多种选择器可以混合起来使用，比如：.d1类内部所有p标签设置字体颜色为红色。 . 代表 且 123.c1 p &#123; color: red;&#125; 找一个class = d1 的span标签 123span.d1&#123; color: pink;&#125; 属性选择器123&lt;p cid="leo"&gt;我是一个P标签&lt;/p&gt;&lt;p cid="lex"&gt;我也是一个P标签&lt;/p&gt;&lt;p&gt;我还是一个P标签&lt;/p&gt; 用于选取带有指定属性的元素 123[cid]&#123; color: pink;&#125; 用于选取带有指定属性和值的元素 123[cid='lex']&#123; color: green;&#125; 伪类选择器 a：link（从未访问过的链接的崭新状态），用于定义了链接的常规状态。 a:hover（鼠标移动到链接上时未点击的悬浮状态），用于产生视觉效果。 a:visited（已访问过的链接的状态）用于阅读文章，能清楚的判断已经访问过的链接。 a:active（在链接上按下鼠标时的状态），用于表现鼠标按下时的链接激活状态。 123456789101112131415161718192021222324252627282930/* 所有没有访问过的a标签 */a:link &#123; color: deeppink;&#125;/* 所有访问过的a标签 */a:visited &#123; color: green;&#125;/* 鼠标移上去 变色 */a:hover &#123; color: blueviolet;&#125;#d1:hover &#123; color: darksalmon;&#125;/* 被选定 鼠标按下去变色 */a:active&#123; color: deeppink;&#125;/*input获取光标时*/input:focus&#123; outline: 0; background-color: deeppink;&#125; 伪元素选择器1234567891011121314151617/*常用的给首字母设置特殊样式：*/p:first-letter&#123; font-size: 48px; color: deeppink;&#125;/*在标签内容开头操作*/.p1:before&#123; content: "*"; color: red;&#125;/*在标签内容最后操作*/.p1:after&#123; content: "[?]"; color: blue;&#125; 选择器优先级 所谓CSS优先级，即是指CSS样式在浏览器中被解析的先后顺序。 1.内联样式表的权值最高 嵌套引入 style=”” －－－ 1000 2.统计选择符中的ID属性个数。 #id －－－ 100 3.统计选择符中的CLASS属性个数。 .class －－－ 10 4.统计选择符中的HTML标签名个数。 p －－－ 1 5.选择器都一样的情况下，谁靠近标签，谁的优先级高 6.万不得已可以使用!important CSS 常用属性宽和高 width 属性可以为元素设置宽度。 height 属性可以为元素设置高度。 只有块级标签才能设置宽和高，内联标签的宽度由内容的长度来决定 1234.d1 &#123; width: 300px; height: 200px;&#125; 字体属性文字字体 font-family 可以把多个字体名称作为一个“回退”系统来保存。 如果浏览器不支持第一个字体，则会尝试下一个。 浏览器会使用它可识别的第一个值。 1234/*全局样式*/*&#123; font-family: "幼圆","Microsoft YaHei" ,"Arial";&#125; 字体大小123.d1 &#123; font-size: 32px;&#125; 字重（粗细）123.d1 &#123; font-weight: bold;&#125; 文本颜色 颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 还有rgba(255,0,0,0.3)，第四个值为alpha, 指定了色彩的透明度/不透明度，它的范围为0.0到1.0之间。 可以通过浏览器工具获取颜色的十六进制值,然后用到自己的样式中 12345.d1 &#123; color: deeppink; /*color: #FF1493;*/ /*color: rgba(255,0,0,0.3);*/&#125; 文字对齐 text-align 属性规定元素中的文本的水平对齐方式。 123.p1&#123; text-align: justify;&#125; 文字装饰 text-decoration 属性用来给文字添加特殊效果。 常用方法: 1234/* 去掉a标签默认的自划线：*/a&#123; text-decoration: none;&#125; 首行缩进 首行缩进 字体像素的两倍就相当于是首行缩进两个字: 12345.p1&#123; font-size: 32px; text-indent: 32px;&#125; 文本其它属性 font-style: oblique; 斜体 letter-spacing: 10px; 字母间距 word-spacing: 20px; 单词间距 text-transform: capitalize/uppercase/lowercase ; 文本转换，用于所有字句变成大写或小写字母，或每个单词的首字母大写 line-height: 200px; 文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比 vertical-align:－4px 设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效 背景属性背景颜色123.d1&#123; background-color: deeppink;&#125; 背景图片 设置背景图片如:200 X 200像素 如果设置的div层宽和高 与图片的像素一致，则直接铺满 如果设置的div层宽和高 大于图片的像素 如 600 X 600 ，如下图，就要进行背景调整12345.d1&#123; width: 600px; height: 600px; background-image: url("xiaoxin.jpg");&#125; 背景重复 repeat(默认):背景图片平铺排满整个网页 repeat-x：背景图片只在水平方向上平铺 repeat-y：背景图片只在垂直方向上平铺 no-repeat：背景图片不平铺 1234567.d1&#123; width: 600px; height: 600px; background-image: url("xiaoxin.jpg"); /*图片超出后不重复(平铺)*/ background-repeat: no-repeat;&#125; 调整背景位置 1234567891011.d1&#123; width: 600px; height: 600px; background-image: url("xiaoxin.jpg"); /*图片超出后不重复(平铺)*/ background-repeat: no-repeat; /*background-position: center;*/ background-position: center; /*x轴 -&gt; 200，y轴100*/ /*background-position: 200px 100px;*/&#125; 支持简写：background:#ffffff url(&#39;1.png&#39;) no-repeat right top; 使用背景图片的一个常见案例就是很多网站会把很多小图标放在一张图片上，然后根据位置去显示图片。减少频繁的图片请求。http://www.w3school.com.cn/css/css_background.asp 鼠标滚动背景不动 123&lt;div class="c1"&gt;&lt;/div&gt;&lt;div class="c2"&gt;&lt;/div&gt;&lt;div class="c3"&gt;&lt;/div&gt; 123456789101112131415.c1&#123; height: 500px; background-color: red;&#125;.c2&#123; height: 500px; background: url("CSS 属性/img23.jpg") no-repeat center; background-attachment: fixed;&#125;.c3&#123; height: 500px; background-color: green;&#125; 边框属性设置边框 border-width 粗细 border-style 样式 border-color 颜色 12345678.d1&#123; height: 200px; width: 300px; background-color: deeppink; border-width: 5px; border-style: solid; background-color: green;&#125; 12345/*通常使用简写方式：*/.d1&#123; border: 5px solid green;&#125; 除了可以统一设置边框外还可以单独为某一个边框设置样式，如下所示： 1234567.d1&#123; border-top-style:dotted; border-top-color: red; border-right-style:solid; border-bottom-style:dotted; border-left-style:none;&#125; 圆角边框123456.d1&#123; height: 200px; width: 200px; border-radius: 100px 100px; background-color: deeppink;&#125; 列表属性12341、list-style-type 设置列表项标志的类型。2、list-style-image 将图象设置为列表项标志。3、list-style-position 设置列表中列表项标志的位置。4、list-style 简写属性。用于把所有用于列表的属性设置于一个声明中 1234/*使用图像来替换列表项的标记:*/ul &#123; list-style-image: url('图片');&#125; display 属性 用于控制HTML元素的显示效果。 none(隐藏某标签) display: none 与 visibility: hidden的区别 visibility:hidden: 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 display:none: 可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 display: none不占位，visibility: hidden占位 12345.d1&#123; height: 100px; color: red; display: none; /*visibility: hidden;*/ block (内联标签设置为块级标签)1234.s1&#123; display: block; background-color: green;&#125; inline(块级标签设置为内联标签)123456&lt;ul class="u1"&gt; &lt;li&gt;&lt;a href=""&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;体育&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;娱乐&lt;/a&gt;&lt;/li&gt; &lt;li class="last"&gt;&lt;a href=""&gt;天气&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213li&#123; display: inline; border-right: 1px solid black; padding: 1px 10px;&#125;li a&#123; text-decoration: none;&#125;li.last&#123; border-right: none;&#125; inline-block display:inline-block可做列表布局，其中的类似于图片间的间隙小bug可以通过如下设置解决： 1234#outer&#123; border: 3px dashed; word-spacing: -5px;&#125; CSS 盒子模型 margin: 用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。 padding: 用于控制内容与边框之间的距离； Border(边框): 围绕在内边距和内容外的边框。 Content(内容): 盒子的内容，显示文本和图像。 margin 外边距12345678910111213141516.d1&#123; height: 300px; width: 300px; background-color: deeppink; /*margin-top:10px;*/ /*margin-right:20px;*/ /*margin-bottom:10px;*/ /*margin-left:20px;*/ /*顺序：上右下左*/ margin: 10px 20px 10px 20px; /*常见居中*/ margin: 0 auto;&#125; 123456789101112131415161718### 简写属性margin:10px 20px 20px 10px； 上边距为10px 右边距为20px 下边距为20px 左边距为10pxmargin:10px 20px 10px; 上边距为10px 左右边距为20px 下边距为10pxmargin:10px 20px; 上下边距为10px 左右边距为20pxmargin:25px; 所有的4个边距都是25px padding内填充123456.padding-test &#123; padding-top: 5px; padding-right: 10px; padding-bottom: 15px; padding-left: 20px;&#125; 123.padding-test &#123; padding: 5px 10px 15px 20px;&#125; 123456顺序：上右下左补充padding的常用简写方式：1、提供一个，用于四边；2、提供两个，第一个用于上－下，第二个用于左－右；3、如果提供三个，第一个用于上，第二个用于左－右，第三个用于下；4、提供四个参数值，将按上－右－下－左的顺序作用于四边； 12345678.d1&#123; height: 200px; width: 300px; background-color: deeppink; margin: 20px 30px; padding: 20px 30px; border: 10px solid black;&#125; body标签的外边距 有时候div的宽度我们设置为100%,依然发现不能占满整个页面的宽度，这是由于body存在8px的外边距(不同的浏览器分辨率有所区别可能), 通用初始化,浏览器不设置外边距,解决屏幕铺满问题 1234*&#123; margin: 0; padding: 0;&#125; float 浮动 浮动:div 配合 float浮动 来做 页面的布局 在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 关于浮动的两个特点： 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 浮动标签 left：向左浮动 right：向右浮动 none：默认值，不浮动 123456789101112131415161718*&#123; margin: 0; padding: 0;&#125;.d1&#123; height: 600px; width: 20%; background-color: red; float: left;&#125;.d2&#123; height: 600px; width: 80%; background-color: green; float: left;&#125; 12345a&#123; /*内联标签设置float就会变成块级标签，可以设置长和宽*/ width: 1000px; float: left;&#125; clear 清除浮动 重要，主要解决清除浮动的副作用（父标签塌陷问题） clear属性规定元素的哪一侧不允许其他浮动元素。 出现塌陷演示1234&lt;div id="d0"&gt; &lt;div class="d1"&gt;c1&lt;/div&gt; &lt;div class="d2"&gt;c2&lt;/div&gt;&lt;/div&gt; 12345678910111213141516*&#123; margin: 0; padding: 0;&#125;#d0&#123; border: 1px solid black;&#125;.d1,.d2&#123; /*如果父标签没有高度，float浮动会脱离父标签;*/ float: left; height: 100px; width: 100px;&#125; 标签塌陷：浮动的标签脱离文档流，不在原来的位置，通过清除浮动即左边不能有标签，在浮动标签下撑起整个父标签 为什么父标签没有高度,因为父标签里没有内容 1、因为里面儿子的div 都是浮动的 不能撑起父标签 2、浮动元素 脱离文档流，不在原来的位置上 3、在父标签的最后增加一个没有高度的设置，撑起整个父标签。 伪元素 撑起父标签12345678910#d0:after&#123; /*伪元素，在父标签上内部的最后,增加一个空内容,他的左边不能有浮动*/ /*父标签就会被撑起来*/ /*不浮动的元素在浮动元素的下面*/ content: ""; clear: left; display: block; /*左右都不能有浮动元素*/ /*clear: both;*/&#125; 业界通用版123456789&lt;div id="d1" class="clearfix"&gt; &lt;div class="d2"&gt;&lt;/div&gt; &lt;div class="d2"&gt;&lt;/div&gt; &lt;div class="d2"&gt;&lt;/div&gt; &lt;div class="d2"&gt;&lt;/div&gt; &lt;!--&lt;div class="d3"&gt;&lt;/div&gt;--&gt;&lt;/div&gt;&lt;div class="d4"&gt;我是正常的内容块&lt;/div&gt; 12345678910111213141516171819202122232425262728293031*&#123; margin: 0; padding: 0;&#125;#d1&#123; /*父div没有高度*/ border: 1px solid black;&#125;.d2&#123; height: 50px; width: 50px; background-color: blue; border: 1px solid red; /*display: inline;*/ /*向左浮动left*/ float: left;&#125;.d4&#123; height: 200px; background-color: darkgreen;&#125;/*业界规定清除浮动类*/.clearfix:after&#123; content: ""; clear: both; display: block;&#125; overflow 溢出属性 12345678&lt;div class="d1"&gt; 国安国安北京国安 国安国安北京国安 国安国安北京国安 国安国安北京国安国安国安北京国安 国安国安北京国安国安国安北京国安国安国安北京国安国安国安北京国安国安国安北京国安国安国安北京国安 国安国安北京国安国安国安北京国安&lt;/div&gt; 123456789.d1&#123; width: 120px; height: 120px; border: 1px solid red; /*给溢出的内容一个滚动条*/ overflow: auto; /*超出的隐藏*/ /*overflow: hidden;*/&#125; 制作圆形头像123&lt;div class="header-img"&gt; &lt;img src="xiaoxin.jpg"&gt;&lt;/div&gt; 123456789101112.header-img&#123; height: 120px; width: 120px; border: 2px solid antiquewhite; border-radius: 100%; /*内容溢出隐藏*/ overflow: hidden;&#125;img&#123; /*max直到父标签的100%*/ max-height: 100px;&#125; position 定位 static:默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。 relative:相对定位相对于原来的位置来说 绝对定位相对于最近的一个被定位过的祖宗标签，一直没有就是body,默认来说走左上角 relative 相对定位 相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。 注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。 12345678910111213141516171819202122232425262728*&#123; margin: 0; padding: 0;&#125;.c1,.c2,.c3&#123; height: 150px; width: 150px;&#125;.c1&#123; background-color: red;&#125;.c2&#123; background-color: green; /*相对定位，相对的是原来在的位置*/ /*左边0,上面是c1的高*/ position: relative; left: 400px; top: 150px;&#125;.c3&#123; background-color: blue;&#125; 123&lt;div class="c1"&gt;&lt;/div&gt;&lt;div class="c2"&gt;&lt;/div&gt;&lt;div class="c3"&gt;&lt;/div&gt; absolute 绝对定位 定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。 父节点没有定位 12345&lt;!-- 绝对定位，父节点没有定位，所有对照body --&gt;&lt;div class="c1"&gt;&lt;/div&gt;&lt;div class="c2"&gt;&lt;/div&gt;&lt;div class="c3"&gt;&lt;/div&gt;&lt;div class="c4"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536*&#123; margin: 0; padding: 0;&#125;.c1,.c2,.c3,.c4&#123; height: 150px; width: 150px;&#125;.c1&#123; background-color: red;&#125;.c2&#123; background-color: green; /*相对定位，相对的是原来在的位置*/ /*左边0,上面是c1的高*/ position: relative; left: 400px; top: 150px;&#125;.c3&#123; background-color: blue;&#125;.c4&#123; background-color: deeppink; position: absolute; top: 150px; left: 400px;&#125; 父节点有定位 12345678&lt;!-- 绝对定位，父节点有定位，对照父节点 --&gt;&lt;!-- 加了一父节点div class=c4-father --&gt;&lt;div class="c1"&gt;&lt;/div&gt;&lt;div class="c2"&gt;&lt;/div&gt;&lt;div class="c3"&gt;&lt;/div&gt;&lt;div class="c4-father"&gt; &lt;div class="c4"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243*&#123; margin: 0; padding: 0;&#125;.c1,.c2,.c3,.c4,.c4-father&#123; height: 150px; width: 150px;&#125;.c1&#123; background-color: red;&#125;.c2&#123; background-color: green; /*相对定位，相对的是原来在的位置*/ /*左边0,上面是c1的高*/ position: relative; left: 400px; top: 150px;&#125;.c3&#123; background-color: blue;&#125;.c4&#123; background-color: deeppink; position: absolute; top: 150px; left: 400px;&#125;.c4-father&#123; position: relative; left: 150px; background-color: darkgoldenrod;&#125; fixed固定 经常用于返回顶部按钮 图片制作 输入网址 图片大小 背景颜色 文字颜色 格式 最后文字内容https://dummyimage.com/600X400/695151/fff.png&amp;text=leo CSS 知识补充小米导航条123456789101112131415161718192021222324252627282930313233343536373839404142*&#123; margin: 0; padding: 0;&#125;ul&#123; list-style-type: none;&#125;.nav-left li&#123; float: left; color: white; padding: 10px;&#125;.nav-right&#123; float: right; padding: 10px;&#125;.nav&#123; background-color: black; padding: 5px 0;&#125;/*清理左右两边浮动*/.clearfix:after&#123; content: ""; display: block; clear: both;&#125;.oa&#123; width: 80%; margin: 0 auto;&#125;a&#123; color: white; text-decoration: none;&#125; 123456789101112131415161718192021&lt;div class="nav "&gt; &lt;div class="oa clearfix"&gt; &lt;div class="nav-left"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;玉米商城&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;大米&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;小米&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;苹果&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;香蕉&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;橘子&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;西瓜&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;荔枝&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="nav-right"&gt; &lt;a href=""&gt;登录&lt;/a&gt; &lt;a href=""&gt;注册&lt;/a&gt; &lt;a href=""&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 脱离文档流 脱离文档流的3种方式 浮动 float 绝对定位 position: absolute 固定定位 position: fixed 123&lt;div class="d1"&gt;&lt;/div&gt;&lt;div class="d2"&gt;&lt;/div&gt;&lt;div class="d3"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839*&#123; margin: 0; padding: 0;&#125;.d1&#123; height: 100px; width: 100px; background-color: deeppink;&#125;.d2&#123; height: 150px; width: 150px; background-color: green; /*脱离文档流 让绿色的框脱离文档原来的位置 */ /*浮动*/ /*float: right;*/ /*相对定位: 标签还占有原来的位置*/ /*position: relative;*/ /*left: 400px;*/ /*绝对定位: 没有就找左上角 蓝色框会顶上来,绿色的框脱离了原来的位置 ，脱离了文档流*/ /*position: absolute;*/ /*left: 400px;*/ /*fixed 固定 蓝色也顶上来，绿色失去了原来的位置，脱离文档流 */ position: fixed; right: 100px; top: 100px;&#125;.d3&#123; height: 200px; width: 200px; background-color: blue;&#125; 内容知识点总结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101.伪类和伪元素 1.伪类 1.:link 2.:visited 3.:hover(重要) 4.:active 5.:focus(input标签获取光标焦点) 2.伪元素 1. :first-letter 2. :before(重要 在内容前面添加) 3. :after(重要 在内容后面添加)2.CSS属性 1.字体： 1. font-family 2. font-size 3. font-weight 2.文本: 1. text-align 对齐 2. text-decoration 装饰(去除a标签的下划线) 3. text-indent 首行缩进 3.背景 1. background-color 颜色 2. background-image 图片 url() no-repeat 4.颜色 1. red 直接写名字 2. #FF0000 3. rgb(255,0,0) --&gt; rgba(255,0,0,0)透明度[0-1] 5.边框 1. border-width 宽度 2. border-style 样式 3. border-color 颜色 border 1px solid red; 6.CSS盒子模型 4个部分 1. content 内容的宽度和高度 2. padding 内填充 调整内容和边框的距离 3. border 边框 4. margin 外边距 调整两个标签之间的距离 (注意两个挨着的标签margin取最大值) 5. 注意：要习惯看浏览器console 窗口的那个盒子模型 7.display 标签的展示形式 1. inline 2. block 菜单里的a标签可以设置成block 3. inline-block 4. none 不显示隐藏，但是不占位 8.float 浮动 1.多用于布局效果 1. 顶部的导航条 2. 页面的左右分栏 blog页面 左边20% 右边80% 3. 任何标签都可以浮动，浮动之后都会变成块级标签（可以设置高和宽） 2.float取值: 1. left 2. right 3. none 默认 9.clear 清除浮动的副作用 （内容溢出，父标签撑不起来） 1. 结合伪元素实现 .clearfix:after&#123; content:"", display:"block", clear:both (左右都清除) &#125; 2.clear 取值: 1. left 2. right 3. both 10.overflow 1.标签的内容放不下(溢出) 2.取值: 1. hidden 隐藏 2. scroll 滚轮 3. inherit 继承父标签 4. auto 自动 5. scroll-x 6. scroll-y 例子: 圆形头像例子 1. overflow:hidden 2. border-radius: 50% 边框圆角 11.position 定位 1. static 默认 2. relative 相对定位 # 相对于原来的位置 3. absolute 绝对定位 # 相对于已经定位过的前辈标签 没有就是body 4.fixed 固定 返回顶部按钮实例 补充: 12.脱离文档流的3种方式 1 浮动 float 2 绝对定位 position: absolute 3 固定定位 position: fixed 13.opacity (不透明度) 1. 和agba的区别: 取值0~1 1是原有,0是全透明 opacity 能改变元素 子标签的透明度 比如背景色和文字 rgba 给谁写才能改变 14.z-index 1. 数值越大，越靠近你 2. 只能作用于 定位过的元素标签 3. 自定义模态框示例]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2019%2F05%2F15%2Fweb-base%2F</url>
    <content type="text"><![CDATA[HTML 介绍前端有哪些内容1234### 三大基础基础: HTML CSS JavaScript框架: Bootstrap JQuery功能: 内容 外观 动作 HTML 是什么 超文本标记语言（Hypertext Markup Language, HTML）是一种用于创建网页的标记语言。 本质上是浏览器可识别的规则，我们按照规则写网页，浏览器根据规则渲染我们的网页。对于不同的浏览器，对同一个标签可能会有不同的解释。（兼容性问题） 网页文件的扩展名：.html或.htm HTML是一种标记语言（markup language），它不是一种编程语言。 HTML使用标签来描述网页。 思维导图: https://www.processon.com/mindmap/5a2f4ec4e4b0abb143af4a08 Web服务的本质12345678### 浏览器输入网址 回车 都发生了什么# 1. 浏览器发请求 --&gt; HTTP协议# 2. 服务端接收请求 --&gt; 服务端返回响应# 3. 服务端把HTML文件内容发给浏览器# 4. 浏览器接收渲染页面# 5. 客户端与服务端 消息的格式是约定好的 ,这个约定就叫做 HTTP协议# 6. HTTP协议:浏览器和服务器之间约定好的消息格式 123456789101112131415161718192021222324# web serverimport socketsk = socket.socket()sk.bind(('127.0.0.1',8090))sk.listen()while 1: conn,addr = sk.accept() conn.recv(1024) # 收消息 conn.send(b'HTTP:/1.1 200 ok\r\n\r\n') # 按照HTTP协议的格式 发消息 # 直接发送 # conn.send(b'&lt;h1&gt;hello!&lt;/h1&gt;') # 从文件读取,按字节 with open("data.html",'rb') as f: msg = f.read() conn.send(msg) conn.close()sk.close()# 浏览器作为客户端访问: 127.0.0.1:8090 1234# data html&lt;h1&gt; hello leo &lt;/h1&gt;&lt;img src = "https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3054306616,2519291525&amp;fm=26&amp;gp=0.jpg"&gt;&lt;a href='http://www.sogo.com'&gt;sogo&lt;/a&gt; HTML 文档结构12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;css样式优先级&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; &lt;!DOCTYPE html&gt; 声明为HTML5文档。 &lt;html&gt;、&lt;/html&gt; 是文档的开始标记和结束的标记。是HTML页面的根元素，在它们之间是文档的头部（head）和主体（body）。 &lt;head&gt;、&lt;/head&gt; 定义了HTML文档的开头部分。它们之间的内容不会在浏览器的文档窗口显示。包含了文档的元（meta）数据。 &lt;title&gt;、&lt;/title&gt; 定义了网页标题，在浏览器标题栏显示。 &lt;body&gt;、&lt;/body&gt; 之间的文本是可见的网页主体内容。 HTML 标签HTML 标签格式之前我们学习到，HTML是一种标记语言(HTML,XML,YTAML),他的作用是使用标签来描述网页。 HTML标签是由尖括号包围的关键字，如&lt;html&gt;, &lt;div&gt;等 HTML标签通常是成对出现的，比如：&lt;div&gt;和&lt;/div&gt;，第一个标签是开始，第二个标签是结束。结束标签会有斜线。 也有一部分标签是单独呈现的，比如：&lt;br/&gt;、&lt;hr/&gt;、&lt;img src=&quot;1.jpg&quot; /&gt;等。 标签里面可以有若干属性，也可以不带属性。 标签的分类1 一般标签与自闭和标签 双标签(一般标签) &lt;h1&gt;&lt;/h1&gt; &lt;a&gt;&lt;/a&gt; 单标签(自闭和标签) &lt;img&gt; &lt;link&gt; 一般标签由于有开始符号和结束符号，可以在标签内部插入其他标签或文字； 自闭合标签由于没有结束符号，没办法在内部插入其他标签或文字，只能定义自身的一些属性。1234567891011121314### 常见的自闭合标签1、&lt;meta/&gt; 定义页面的说明信息，供搜索引擎查看。2、&lt;link/&gt; 用于连接外部的CSS文件或脚本文件。3、&lt;base/&gt; 定义页面所有链接的基础定位。4、&lt;br/&gt; 用于换行。5、&lt;hr/&gt; 水平线。6、&lt;input/&gt; 用于定义表单元素7、&lt;img/&gt; 图像标签。 标签的语法 &lt;标签名 属性1=“属性值1” 属性2=“属性值2”……&gt;内容部分&lt;/标签名&gt; &lt;标签名 属性1=“属性值1” 属性2=“属性值2”…… /&gt; 标签的属性任何标签都有三个常用属性: id：定义标签的唯一ID，HTML文档树中唯一 class：为html元素定义一个或多个类名（classname）(CSS样式类名) style：规定元素的行内样式（CSS样式） HTML注释1&lt;!--注释内容--&gt; HTML 常用标签head 常用标签 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!--定义网页标题--&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;!--定义内部样式表--&gt; &lt;style&gt; a &#123; color: red; &#125; &lt;/style&gt; &lt;!--引入外部样式表文件--&gt; &lt;link rel="stylesheet" href="test.css"&gt; &lt;!--定义JS代码或引入外部JS文件--&gt; &lt;script&gt; alert("hello") &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="head_demo.html"&gt;点我跳转&lt;/a&gt; &lt;h1&gt;大家好&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021### Meta标签介绍：&lt;meta&gt;元素可提供有关页面的元信息（mata-information）,针对搜索引擎和更新频度的描述和关键词。&lt;meta&gt;标签位于文档的头部，不包含任何内容。&lt;meta&gt;提供的信息是用户不可见的。meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 ### 1.http-equiv属性：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。&lt;!--2秒后跳转到对应的网址，注意引号--&gt;&lt;meta http-equiv="refresh" content="2;URL=https://www.oldboyedu.com"&gt;&lt;!--指定文档的编码类型--&gt;&lt;meta http-equiv="content-Type" charset=UTF8"&gt;&lt;!--告诉IE以最高级模式渲染文档--&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;### 2.name属性: 主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。&lt;meta name="keywords" content="meta总结,html meta,meta属性,meta跳转"&gt;&lt;meta name="description" content="老男孩教育Python学院"&gt; body 常用标签基本标签（块级标签和内联标签）1234567891011121314151617&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;s&gt;删除&lt;/s&gt;&lt;p&gt;段落标签&lt;/p&gt;&lt;h1&gt;标题1&lt;/h1&gt;&lt;h2&gt;标题2&lt;/h2&gt;&lt;h3&gt;标题3&lt;/h3&gt;&lt;h4&gt;标题4&lt;/h4&gt;&lt;h5&gt;标题5&lt;/h5&gt;&lt;h6&gt;标题6&lt;/h6&gt;&lt;!--换行--&gt;&lt;br&gt;&lt;!--水平线--&gt;&lt;hr&gt; 特殊字符 div 标签和span 标签 div标签用来定义一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。 span标签用来定义内联(行内)元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。 123456&lt;!--div 和 span div占用一行, span在同一行 --&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;span&gt;我是span&lt;/span&gt; 标签的分类2 块级标签与内联标签的区别根据长度分类: 块级标签: 默认占浏览器宽度,块级标签可以设置长和宽: 1h1 - h6、div、p、hr、 内联(行内)标签: 根据内容决定长度，不能设置长和宽: 1a、img、u、s、i、b、span 标签的嵌套规则: 行内标签不能嵌套块级标签 p标签不能包含块级标签，p标签也不能包含p标签。 图片 img 向网页中嵌入一幅图像 标签并不会在网页中插入图像，而是从网页上链接图像。 标签有两个必需的属性：src 属性 和 alt 属性。1&lt;img src="图片的路径" alt="图片未加载成功时的提示" title="鼠标悬浮时提示信息" width="宽" height="高(宽高两个属性只用一个会自动等比缩放)"&gt; 超链接 a 超链接标签 超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。 1&lt;a href="http://www.baidu.com" target="_blank" &gt;点我&lt;/a&gt; 1234567891011### 什么是URL？URL是统一资源定位器(Uniform Resource Locator)的缩写，也被称为网页地址，是因特网上标准的资源的地址。URL举例http://www.sohu.com/stu/intro.htmlURL地址由4部分组成第1部分：为协议：http://、ftp://...等 第2部分：为站点地址：可以是域名或IP地址第3部分：为页面在站点中的目录：stu第4部分：为页面名称，例如 index.html各部分之间用“/”符号隔开。 123456789### href 属性指定目标网页地址。该地址可以有几种类型：1、绝对URL - 指向另一个站点（比如 href="http://www.jd.com）2、相对URL - 指当前站点中确切的路径（href="index.htm"）3、锚URL - 指向页面中的锚（href="#top"）&lt;!--锚URL - 指向页面中的锚（href="#top"）--&gt;&lt;a href="#a2"&gt;a1跳a2&lt;/a&gt;&lt;div style="height: 1000px;background: red"&gt;&lt;/div&gt;&lt;a href="" id="a2"&gt;哈哈哈&lt;/a&gt; 123### target：_blank表示在新标签页中打开目标网页_self表示在当前标签页中打开目标网页 列表 无序列表: ui 有序列表: oi 标题列表: dl 1234567891011### 无序列表: ui&lt;ul type="circle"&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ul&gt;### type属性：disc（实心圆点，默认值）circle（空心圆圈）square（实心方块）none（无样式） 123456789101112### 有序列表: oi&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt;### type属性：1 数字列表，默认值A 大写字母a 小写字母Ⅰ大写罗马ⅰ小写罗马 12345678### 标题列表: dl&lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;内容2&lt;/dd&gt; &lt;dd&gt;内容2&lt;/dd&gt;&lt;/dl&gt; 表格 table 表格是一个二维数据空间，一个表格由若干行组成，一个行又有若干单元格组成，单元格里可以包含文字、列表、图案、表单、数字符号、预置文本和其它的表格等内容。 表格最重要的目的是显示表格类数据。表格类数据是指最适合组织为表格格式（即按行和列组织）的数据。 12345678910111213141516171819202122232425262728293031323334### 表格的基本结构&lt;table border="1" cellpadding="10" cellspacing="10"&gt; &lt;!-- 表头开始 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;爱好&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!-- 表内数据开始 --&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan="2"&gt;leo&lt;/td&gt; &lt;!--&lt;td&gt;28&lt;/td&gt;--&gt; &lt;td rowspan="2"&gt;游戏&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;lex&lt;/td&gt; &lt;td&gt;28&lt;/td&gt; &lt;!--&lt;td&gt;开车&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;### 属性:border: 表格边框.cellpadding: 内边距cellspacing: 外边距.width: 像素 百分比.（最好通过css来设置长宽）rowspan: 单元格竖跨多少行colspan: 单元格横跨多少列（即合并单元格） 快捷语句123456781、快速格式化 : Code --&gt; reformat code2、快速建立4个标签 : h1*4 --&gt;点击tab3、快速建立标签并增加属性 : div*4&gt;a.c1&#123;a标签$&#125;### div*4&gt;a.c1&#123;a标签$&#125; == 快速建立4个div标签，里面添加a标签,class='c1',内容为&#123;a标签$&#125;,&#123;$&#125;表示从1开始的序号 &lt;div&gt;&lt;a href="" class="c1"&gt;a标签1&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;a href="" class="c1"&gt;a标签2&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;a href="" class="c1"&gt;a标签3&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;a href="" class="c1"&gt;a标签4&lt;/a&gt;&lt;/div&gt; Form 表单 form 表单的作用：表单用于收集用户的输入信息，然后向服务器传输数据，从而实现用户与Web服务器的交互 表单能够包含input系列标签，如文本字段、复选框、单选框、提交按钮等等，表单还可以包含textarea、select、fieldset和 label标签。 表单属性 123456action: 表单提交到哪.一般指向服务器端一个程序,程序接收到表单提交过来的数据（即表单元素值）作相应处理，比如https://www.sogou.com/webmethod: 表单的提交方式 post/get，默认取值就是get# 关于表单提交点击sumbit提交后，会将数据组装成字典格式—键值对如果是：与查询相关的内容，使用get提交方法，数据在地址栏用？隔开如果是：服务器修改相关的内容用post请求 数据在请求体里 http协议中可见 Djaogo接收表单数据代码12345678910111213141516171819from django.conf.urls import urlfrom django.shortcuts import HttpResponsedef upload(request): print('request.GET:',request.GET) print("request.POST:", request.POST) if request.FILES: filename = request.FILES['avatar'].name with open(filename,'wb') as f: for chunk in request.FILES['avatar'].chunks(): f.write(chunk) return HttpResponse("上传成功") return HttpResponse('收到了')urlpatterns = [ url(r'^upload/',upload)] input系列标签 text 文本框12345678910&lt;p&gt; &lt;label for="username"&gt;用户名:&lt;/label&gt; &lt;input type="text" id="username" name="username" placeholder="请输入用户名" value="默认值" disabled&gt;&lt;/p&gt;# 属性说明: 1、disabled: 禁用2、placeholder: 占位符3、value: 默认值4、request.GET: &lt;QueryDict: &#123;'username': ['leo']&#125;&gt; password 密码输入框12345678&lt;p&gt; &lt;label for="password"&gt;密码:&lt;/label&gt; &lt;input type="password" id="password" name="password" placeholder="请输入密码" &gt;&lt;/p&gt;# 属性说明:1、基本与text一致2、request.GET: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123']&#125;&gt; date 日期1234567&lt;p&gt; &lt;label for="birthday"&gt;生日:&lt;/label&gt; &lt;input type="date" id="birthday" name="birthday"&gt;&lt;/p&gt;# 属性说明:1、request.GET: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20']&#125;&gt; radio 单选按钮123456789101112&lt;p&gt; &lt;label&gt;性别:&lt;/label&gt; &lt;input type="radio" id="r1" name="gender" value="男"&gt; &lt;label for="r1"&gt;男&lt;/label&gt; &lt;input type="radio" id="r2" name="gender" value="女"&gt; &lt;label for="r2"&gt;女&lt;/label&gt;&lt;/p&gt;# 属性说明:1、checked: 默认选中2、value:选择相关联的值 3、request.GET: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 'gender': ['男']&#125;&gt; checkbox 多选按钮1234567891011121314&lt;p&gt; &lt;label&gt;爱好:&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="football" checked&gt;足球 &lt;input type="checkbox" name="hobby" value="basketball"&gt;篮球 &lt;input type="checkbox" name="hobby" value="doubleball"&gt;双色球&lt;/p&gt;# 属性说明1、key=name: 多选标签的name必须一致，"hobby":[basketball,doubleball]2、值=value: value值必须设置3、value:选择相关联的值 4、checked: 默认选中5、request.GET: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 'gender': ['男'], 'hobby': ['basketball', 'doubleball']&#125;&gt; submit 提交按钮12345678&lt;p&gt; &lt;input type="submit" value="提交数据"&gt; &lt;input type="reset" value="重置数据"&gt;&lt;/p&gt;# 属性说明1、value:按钮上显示的文本内容2、点击sumbit会将表单中的数据组成字典(键值对)，并向服务器提交数据 reset 撤销按钮1234567&lt;p&gt; &lt;input type="submit" value="提交数据"&gt; &lt;input type="reset" value="重置数据"&gt;&lt;/p&gt;# 属性说明1、value:按钮上显示的文本内容2、点击reset撤销按钮，会将输入的内容数据重置 button 普通按钮123456&lt;p&gt; &lt;input type="button" value="普通事件按钮" onclick="alert(123)"&gt;&lt;/p&gt;# 属性说明1、通常用于JS绑定事件2、value: 按钮显示文本 hidden 隐藏标签123456&lt;p&gt; &lt;input type="hidden" name="user_id" value="leo_id"&gt;&lt;/p&gt;# 属性说明:1、每个页面中存储的用户信息比如隐藏身份证2、key=name, 值=value file 上传标签上传文件注意两点： 请求方式必须是: post form标签增加: enctype=”multipart/form-data” 1234567891011&lt;form action="http://127.0.0.1:8000/upload/" method="post" enctype="multipart/form-data"&gt; &lt;p&gt; &lt;input type="file" name="avatar" &gt; &lt;/p&gt;&lt;/form&gt;# 属性说明1、key="name",值="上传文件对象"2、request.POST: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 'gender': ['男'], 'hobby': ['football', 'basketball'], 'leo': ['leo_id']&#125;&gt;3、上传的附件会根据程序代码存储到指定目录 input表单标签属性总结 name: 表单提交时的“键”，注意和id的区别 value: 表单提交时对应项的值: type=”button”, “reset”, “submit”时，为按钮上显示的文本内容 type=”text”,”password”,”hidden”时，为输入框的初始值 type=”checkbox”, “radio”, “file”，为输入相关联的值 checked: radio和checkbox默认被选中的项 readonly: text和password设置只读 disabled: 所有input均适用 其他常用标签label 标记定义： 标签为 input 元素定义标注（标记）。1234# 属性说明:1、label 元素不会向用户呈现任何特殊效果。2、&lt;label&gt; 标签的 for 属性值应当与相关元素的 id 属性值相同。3、点击label内的内容 可以进入text文本框的光标 用for关联text的id select 下拉菜单123456789101112131415161718# 普通下拉框&lt;p&gt; &lt;label for="city"&gt;城市:&lt;/label&gt; &lt;select name="city" id="city"&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="hongkong" selected&gt;香港&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;# 属性说明:1、select 标签中的name为键2、option 标签中的value为值，一般情况下都不会使用中文,常用的地市会使用区号 010 = 北京3、selected="selected" 默认选中4、multiple="multiple" 为多选5、optgroup 分组的下拉框6、request.POST: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 'gender': ['男'], 'hobby': ['football', 'basketball'], 'city': ['beijing'], 'area': ['xc'], 'info': ['哈哈哈'], 'leo': ['leo_id']&#125;&gt; 12345678910111213141516# 分组下拉框&lt;p&gt; &lt;label for="area"&gt;区域&lt;/label&gt; &lt;select name="area" id="area"&gt; &lt;optgroup label="北京"&gt; &lt;option value="xc" selected&gt;西城&lt;/option&gt; &lt;option value="dc"&gt;东城&lt;/option&gt; &lt;option value="sjs"&gt;石景山&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="上海"&gt; &lt;option value="pd"&gt;浦东新区&lt;/option&gt; &lt;option value="hp"&gt;黄浦区&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;&lt;/p&gt; textarea 多行文本1234567891011&lt;p&gt; &lt;label for="info"&gt;自我介绍&lt;/label&gt; &lt;textarea id="info" name="info" cols="30" rows="10" placeholder="不少于100字"&gt;&lt;/textarea&gt;&lt;/p&gt;# 属性说明1、key=name,值=用户输入2、rows：行数3、cols：列数4、request.POST: &lt;QueryDict: &#123;'username': ['leo'], 'password': ['123456'], 'birthday': ['2019-05-20'], 、'gender': ['男'], 'hobby': ['football', 'basketball'], 'city': ['beijing'], 'info': ['哈哈哈'], 'leo': ['leo_id']&#125;&gt; form表单提交数据的几个注意事项 所有获取或用户输入的标签，都必须放在form表单里面 action 控制着往哪提交 input\select\textarea 都需要有name属性 提交按钮 input type=’sumbit’ file文件 需要post提交方式和enctype=”multipart/form-data”]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发爬虫]]></title>
    <url>%2F2019%2F05%2F10%2Fconcurrent-crawl%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO 模型]]></title>
    <url>%2F2019%2F05%2F08%2Fio-model%2F</url>
    <content type="text"><![CDATA[IO模型介绍Stevens在文章中一共比较了五种IO Model：12345# 1、blocking IO 阻塞IO# 2、nonblocking IO 非阻塞IO# 3、IO multiplexing IO多路复用# 4、signal driven IO 信号驱动IO# 5、asynchronous IO 异步IO 由于signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model IO发生时涉及的对象和步骤:对于一个network IO (这里我们以read举例)，它会涉及到 两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，该操作会经历两个阶段： 12#1）等待数据准备 (Waiting for the data to be ready)#2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process) 阻塞 IO(blocking IO) 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。kernel要等待足够的数据到来,用户进程这边，整个进程会被阻塞。 有数据到来后，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。 几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。123# 使用多线程或多进程解决阻塞？# 在服务器端使用多线程（或多进程）。# 多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。 123# 多线程或多进程的问题:# 开启多进程多线程的方式，在遇到要同时响应成百上千路的连接请求，# 则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态。 1234# 使用线程池或进程池的问题:# 线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。# 而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。# 所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。 对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。 非阻塞 IO(non-blocking IO) 当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。 用户进程判断结果是一个error时，它就知道数据还没有准备好，于是用户就可以在本次到下次再发起read询问的时间间隔内做其他事情，或者直接再次发送read操作。 一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存（这一阶段仍然是阻塞的），然后返回。 所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。 但是非阻塞IO模型绝不被推荐。12345#1. 循环调用recv()将大幅度推高CPU占用率；这也是我们在代码中留一句time.sleep(2)的原因,否则在低配主机下极容易出现卡机情况#2. 任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。# 这会导致整体数据吞吐量的降低。#3. recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，# 例如select()多路复用模式，可以一次检测多个连接是否活跃。 多路复用 IO(IO multiplexing)IO multiplexing这个词可能有点陌生，但是如果我说select/epoll，大概就都能明白了。有些地方也称这种IO方式为事件驱动IO(event driven IO)。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。结论: select的优势在于可以处理多个连接，不适用于单个连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445# IO 多路复用# 代理帮忙去查看链接和接收发送消息,代理可以监听多个对象# windows 拥有select模块import selectimport socketsk = socket.socket()sk.bind(('127.0.0.1',8000))sk.setblocking(False) # 非阻塞模式sk.listen()read_lst = [sk] # 监听谁就放谁# print(ret) # ([&lt;socket.socket fd=204, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000)&gt;], [], [])# print(r_lst) # [&lt;socket.socket fd=204, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000)&gt;]# print(sk) # &lt;socket.socket fd=204, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000)&gt;# r_lst 里面存着的 sk对象while True: # 当有链接来连，获取了socket对象并链接 # 将对象再放入列表中继续监听 [sk,conn] r_lst, w_lst, x_lst = select.select(read_lst, [], []) # r_list和其他空列表 # print('******',r_lst) for i in r_lst: if i is sk: conn,addr = i.accept() # print(conn) # &lt;socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 8000), raddr=('127.0.0.1', 61832)&gt; read_lst.append(conn) else: # 否则是conn ret = i.recv(1024) if ret == b'': i.close() read_lst.remove(i) continue print(ret) i.send(b'bye')# IO多路复用 # select Windows Linux 都是操作系统轮询每一个被监听的项，看是否有读才做 # poll Linux 可以监听的对象比select对象多 # 随着监听项的增多，导致效率降低 # epoll Linux 给每一个监听对象都绑定一个回调函数 # selectors 可以自动帮我们选适合操作系统的模块 12345678910111213141516# clientimport socketimport timeimport threadingdef func(): sk = socket.socket() sk.connect(('127.0.0.1',8000)) sk.send(b'hello') time.sleep(3) print(sk.recv(1024)) sk.close()for i in range(20): threading.Thread(target=func).start() 异步IO (Asynchronous I/O) 12345678910111213141516### 需要记住# 同步 # 提交一个任务之后，要等待这个任务执行完毕# 异步 # 只管提交任务，不等待这个任务执行完毕，就可以做其他事情# 阻塞 # recv、recvfrom、accept # 非阻塞 # 都可以正常执行# 阻塞和非阻塞 # 线程遇到阻塞 ： 运行 --&gt; 阻塞 --&gt; 就绪 --&gt; 运行 # 线程遇到非阻塞：运行 &lt;--&gt; 就绪 123456789### 需要理解# 1、异步IO 没有数据 直接返回# 2、操作系统会告诉我有新数据进来，并直接将数据交给用户# 异步IO 没有wait data 和 copy data# 其他模型只是对wait data 进行优化# 异步IO 都是操作系统来完成 wait data 和 copy data，Python并不能完成，C语言可以直接实现# Python的异步模块和框架 很多都是用底层的C语言实现 框架包括Twisted和Tornado# 异步框架 可以相应更多的需求 IO模型比较分析12# blocking和non-blocking的区别# 调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回 selectors 模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#服务端from socket import *import selectorssel=selectors.DefaultSelector()def accept(server_fileobj,mask): conn,addr=server_fileobj.accept() # accept 建立后 注册conn sel.register(conn,selectors.EVENT_READ,read) # 监听conn的读时间 , 回调函数 readdef read(conn,mask): try: data=conn.recv(1024) if not data: print('closing',conn) sel.unregister(conn) conn.close() return conn.send(data.upper()+b'_SB') except Exception: print('closing', conn) sel.unregister(conn) conn.close()# 建立socket对象sk=socket(AF_INET,SOCK_STREAM) # socket对象sk.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)sk.bind(('127.0.0.1',8088))sk.listen(5)sk.setblocking(False) #设置socket的接口为非阻塞# 选择适合的IO多路复用机制# sel=selectors.DefaultSelector() selectors模块sel.register(sk,selectors.EVENT_READ,accept)# selectors.EVENT_READ 监听的是一个读事件# 相当于网select的读列表里append了一个socket对象,并且绑定了一个回调函数 accept# 有人请求链接socket了 就调用 accept方法 accept(server_fileobj,mask)while True: events=sel.select() # 检测所有的fileobj(socket|conn)，是否有完成wait data for sel_obj,mask in events: callback=sel_obj.data # callback=accpet | read callback(sel_obj.fileobj,mask) # accpet(server_fileobj,1) | read(conn,l)#客户端from socket import *c=socket(AF_INET,SOCK_STREAM)c.connect(('127.0.0.1',8088))while True: msg=input('&gt;&gt;: ') if not msg:continue c.send(msg.encode('utf-8')) data=c.recv(1024) print(data.decode('utf-8'))# selectors 模块 可以帮助我们选择适合操作系统的IO多路复用模块# 非阻塞IO一直在询问，会耗费CPU# 1、异步IO 没有数据 直接返回# 2、操作系统会告诉我有新数据进来，并直接将数据交给用户]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>IO多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程]]></title>
    <url>%2F2019%2F04%2F30%2Fcoroutines%2F</url>
    <content type="text"><![CDATA[什么是协程 在操作系统中进程是资源分配的最小单位,线程是CPU调度的最小单位。 无论是创建多进程还是创建多线程来解决问题，都要消耗一定的时间来创建进程、创建线程、以及管理他们之间的切换。 基于单线程来实现并发又成为一个新的课题，即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并发。这样就可以节省创建线进程所消耗的时间。 并发的本质：切换+保存状态cpu正在运行一个任务，会在两种情况下切走去执行其他的任务（切换由操作系统强制控制），一种情况是该任务发生了阻塞，另外一种情况是该任务计算的时间过长。 协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。为了实现它，我们需要找寻一种可以同时满足以下条件的解决方案： 可以控制多个任务之间的切换，切换之前将任务的状态保存下来，以便重新运行时，可以基于暂停的位置继续执行。 作为1的补充：可以检测io操作，在遇到io操作的情况下才发生切换 实现在多个任务之间切换 yield + send yield无法做到遇到io阻塞12345678910111213141516171819202122232425262728293031323334353637383940# 进程 : 启动多个进程,进程之间是由操作系统负责调用# 线程 : 启动多个线程,真正被CPU执行的最小单位实际是线程 # 开启一个线程 ：创建1个线程,属于线程的内存开销 寄存器和堆栈 # 关闭一个线程 # 线程在CPython下，由于全局GLI锁，多线程没有办法同时访问CPU，真正工作只有一个CPU# 协程 : 本质上是一个线程 # 在多个任务之间切换，来节省IO时间 # 无需切换寄存器 和 堆栈，只是正常在程序之间切换 # ***** 能在多个任务之间切换 # ***** 协程中任务之间的切换也消耗时间，但是开销，要远远小于进程线程之间的切换。# 实现并发的手段### 实现在多个任务之间切换 yield + sendimport timedef consumer(): # print(111111) while True: x = yield time.sleep(1) print('处理了数据: ' ,x)def producer(): c = consumer() # 生成器 next(c) # 激活生成器,send之前必须next for i in range(10): time.sleep(1) print('生产了数据 %s ' %i) c.send(i)producer() # 在producer控制了consumer函数，并且来回切换 即-在两个任务中切换c = consumer() # 生成器print(c) # &lt;generator object consumer at 0x00000000021C84C0&gt;c.__next__()next(c)c.send(100)c.send(200) greenlet 模块切换执行程序12345678910111213141516171819202122232425262728293031323334353637from greenlet import greenlet# pip3 install greenlet# pip3 install gevent# greenlet 学习一下 后续不用# 协程模块# 切换执行程序# 真真干的协程模块，就是使用greenlet完成的切换def eat(): print('eating start') g2.switch() # 第1次切换 在这里switch(切换)，不仅切换还会记录执行的位置 print('eating end') g2.switch()def play(): print('playing start') g1.switch() print('playing end')# 把执行的方法 交给greenletg1 = greenlet(eat)g2 = greenlet(play)g1.switch() # 首先让g1执行# 结果: 出现switch即切换程序# eating start# playing start# eating end# laying end# 进程 4c+1 = 5# 线程 4c*5 = 20# 协程 每个线程里最多可以启动500个协程# 并发 1个进程20个线程 5个进程 100个线程 100个线程 = 50000W个协程# nginx 分发任务,最大承载量 5W# 在IO等待的时候 切换执行其他任务 使用gevent模块实现协程 安装：pip3 install gevent Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。 123456# g1=gevent.spawn(func,1,,2,3,x=4,y=5)创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的# g2=gevent.spawn(func2)# g1.join() #等待g1结束# g2.join() #等待g2结束# 或者上述两步合作一步：gevent.joinall([g1,g2])# g1.value#拿到func1的返回值 使用gevent实现IO切换123456789101112131415161718192021222324252627282930313233343536373839from gevent import monkey;monkey.patch_all()# 会把后面所有的阻塞操作都打成包，就会认识到time.sleepimport timeimport geventimport threading# 遇到IO切换def eat(): print(threading.current_thread().getName()) # DummyThread-1 仿制品线程 虚拟线程 -- 协程 print('eating start') time.sleep(1) # gevent.sleep(1) print('eating end')def play(): print(threading.current_thread().getName()) print('playing start') time.sleep(1) # gevent.sleep(1) print('playing end')g1 = gevent.spawn(eat) # gevent 遇到IO会自动切换g2 = gevent.spawn(play)g1.join() # 等待g1执行结束g2.join() # 等待g2执行结束,不然则异步# 或者上述两步合作一步：gevent.joinall([g1,g2])# 结果# eating start# playing start 同时开始# 同时睡一秒# eating end 同时结束# playing end# 总结：# 1、进程和线程的任务切换 由操作系统完成，而协程任务切换由程序代码完成,只有遇到协程模块能识别的IO操作的时候，程序才会执行任务切换# 实现并发效果。# 2、协程是通过greenlet模块的switch()方法控制切换 gevent的同步和异步1234567891011121314151617181920212223242526272829# gevent.sleep(2)模拟的是gevent可以识别的io阻塞,而time.sleep(2)或其他的阻塞,# gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了# from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前# 或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头from gevent import monkey;monkey.patch_all()import timeimport geventdef task(): time.sleep(1) # 模拟IO阻塞 print(12345)def sync(): # synchronous = sync 同步 for i in range(10): task()def async(): # 异步 g_lst = [] for i in range(10): g = gevent.spawn(task) g_lst.append(g) # for g in g_lst:g.join() # 等待所有的协程结束 gevent.joinall(g_lst) # 接收可迭代对象 每个g都执行完join# sync() # 同步 睡一秒执行一个async() # 异步 都睡一秒一起执行# 协程 适合用于网络操作，比如爬虫 协程爬虫小例子123456789101112131415161718192021222324252627282930313233343536373839404142434445# 协程：能够在线程中实现并发效果 # 能够规避一些在任务中遇到的IO操作 # 在任务的执行过程中,检测到IO就切换到其他任务### 协程 — 爬虫例子# 正则基础# 请求过程中的IO等待from gevent import monkey;monkey.patch_all()import requestsimport geventurl = 'https://maoyan.com/board/4'# res = requests.get(url)# print(len(res.content.decode('utf-8')))# print(len(res.text))def get_url(url): headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/71.0.3578.98 Safari/537.36' &#125; res = requests.get(url,headers=headers) html = res.content.decode('utf-8') return len(html)# ret = get_url('http://www.baidu.com')g1 = gevent.spawn(get_url,'http://www.tianmao.com')g2 = gevent.spawn(get_url,'http://www.taobao.com')g3 = gevent.spawn(get_url,'http://www.jd.com')g4 = gevent.spawn(get_url,'https://maoyan.com/board/4')gevent.joinall([g1,g2,g3,g4])print(g1.value)print(g2.value)print(g3.value)print(g4.value)# 总结：# 为什么用到协程 # 多线程在CPython解释器下，存在GIL锁，无法真正的使用多个CPU，多个线程之间的切换就会浪费时间 # 可以把一个线程的作用发挥到极致 1个线程可以开启500个协程,提高了CPU的利用率 # 协程相比于多线程的优势 ，切换的效率更快]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2019%2F04%2F25%2Fthread%2F</url>
    <content type="text"><![CDATA[线程进程内容回顾： 程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。 程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。 在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。 进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。 进程的出现，可以让一台服务器同时处理多个任务,在多个任务之间来回切换并记录任务执行状态。 进程的缺陷： 进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。 进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。 线程的出现：随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。因此在80年代，出现了能独立运行的基本单位——线程（Threads）。 注意: 进程是资源分配的最小单位,线程是CPU调度的最小单位. 每一个进程中至少有一个线程。 进程和线程的关系 地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 调度和切换：线程上下文切换比进程上下文切换要快得多。 在多线程操作系统中，进程不是一个可执行的实体。 线程的特点在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。 轻型实体。存储的较少线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。 独立调度和分派的基本单位。 真正被操作系统调度的是线程在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。 共享进程资源。 进程的数据在多线程中使用不用ipc，而是直接使用线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。 可并发执行。 比如6个线程可以运行不同的代码在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。 内存中的线程 多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程。而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。 不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。 类似于进程，每个线程也有自己的堆栈，不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。 线程通常是有益的，但是带来了不小程序设计难度，线程的问题是： 父进程有多个线程，那么开启的子线程是否需要同样多的线程 在同一个进程中，如果一个线程关闭了文件，而另外一个线程正准备往该文件内写内容呢？因此，在多线程的代码中，需要更多的心思来设计程序的逻辑、保护程序的数据。 开启多线程通过threading模块开启多线程123456789101112131415# Python多线程模块# thread、threading和Queue 推荐使用threading# 线程的创建Threading.Thread类import timefrom threading import Thread# 多线程并发def func(n): time.sleep(1) # 10次子线程一起执行 print(n) # 并发for i in range(10): t = Thread(target=func,args=(i,)) t.start() 通过继承threading类 开启多线程1234567891011121314import timefrom threading import Threadclass MyTread(Thread): def __init__(self,arg): super().__init__() self.arg = arg def run(self): time.sleep(1) print(self.arg)for i in range(10): t = MyTread(10) t.start() 多线程与多进程12345678910111213141516import osimport timefrom threading import Threaddef func(a,b): n = a+b print(n,os.getpid())print('主线程',os.getpid())for i in range(10): t = Thread(target=func,args=(i,5)) t.start()# 主线程和子线程的pid是一致的，说明子线程都是在一个进程里执行# 主进程中 存储 导入的模块，文件所在的位置，内置的函数，代码# 主线程存储循环的i 和 t# 子线程拥有栈，里面存储着 add a 和 b n = 0+5 内存数据共享12345678910111213141516171819# 内存数据共享import osimport timefrom threading import Threaddef func(a,b): global g g = 0 # g = 0 + a print(g,os.getpid())g = 100t_lst = []print('主线程',os.getpid())for i in range(10): t = Thread(target=func,args=(i,5)) t.start() t_lst.append(t)for t in t_lst:t.join()print(g) 12345678910111213141516171819202122232425262728293031# 总结:# 进程 是 最小的内存分配单位# 线程 是 操作系统调度的最小单位# 真正被执行的是线程，线程被CPU执行# 进程内至少含有一个线程# 进程中可以开启多个线程 # 开启一个线程 所需要的时间 要远远小于开启一个进程 # 线程占用的内存空间 也更小 # 多个线程内部有自己的数据栈，这个数据是不共享的 # 全局变量在多个线程之间是共享的# 在CPython解释器下的Python程序 # 在同一时刻，多个线程中只能有一个线程 被 CPU执行 # 高CPU：计算类 --- 高CPU利用率 执行效率不高 # 高IO: # 爬取网页 # 读写文件 处理日志文件 # 网络请求 处理web请求 # 读数据库 写数据库 # 非要处理计算类，就使用多进程 进程与进程没有锁 # 4个CPU# 不同的CPU可以执行多条线程，可能会造成数据的混乱# 对同一个数据的加减操作# CPython解释器 为了避免 存在 一种锁 GLP 全局解释器锁# 任何一个线程 想要给CPU 必须拿到钥匙，只有拿到钥匙的线程才能交给CPU执行# 重点：# 1 同一时刻，只能有一个线程，访问CPU，# 2 锁的是什么？锁的是线程# 3 锁的缺点: 多线程不能充分的利用CPU，同一时间只能用到一个C# 4 GLP是Python语言的问题么？ 不是，是CPython解释器的特性，JPython没有这个锁 多线程与多进程执行效率对比123456789101112131415161718192021222324252627282930import timefrom threading import Threadfrom multiprocessing import Processdef func(n): n + 1 # 计算操作 占用cpuif __name__ == '__main__': start = time.time() t_lst = [] for i in range(100): t = Thread(target=func,args=(i,)) t.start() t_lst.append(t) for t in t_lst:t.join() t1 = time.time() - start start = time.time() p_lst = [] for i in range(100): p = Process(target=func,args=(i,)) p.start() p_lst.append(t) for p in p_lst:p.join() t2 = time.time() - start print('线程执行',t1) # 0.009000539779663086 print('进程执行',t2) # 1.8071033954620361 # 对于高IO 和 简单的高CPU计算任务时 , 多线程的开销更少，执行效率更高 线程模块中的其他方法123456789101112131415import threadingimport timedef wahaha(n): time.sleep(0.5) print(n,threading.current_thread(),threading.get_ident()) # 子线程 名字 PIDfor i in range(10): threading.Thread(target=wahaha,args=(1,)).start()print(threading.active_count()) # 查看当前所有的活跃的线程数 # 11 (10个子线程+1个主线程)print(threading.current_thread()) # 主线程 名字 PIDprint(threading.enumerate()) # 所有的进程名字 pid 存在一个列表返回print(len(threading.enumerate())) # 11 多线程实现简单的socket服务123456789101112131415161718192021# serverimport socketfrom threading import Threaddef chat(conn): conn.send(b'hello') msg = conn.recv(1024).decode('utf-8') print(msg) conn.close()s = socket.socket()s.bind(('127.0.0.1',8090))s.listen()while True: conn,addr = s.accept() # 获取连接 t = Thread(target=chat,args=(conn,)) t.start()s.close() 1234567891011# clientimport sockets = socket.socket()s.connect(('127.0.0.1',8090))msg = s.recv(1024).decode('utf-8')print(msg)inp = input('&gt;&gt;&gt;').encode('utf-8')s.send(inp)s.close() 守护线程 daemon=True123456789101112131415161718192021222324252627282930313233343536373839404142434445import timefrom threading import Threaddef func1(): while True: print(10 * '*') time.sleep(1)def func2(): print('in func2') time.sleep(5)t = Thread(target=func1,)t.daemon = Truet.start()t2 = Thread(target=func2,)t2.start()t2.join() # 所有的t2结束后打印在执行主进程代码# 守护进程 随着主进程代码的执行结束 而结束# 守护线程 会在主线程结束之后，等待其他子线程的结束而结束# 主进程 在执行完自己的代码之后 不会立即结束，而是等待子进程结束之后 回收子进程的资源import timefrom multiprocessing import Processdef func1(): while True: print(10 * '*') time.sleep(1)def func2(): print('in func2') time.sleep(5)if __name__ == '__main__': p = Process(target=func1, ) p.daemon = True # 守护线程 主线程结束，守护线程随之结束 p.start() p2 = Process(target=func2, ) p2.start() print('主进程') 线程锁 Lock123456789101112131415161718192021222324252627282930import timefrom threading import Lock,Threaddef func(lock): global n lock.acquire() temp = n time.sleep(0.2) n = temp - 1 lock.release()n = 10t_lst = []lock = Lock()for i in range(10): t = Thread(target=func,args=(lock,)) t.start() t_lst.append(t)for i in t_lst:t.join() # 执行完所有子线程print(n)# 10个线程分别 n - 1# 1、10个线程同时执行 都去拿 n = 10# 2、都sleep 0.2秒,同时减1# 3、同时赋值回去 大家赋值的都是9# 4、为什么有了GIL锁 还是会出现混乱 : 拿到数据后 刚好时间片到了会释放锁 ，就会拿到同一数据# 5、GIL锁加给线程，为了避免多个线程同一时间对一个数据操作，但是无法避免时间片的轮转对数据的不安全性# 6、多线程里还需要用到锁# 7、加锁，牺牲了效率，保证了数据安全 递归锁解决死锁问题 RLock1234567891011121314151617181920212223242526272829303132333435363738394041import timefrom threading import Lock,Threadnoodle_lock = Lock()fork_lock = Lock()def eat1(name): noodle_lock.acquire() print('%s 拿到面条' %name) fork_lock.acquire() print('%s 拿到叉子' %name) print('%s 吃面' %name) fork_lock.release() noodle_lock.release()def eat2(name): fork_lock.acquire() print('%s 拿到叉子' %name) time.sleep(1) noodle_lock.acquire() print('%s 拿到面条' %name) print('%s 吃面' %name) noodle_lock.release() fork_lock.release()Thread(target=eat1,args=('rubin',)).start()Thread(target=eat2,args=('leo',)).start()Thread(target=eat1,args=('lex',)).start()Thread(target=eat2,args=('fily',)).start()# rubin 拿到面条# rubin 拿到叉子# rubin 吃面# leo 拿到叉子# lex 拿到面条# ... 卡住了 123456789101112131415161718192021222324252627282930313233343536373839404142# 递归锁 解决死锁问题import timefrom threading import Lock,Threadfrom threading import RLockr_fork_lock = r_noodle_lock = RLock() # 一个钥匙串上的两把钥匙def eat1(name): r_noodle_lock.acquire() # 一旦拿到其中一把钥匙，说明要是都在手里 房子1 print('%s 拿到面条' %name) r_fork_lock.acquire() # 房子2 2层钥匙 print('%s 拿到叉子' %name) print('%s 吃面' %name) r_fork_lock.release() # 释放1层 r_noodle_lock.release() # 释放2层 还完所有钥匙def eat2(name): r_fork_lock.acquire() print('%s 拿到叉子' %name) time.sleep(1) r_noodle_lock.acquire() print('%s 拿到面条' %name) print('%s 吃面' %name) r_noodle_lock.release() r_fork_lock.release()Thread(target=eat1,args=('rubin',)).start()Thread(target=eat2,args=('leo',)).start()Thread(target=eat1,args=('lex',)).start()Thread(target=eat2,args=('fily',)).start()# Lock 互斥锁 1把钥匙# RLock 递归锁 同一个线程拿多少次钥匙都可以 , 不同的线程里 一旦有一个拿到了，别的线程都无法拿到# 递归解决死锁问题，同一个线程可以被 acquire 多次。# 当同一个线程 或者 同一个进程 遇到两把以上锁的时候，就容易出现死锁，需要使用递归锁。# 线程进场遇到全局数据，全局数据又是共享，所以经常要加锁。 信号量 Semaphore12345678910111213141516import timefrom threading import Semaphore,Thread# 信号量 就是控制n个线程 访问同一段代码def func(sem,a,b): sem.acquire() time.sleep(1) print(a + b) sem.release()# KTV例子 同一时间几个人能够进入sem = Semaphore(4) # 同一时间 只能有4个线程进入for i in range(10): t = Thread(target=func,args=(sem,i,i+5)) t.start() 事件 Event123456789101112131415161718192021222324252627282930313233343536373839404142# 事件被创建的时候# 当False状态，wait() 阻塞# 当True状态的 wait() 非阻塞# clear 设置状态为False# set 设置状态为True# 之前有红绿灯例子# 链接数据库和检测数据库的可链接情况# 起两个线程# 第一个线程 : 链接数据库 # 等待一个信号,告诉我们之间的网络是通的 # 链接数据库# 第二个线程 : 检测与数据库之间的网络是否连通 # 模拟检测 time.sleep(0,2) 如果2秒钟没通 就是没通 # 将事件的状态,设置为 Trueimport timeimport randomfrom threading import Event,Threaddef connect_db(e): count = 0 # 计数器，尝试三次链接 while count &lt; 3: e.wait(0.5) # 状态为False的时候 ，只等待n秒钟就结束 if e.is_set() == True: print('链接数据库') break else: count += 1 print('第%s次链接失败' %count) else: # while 循环 + else 三次都没有被break 也就是都没连接上 raise TimeoutError('数据库连接超时') # 超时错误def check_web(e): time.sleep(random.randint(0,3)) e.set() # wait = Truee = Event()t1 = Thread(target=connect_db,args=(e,))t2 = Thread(target=check_web,args=(e,))t1.start()t2.start() 定时器 Timer123456789import timefrom threading import Timerdef func(): print('时间同步')while True: t = Timer(2,func).start() # Timer(秒数,方法) 2秒钟之后开启线程 time.sleep(5) # 和上面的Timer是同步 Timer5秒后会执行func 队列 queue1234# Queue 先进先出 队列# LifoQueue 先进后出 栈# PriorityQueue 优先级队列# 他们都是数据安全 1234567# 队列import queue q = queue.Queue() # 队列的特点 先进先出q.put() # 满了会阻塞q.get() # 空了会阻塞q.put_nowait() # + 异常处理q.get_nowait() # 1234567# 栈import queue q = queue.LifoQueue() # 栈 先进后出 (先进来的在最底下,后进来的先出去)q.put(1)q.put(2)q.put(3)print(q.get()) # 3 12345678910# 优先级队列import queue q = queue.PriorityQueue() # 优先级队列 放数据的时候，给优先级q.put((20,'a'))q.put((10,'b'))q.put((30,'c'))q.put((1,'z'))q.put((1,'d'))print(q.get()) # (1, 'd') 顺序按照 数字从小到大，如果数字相同,按照数据的ASCII码排 线程池 concurrent.futures 模块12345# 1 介绍# concurrent.futures模块提供了高度封装的异步调用接口# ThreadPoolExecutor：线程池，提供异步调用# ProcessPoolExecutor: 进程池，提供异步调用# Both implement the same interface, which is defined by the abstract Executor class. 12345678910111213141516171819202122232425# 2 基本方法# submit(fn, *args, **kwargs)# 异步提交任务# map(func, *iterables, timeout=None, chunksize=1)# 取代for循环submit的操作# shutdown(wait=True)# 相当于进程池的pool.close() + pool.join() 操作# wait=True，等待池内所有任务执行完毕回收完资源后才继续# wait=False，立即返回，并不会等待池内的任务执行完毕# 但不管wait参数为何值，整个程序都会等到所有任务执行完毕# submit和map必须在shutdown之前# result(timeout=None)# 取得结果# add_done_callback(fn)# 回调函数# done()# 判断某一个线程是否完成# cancle()# 取消某个任务 12345678910111213141516171819# 线程池import timefrom concurrent.futures import ThreadPoolExecutor # 线程池,提供异步调用from concurrent.futures import ProcessPoolExecutor # 进程池,提供异步调用 apply_async()def func(n): time.sleep(2) print(n) return n*ntpool = ThreadPoolExecutor(max_workers=5) # 1一般情况下 线程卡其 max_workers = 默认不要超过 cpu个数 * 5t_lst = [] # 任务列表for i in range(10): t = tpool.submit(func,i) # 线程池提交任务 t_lst.append(t) # 存储结果对象,就像领了个号，等任务结束后去领取结果tpool.shutdown() # pool.close() 关闭池子不让人物再提交进来 + pool.join() 阻塞直到池子中的子线程任务执行完print('主线程')for t in t_lst:print('***',t.result()) # 为什么这个地方按顺序打印，因为 t_lst 是按照顺序产生的 123456789101112# 流程总结:# 1、创建线程池# 2、线程池异步提交任务# 3、阻塞到线程池任务都结束# 4、获取结果# 如果没有shutdown:# 1、会先打印 print('主线程')# 2、谁先执行好 就先接收到结果输出 (消耗好一些)# 5线程 * 每个任务2秒 = 5任务2秒 10任务4秒 如果join 需要4秒后统一拿结果# 不加join 2秒后执行完前5个任务拿到结果# 如果有返回值的话 ，超过池子的数量 用 shutdown 效率会慢 123456789101112131415161718192021### 进程池import timefrom concurrent.futures import ThreadPoolExecutor # 线程池,提供异步调用from concurrent.futures import ProcessPoolExecutor # 进程池,提供异步调用 apply_async()def func(n): time.sleep(2) print(n) return n*nif __name__ == '__main__': p_pool = ProcessPoolExecutor(max_workers=5) p_lst = [] # 任务列表 for i in range(10): t = p_pool.submit(func, i) p_lst.append(t) p_pool.shutdown() print('主进程') for p in p_lst: print('进程池 ***', p.result()) 1234567891011### mapimport timefrom concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutordef func(n): time.sleep(2) print(n) return n*nt_pool = ThreadPoolExecutor(max_workers=5)t_pool.map(func,range(20)) # 拿不到返回值啦 123456789101112131415161718# 回调函数 call_backimport timefrom concurrent.futures import ThreadPoolExecutor # 线程池,提供异步调用from concurrent.futures import ProcessPoolExecutor # 进程池,提供异步调用 apply_async()def func(n): time.sleep(2) print(n) return n*ndef call_back(m): # 接收到了个对象 print('结果是%s' %m.result())tpool = ThreadPoolExecutor(max_workers=5)t_lst = [] # 任务列表for i in range(10): t = tpool.submit(func,i).add_done_callback(call_back) # 线程池提交任务 带回调函数 t_lst.append(t)]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多进程 multiprocess模块]]></title>
    <url>%2F2019%2F04%2F19%2Fprocess-note%2F</url>
    <content type="text"><![CDATA[开启多进程使用Process模块123456# Process([group [, target [, name [, args [, kwargs]]]]])# target表示调用对象，你可以传入方法的名字# args表示被调用对象的位置参数元组，比如target是函数a，他有两个参数m，n，那么args就传入(m, n)即可# kwargs表示调用对象的字典# name是别名，相当于给这个进程取一个名字# group分组，实际上不使用 12345678910111213141516171819# 使用process模块from multiprocessing import Processimport multiprocessingimport osdef process(num): print('PID:%s Process:%s' %(os.getpid(),num))if __name__ == '__main__': for i in range(5): p = Process(target=process,args=(i,)) p.start() print('CPU number:%d' %multiprocessing.cpu_count()) # cpu个数 # CPU number:4# PID:97764 Process:1# PID:101312 Process:2# PID:100472 Process:0# PID:101172 Process:4# PID:99964 Process:3 继承Process类12345678910111213141516171819# 继承创建多进程from multiprocessing import Processclass MyProcess(Process): def __init__(self): super().__init__() def run(self): print('开始一个新进程 PID:%s' %self.pid)if __name__ == '__main__': for i in range(5): p = MyProcess() p.start()# 开始一个新进程 PID:100524# 开始一个新进程 PID:97824# 开始一个新进程 PID:87880# 开始一个新进程 PID:93100# 开始一个新进程 PID:94960 守护进程 deamon123456789101112131415161718192021222324# 如果设置为True，当父进程结束后，子进程会自动被终止。# 注意: 守护进程 会随着 主进程的代码执行完毕 而结束# 代码运行: 主进程 在延迟一秒后只打印一句话，全部的代码已经执行完成,也直接终止了子进程的运行# 作用: 有效防止无控制地生成子进程，关闭这个主程序运行时，就无需额外担心子进程有没有被关闭了。import timefrom multiprocessing import Processclass MyProcess(Process): def __init__(self): super().__init__() def run(self): time.sleep(2) print('开启一个新进程%s' %self.pid)if __name__ == '__main__': for i in range(5): p = MyProcess() p.daemon = True p.start() time.sleep(1) print('主进程结束') # time.sleep(3) # 如果再延迟3秒，子进程会执行，因为这个时候主进程的代码还没有执行结束 # 主进程结束 主进程等待子进程执行完成 join12345678910111213141516171819202122232425262728293031323334# 主进程等待子进程执行完成 join# 每个子进程都调用了join()方法，这样父进程（主进程）就会等待子进程执行完毕。import osimport timefrom multiprocessing import Processclass MyProcess(Process): def __init__(self,num): super().__init__() self.num = num def run(self): time.sleep(1) print('子进程%s 任务编号%s 开始执行' %(os.getpid(),self.num))if __name__ == '__main__': start_time = time.time() p_lst = [] for i in range(1,6): p = MyProcess(i) p_lst.append(p) p.daemon = True p.start() # p.join() # 如果在循环里面join,则每循环一个进程都要等待进程的结束,会变成同步 [p.join() for i in p_lst] # 之前的所有进程必须在这里都执行完，才能执行后面的代码 print('主进程执行结束') print('程序运行:',time.time()-start_time) # 子进程55888 任务编号3 开始执行# 子进程16812 任务编号4 开始执行# 子进程77500 任务编号1 开始执行# 子进程62216 任务编号5 开始执行# 子进程86548 任务编号2 开始执行# 主进程执行结束# 程序运行: 1.2200696468353271]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程]]></title>
    <url>%2F2019%2F04%2F04%2Fconcurrency%2F</url>
    <content type="text"><![CDATA[进程理论基础一、操作系统的作用: 隐藏丑陋复杂的硬件接口，提供良好的抽象接口 管理、调度进程，并且将多个进程对硬件的竞争变得有序 二、多道技术: 产生背景：针对单核，实现并发ps：现在的主机一般是多核，那么每个核都会利用多道技术有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个cpu中的任意一个，具体由操作系统调度算法决定。 空间上的复用：如内存中同时有多道程序 时间上的复用：复用一个cpu的时间片强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样才能保证下次切换回来时，能基于上次切走的位置继续运行 三、进程: 进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。 进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。 PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。 内存越大，多个程序占用的空间越大；CPU核数越多，同一时间处理的任务越多。 什么是进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。 进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。[3]进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。 进程的并行与并发 并行 : 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ） 并发 : 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。 区别:并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。 进程的三状态 在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。 （1）就绪(Ready)状态 当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。 （2）执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。 （3）阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。 同步与异步 同步: 串行处理一件事物 异步: 同时处理多件不同的事物 所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。 所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。 阻塞与非阻塞 阻塞: input 读写文件 产生IO操作 非阻塞: 不产生IO操作阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的 同步/异步与阻塞/非阻塞 同步阻塞形式 效率低 专心排队，什么别的事都不做 异步阻塞形式 领一张排队号码，不用排队等着叫号，但是等的过程中不能做其他事情。异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。 同步非阻塞形式 一边排队，一边打电话,来回切换两种不同的行为，效率低 异步非阻塞形式 效率高，等着柜台(消息触发机制)通知，去外面抽烟，做自己的事 很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞。 进程的创建与结束但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程： 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印） 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等） 用户的交互式请求，而创建一个新进程（如用户双击暴风影音） 一个批处理作业的初始化（只在大型机的批处理系统中应用）无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。 进程的结束: 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess） 出错退出（自愿，python a.py中a.py不存在） 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try…except…） 被其他进程杀死（非自愿，如kill -9） 在python程序中的进程操作创建进程共四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。 multiprocess.process模块process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。 Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动） 强调： 需要使用关键字的方式来指定参数 args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号 参数介绍：1 group参数未使用，值始终为None2 target表示调用对象，即子进程要执行的任务3 args表示调用对象的位置参数元组，args=(1,2,’egon’,)4 kwargs表示调用对象的字典,kwargs={‘name’:’egon’,’age’:18}5 name为子进程的名称 在windows中使用process模块的注意事项:必须把创建子进程的部分使用if __name__ ==‘__main__’判断保护起来 使用process模块创建进程123456# Process([group [, target [, name [, args [, kwargs]]]]])# target表示调用对象，你可以传入方法的名字# args表示被调用对象的位置参数元组，比如target是函数a，他有两个参数m，n，那么args就传入(m, n)即可# kwargs表示调用对象的字典# name是别名，相当于给这个进程取一个名字# group分组，实际上不使用 123456789101112import timefrom multiprocessing import Processdef f(name): print('hello', name) print('我是子进程')if __name__ == '__main__': p = Process(target=f, args=('leo',)) p.start() time.sleep(1) print('执行主进程的内容了') 查看进程的执行12345678910111213141516171819202122232425262728293031323334import timeimport osfrom multiprocessing import Processdef func(args,args2): print(args,args2) # print(54321) time.sleep(1) print('子进程:', os.getpid()) print('子进程的父进程:', os.getppid()) # 查看当前进程的父进程号 print(12345)if __name__ == '__main__': # 主进程(父进程)执行的 p = Process(target=func,args=('参数','参数2')) # 注册 args传参必须传元祖,里面放着参数 # p 是进程对象,此时还没有启动进程 p.start() # 开启子进程 print('*'*10) print('父进程:',os.getpid()) # 查看当前进程的进程号 print('父进程的父进程:', os.getppid()) # 查看当前进程的父进程号 在pycharm中启动就是pycharm 可以通过任务管理器查看到# 如果是同步的函数执行，会先执行完func函数在执行打印# 异步虽然要先启动子进程，但是不影响后面的代码# 进程的生命周期: # 主进程 : 从程序开启开始，直到程序执行完成 # 子进程 : 从start开始，到子进程中的代码执行完成 # 开启了子进程的主进程: # 主进程自己的代码如果长，等待自己的代码执行结束 # 子进程的执行时间长，主进程会在主进程代码执行完毕后,等待子进程执行完毕,主进程才结束# python chrom.py &amp; 终端没有关闭 进程都在后台运行# 父进程在 自己进程就在 不一定，要看怎么启动的# 子进程不一定要依赖父进程运行 123456789101112131415161718from multiprocessing import Processimport timeimport osdef func(args,args2): print('大家好,我是子进程') print(args,args2) time.sleep(3) print('子进程执行完成') print('子进程:',os.getpid()) print('子进程的父进程: ',os.getppid())if __name__ == '__main__': p = Process(target=func,args=(10,20)) # 注册 p.start() # 启动紫禁城 print('当前进程:',os.getpid()) print('当前进程的父进程: ',os.getppid()) print('*'*10) join方法 p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程12345678910111213141516171819# join()import timefrom multiprocessing import Processdef func(arg1,arg2): print('*'*arg1) time.sleep(5) print('*'*arg2)if __name__ == '__main__': p = Process(target=func, args=(10, 20)) p.start() print('这个时候还是异步的') p.join() # 作用：感知一个子进程的结束 ，异步的程序就变成同步了 print('主进程运行完成')# join 会将异步的程序变成同步 开启多个子进程,并写入文件通过join方法，让写文件的操作编程异步123456789101112131415161718192021222324252627282930313233343536373839404142434445# 多进程写文件# for 循环500个文件,没处理1个文件需要0.1秒，500个是50秒# 同步，只有一个进程处理: 0.1 * 500 = 50 # 异步，存在500个进程: 500 * 0.1 = 0.1# 1. 先往文件夹中写文件# 2. 展示写入后文件件的所有文件名# join 会将异步的程序变成同步import timeimport osfrom multiprocessing import Processdef func(filename,context): print('子进程%s开始' %(os.getpid())) with open(filename,'w') as f: f.write(str(context))# 单过在循环外只有1个join无法确定所有子进程都结束，所以需要控制if __name__ == '__main__': p_lst = [] for i in range(1,6): p = Process(target=func,args=('inod%s'%i,i)) p_lst.append(p) # 每创建出来一个进程都加入进程列表 p.start() # p.join() # 如果在循环里面join,则每循环一个进程都要等待进程的结束,会变成同步 # 如果不用join 开启进程无法保障运行的时间，所以后面的代码一起异步执行 [p.join() for p in p_lst] # 之前的所有进程必须在这里都执行完，才能执行后面的代码 # 列表推导式，先启动所有的进程，按顺序执行，在最后之前保障所有的进程对象执行完成 print('主进程%s执行完成' %(os.getpid())) print([i for i in os.walk(r'D:\PycharmProjects\Notes\08 并发编程')])# 场景:# 同时开启多个子进程，异步执行，当我需要同步执行的时候，设置一个阻拦的手段，让所有的进程在这话话都执行完成# 结果:# 子进程8332开始# 子进程4936开始# 子进程2728开始# 子进程9832开始# 子进程4428开始# 主进程9340执行完成# [('inod1', 'inod2', 'inod3', 'inod4', 'inod5'])] 开启多进程方法212345678910111213141516171819202122232425# 自定义类继承Process，实现多进程import osfrom multiprocessing import Processclass MyProcess(Process): # 自定义类继承Process def __init__(self,arg1,arg2): # 传参需要继承父类的__init__ super().__init__() # 继承父类的__init__ self.arg1 = arg1 self.arg2 = arg2 def run(self): # 实现run方法 print(self.pid) print(self.name) print(self.arg1) print(self.arg2) print('开始一个新进程%s' %os.getpid())if __name__ == '__main__': print('主进程:', os.getpid()) p1 = MyProcess(1,2) p1.start() # start 调用 run方法 p2 = MyProcess(3,4) p2.start() 123456789101112131415161718192021222324import osfrom multiprocessing import Processclass MyProcess(Process): # 自定义类继承Process def __init__(self,arg1,arg2): # 传参需要继承父类的__init__ super().__init__() # 继承父类的__init__ self.arg1 = arg1 self.arg2 = arg2 def run(self): # 实现run方法 print(self.pid) print(self.name) print(self.arg1) print(self.arg2) print('开始一个新进程%s' %os.getpid())if __name__ == '__main__': print('主进程:', os.getpid()) p1 = MyProcess(1,2) p1.start() # start 调用 run方法 p2 = MyProcess(3,4) p2.start() 多进程之间的数据隔离12345678910111213141516171819202122# 进程 与 进程之间数据是隔离的？ 是隔离的# 微信 与 QQ之间的数据能共享么？import osfrom multiprocessing import Processdef func(): global n # 全局变量n n = 0 # 重新定义n print('子进程 : %s' %os.getpid(),n)if __name__ == '__main__': print('主进程',os.getpid()) n = 100 p = Process(target=func) p.start() p.join() # 等待子进程 结束完 print('主进程',n) # 主进程打印的n 和 子进程不一样 ，多进程之间数据有隔离# 运行结果# 主进程pid: 5748# 子进程pid: 6048 0# 主进程 100 守护进程1234567891011121314151617181920212223242526272829# 特点: 会随着主进程的结束而结束。# 主进程创建守护进程 # 其一：守护进程会在主进程代码执行结束后就终止 # 其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children# 注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止import timefrom multiprocessing import Processdef func(): while True: time.sleep(0.2) print('我还活着') # 每隔0.5秒 说下进程状态if __name__ == '__main__': p = Process(target=func) p.daemon = True # 设置子进程为守护进程 p.start() i = 0 while i &lt; 5: print('我是socket server') time.sleep(1) i += 1# 守护进程 会随着 主进程的代码执行完毕 而结束 12345678910111213141516171819202122232425262728293031323334353637383940414243# 守护进程# 子进程 转换成 守护进程# 守护进程 子进程随着主进程 一起结束import timefrom multiprocessing import Processdef func(): while True: time.sleep(0.2) print('我还活着') # 每隔0.5秒 说下进程状态def func2(): print('in func2 开始') time.sleep(8) print('in func2 结束')if __name__ == '__main__': p = Process(target=func) p.daemon = True # 设置子进程为守护进程 p.start() p2 = Process(target=func2) # 另外一个子进程 p2.start() p2.terminate() # 结束一个进程 print(p2.is_alive()) # 检查进程是否还活着 time.sleep(2) print(p2.is_alive()) print(p2.name) # i = 0 # while i &lt; 5: # print('我是socket server') # time.sleep(1) # i += 1# 守护进程 会随着 主进程的代码执行完毕 而结束# 在主进程内结束进程 p2.terminate()# 结束一个进程不是在执行方法之后立即生效，需要一个操作系统响应的过程# 检验进程是否活着的状态 p2.is_alive()# p.name p.pid 进程名 和 进程号 多进程中的方法和属性1234567891011121314151617181920212223242526272829import randomimport timefrom multiprocessing import Processclass MyProcess(Process): def __init__(self,user): super().__init__() self.user = user def run(self): print('子进程 %s 的 pid %s' %(self.name,self.pid)) print('%s 开始执行子进程'%self.user) time.sleep(random.randrange(1,5)) print('%s 子进程完成' %(self.user))if __name__ == '__main__': p1 = MyProcess(user='leo') p1.start() p1.terminate() # 关闭进程,不会立即关闭,所以is_alive立刻查看的结果可能还是存活 print(p1.is_alive()) # True time.sleep(1) print(p1.is_alive()) # False # self.name 属性是Process中的属性，标示进程的名字 # super().__init__() # 执行父类的初始化方法会覆盖name属性 # self.pid 查看id # p1.terminate() 关闭进程 # p1.is_alive() 查看进程是否存活 socket聊天并发实例123456789101112131415161718192021222324# serverimport socketfrom multiprocessing import Processdef server(conn): # ret = input('&gt;&gt;&gt;').encode('utf-8') ret = '你好'.encode('utf-8') conn.send(ret) msg = conn.recv(1024).decode('utf-8') print(msg) conn.close()if __name__ == '__main__': sk = socket.socket() sk.bind(('127.0.0.1',8090)) sk.listen() while True: conn,addr = sk.accept() # 拿到链接 放到多进程 每个链接都执行 p = Process(target=server,args=(conn,)) p.start() sk.close() 1234567891011# clientimport socketsk = socket.socket()sk.connect(('127.0.0.1',8090))msg = sk.recv(1024).decode('utf-8')print(msg)msg2 = input('&gt;&gt;&gt;').encode('utf-8')sk.send(msg2)sk.close() 进程同步 —— 锁、信号量和事件重要程度:Lock(加锁，同一时间1个进程执行) 锁 —— multiprocess.Lock加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。虽然可以用文件共享数据实现进程间通信，但问题是：1.效率低（共享数据基于文件，而文件是硬盘上的数据）2.需要自己加锁处理12345678910111213141516171819202122232425262728293031323334353637383940414243from multiprocessing import Processfrom multiprocessing import Lock # 进程锁import jsonimport osimport timedef show(i): # 查票读取ticket文件 with open('ticket',mode='r') as f: dic = json.load(f) print('子进程%s,余票:%s'%(os.getpid(),dic['ticket']))def buy_ticket(i,lock): lock.acquire() # 拿钥匙进门 被拿走后 别的进程会在这里阻塞，直到钥匙被还 with open('ticket') as f: dic = json.load(f) time.sleep(0.1) if dic['ticket'] &gt; 0: dic['ticket'] -= 1 print('\033[32m%s 买到票了\033[0m' %i) else: print('\033[31m%s 没买到票\033[0m' %i) time.sleep(0.1) with open('ticket',mode='w') as f: # 修改票结果 json.dump(dic,f) lock.release() # 还钥匙，已经买完票了if __name__ == '__main__': for i in range(10): # 假装有10个人抢票 p = Process(target=show,args=(i,)) p.start() lock = Lock() for i in range(10): p = Process(target=buy_ticket,args=(i,lock)) p.start()# 给某一段代码加上锁 这段代码在这一段时间内只能让一个进程执行# 只要多人同时操作一个数据 就会出现数据安全问题，需要牺牲效率 保证数据安全# &#123;"ticket": 1&#125; 信号量 —— multiprocess.Semaphore1234567891011121314151617181920212223242526272829303132333435363738394041424344# 多进程中的组件 # 同步控制 # 进程间通信 # 进程间的数据共享 # 进程池# ktv 有4个门 20个人同时进出,现在要控制4个人先进# 一套资源 同一时间 只能被N个人访问# 某一段代码 在同一时间 只能被n个进程执行import timeimport randomfrom multiprocessing import Processfrom multiprocessing import Semaphoredef ktv(i,sem): sem.acquire() # 获取钥匙 print('%i 走进KTV' %i) time.sleep(random.randint(10,20)) # 模拟唱歌 1-5秒 print('%i 走出KTV' %i) sem.release() # 还钥匙if __name__ == '__main__': sem = Semaphore(4) # 实例化4把钥匙 for i in range(20): p = Process(target=ktv,args=(i,sem)) p.start()# 限定进程访问的代码 同一时间只能有几个进程来访问# 开一个们 有4把要是 前4个进程进去后 门就观赏了 直到某一个进程出来还钥匙，第5个进程获取进入# lock只有一把钥匙# 信号量有N把钥匙# 结果:# 3 走进KTV# 0 走进KTV# 8 走进KTV# 7 走进KTV# ...同一时间只有4个人# 8 走出KTV# 4 走进KTV# 3 走出KTV# 12 走进KTV 事件 —— multiprocess.Event1234567891011121314151617181920212223242526# 通过一个信号 来控制 多个进程 同时执行或者阻塞# 事件from multiprocessing import Event# 一个信号 可以使所有的进程都进入阻塞状态# 也可以控制 所有的进程 解除阻塞# 一个事件 被创建之后，默认是阻塞状态e = Event() # 创建了一个事件print(e.is_set() ) # 查看一个事件的状态 # Falsee.set() # 将这个时间的状态改为Trueprint(e.is_set() ) # Truee.wait() # 是依据e.is_set()的值，来决定是否阻塞,如果是False就阻塞,True就是不阻塞print(123456) # 正常打印e.clear() # 将事件状态改成falseprint(e.is_set()) # Falsee.wait() # 阻塞print('123456') # 不打印# set 和 clear # 分别用来修改一个事件的状态：True / False# is_set # 用来查看一个事件的状态# wait # 依据事件的状态来决定自己是否阻塞 True:不阻塞，False:阻塞 1234567891011121314151617181920212223242526272829303132# 红绿灯事件# 两个进程，车怎么才能感知到灯？import timeimport randomfrom multiprocessing import Eventfrom multiprocessing import Processdef car(e,i): if not e.is_set(): print('car%s 等红灯'%i) e.wait() # 阻塞,直到得到一个事件状态改变，编程True的信号 print('\033[0;32;40mcar%s 通过\033[0m' %i)def light(e): while True: if e.is_set(): # Ture e.clear() # False print('\033[31m红灯亮了\033[0m') else: e.set() # True print('\033[32m绿灯亮了\033[0m') time.sleep(2)if __name__ == '__main__': e = Event() p = Process(target=light,args=(e,)) p.start() for i in range(20): cars = Process(target=car,args=(e,i)) cars.start() time.sleep(random.random()) # 0 - 1秒 进程间的通信 —— 队列和管道进程间通信:IPC(Inter-Process Communication) 队列 multiprocessing.Queue1234567891011121314151617181920212223242526# 队列 先进先出import timefrom multiprocessing import Queueq = Queue(5)# for i in range(6): # 0 - 5 超过队列大小了 会阻塞# q.put(i)q.put(1)q.put(2)q.put(3)q.put(4)q.put(5)print(q.full()) # True 队列是否满了print(q.get()) # 1print(q.get()) # 2print(q.get()) # 3print(q.get()) # 4print(q.get()) # 5print(q.empty()) # True 队列是否空while True: try: q.get_nowait() except: print('队列已空') time.sleep(1)# 放到满 和 空了再取值 都会阻塞 生产者与消费者模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 队列# 生产者与消费者模型:# 买包子# 蒸包子 # 买包子# 生产数据 # 消费数据# 爬虫 爬500个网页 生产数据快 ——&gt; 放到内存里 # 处理爬虫 处理数据 慢# 1、容器满了就不允许再放# 2、增加处理进程# 3、如果爬取数据慢，比如网络延迟或者需要验证破解,那么增加生产者,解决数据供需不平衡# 生产者 进程# 消费者 进程import timeimport randomimport osfrom multiprocessing import Queuefrom multiprocessing import Process# 消费者def consumer(q,name): # 数据一直处理 while True: food = q.get() if food is None: # 当获取到空了说明生产者完成了所有生产 print('%s 获取到空了' %name) break print('\033[31m%s消费了%s\033[0m' % (name,food)) time.sleep(random.randint(1,3))# 生产者def producer(name,food,q): for i in range(5): time.sleep(random.randint(1,3)) f = '%s生产了%s%s' %(name,food,i) print(f,os.getpid()) q.put(f) # 放到队列中if __name__ == '__main__': q = Queue(20) pro1 = Process(target=producer,args=('小红','包子',q)) pro2 = Process(target=producer,args=('小兰','汽水',q)) c1 = Process(target=consumer,args=(q,'小黑')) c2 = Process(target=consumer,args=(q,'小金')) pro1.start() pro2.start() c1.start() c2.start() pro1.join() pro2.join() q.put(None) # 等生产者都生产完毕后 放入一个空值 q.put(None) # 等生产者都生产完毕后 放入一个空值# Queue 是进程安全的，在队列里的数据只能被一个进程取走# 三个不同的进程 有可能在同一个时间去队列取值，这样是不安全的# None被其中一个进程取走，另外一个并没有拿到，所以会阻塞 JoinableQueue队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import timeimport osimport randomfrom multiprocessing import Processfrom multiprocessing import JoinableQueue# 消费者def consumer(q,name): # 数据一直处理 while True: food = q.get() if food is None: # 当获取到空了说明生产者完成了所有生产 print('%s 获取到空了' %name) break print('\033[31m%s消费了%s\033[0m' % (name,food)) time.sleep(random.randint(1,3)) q.task_done() # count - 1 ,直到队列中的所有数据都执行了task_done# 生产者def producer(name,food,q): for i in range(5): time.sleep(random.randint(1,3)) f = '%s生产了%s%s' %(name,food,i) print(f,os.getpid()) q.put(f) # 放到队列中 count + 1 1.,20 q.join() # 阻塞，直到一听歌队列中的所有数据 全部被处理完毕,这个进程才结束if __name__ == '__main__': q = JoinableQueue(20) pro1 = Process(target=producer,args=('小红','包子',q)) pro2 = Process(target=producer,args=('小兰','汽水',q)) c1 = Process(target=consumer,args=(q,'小黑')) c2 = Process(target=consumer,args=(q,'小金')) pro1.start() pro2.start() c1.daemon = True # 主进程中的代码执行完毕后 该守护进程结束 进程结束了 q.get()也不会阻塞了。 c2.daemon = True c1.start() c2.start() pro1.join() # 感知一个进程的结束 pro2.join() # 生产进程 q.join()结束，需要等待消费者都处理完才能结束# JoinableQueue 比 Queue多了两个方法# 1、获取数据要提交回执 q.task_done() q.join()# c1.daemon = True 守护进程 主进程中的代码执行完毕后 该守护进程结束# 在消费者这一端: # 每次获取一个数据 # 处理一个数据 # 发送一个记号：标志一个数据被处理成功# 在生产者这一端: # 每一次生产一个数据 # 且每一次生产的数据都放在队列里 # 在队列中刻上一个记号 # 当生产者全部生产完毕之后 # join信号:已经停止生产数据,且要等待之前被刻上的记号都被消费完 # 当数据都被处理完事，join阻塞结束# consumer 把所有的任务消耗完# producer 端的join感知到，停止阻塞# 所有的producer 进程结束# 主进程中的p.join结束# 主进程的代码结束# 守护进程(c1,c2消费者进程)结束 管道 multiprocessing.Pipe作用：在进程之间通信 123456789from multiprocessing import Pipe,Processdef func(conn): conn.send('吃了么')if __name__ == '__main__': conn1,conn2 = Pipe() p = Process(target=func,args=(conn1,)) p.start() print(conn2.recv()) 123456789101112131415# 发送多条消息from multiprocessing import Pipe,Processdef func(conn): while True: msg = conn.recv() if msg is None: break print(msg)if __name__ == '__main__': conn1,conn2 = Pipe() p = Process(target=func,args=(conn1,)) p.start() for i in range(20): conn2.send('吃了么%s' %i) conn2.send(None) 1234567891011121314151617181920# 作为两端通信# conn2发送,conn1接收def func(conn1,conn2): conn2.close() while True: try: msg = conn1.recv() print(msg) except EOFError: # 没有数据仍然recv的时候报错 conn1.close() breakif __name__ == '__main__': conn1,conn2 = Pipe() p = Process(target=func,args=(conn1,conn2)) p.start() conn1.close() for i in range(20): conn2.send('吃了么%s' %i) conn2.close() # 主进程两边都关闭 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import timeimport randomfrom multiprocessing import Pipefrom multiprocessing import Processfrom multiprocessing import Lockdef producer(con,pro,name,food): con.close() # 用不到消费者管道 for i in range(6): time.sleep(random.randint(1,3)) f = '%s生产%s %s' %(name,food,i) print(f) pro.send(f) # 生产放入管道 pro.close() # 生产完成后关闭管道def consumer(con,pro,name,lock): pro.close() while True: try: lock.acquire() food = con.recv() # 从管道拿产品 lock.release() print('%s 购买了 %s' %(name,food)) time.sleep(random.randint(1,3)) except EOFError: con.close() breakif __name__ == '__main__': con,pro = Pipe() # 生产者和消费者的管道 lock = Lock() # 加锁 p = Process(target=producer,args=(con,pro,'rubin','汽水')) p.start() c1 = Process(target=consumer,args=(con,pro,'leo',lock)) c1.start() c2 = Process(target=consumer,args=(con,pro,'lex',lock)) c2.start() con.close() pro.close()# pipe 数据不安全性# 生产者 消费者1 1个放1个取# 生产者 消费者1、2 1个放2个取 其他消费也来抢占数据,数据在管道中是混乱的,没被拿走之前，消费者都可以来申请# 多个消费者同时取一个数据，数据不安全# 管道是进程数据不安全的，解决方式：加锁# 队列是进程之间数据安全的，因为队里基于管道+锁 实现的,所以之后会更多使用队列 进程之间的数据共享 multiprocessing.Manager 基于消息传递的并发编程是大势所趋 即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合，通过消息队列交换数据。 这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中。 但进程间应该尽量避免通信，即便需要通信，也应该选择进程安全的工具来避免加锁带来的问题。 以后我们会尝试使用数据库来解决现在进程之间的数据共享问题。 进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的 虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此 12345678910111213141516# 进程之间的数据共享from multiprocessing import Manager,Process,Lockdef func(dic): dic['count'] -= 1 print(dic)if __name__ == '__main__': m = Manager() print(m) # &lt;multiprocessing.managers.SyncManager object at 0x0000000001D7A3C8&gt; dic = m.dict(&#123;'count':100&#125;) # dic会变成数据共享的字典 p_lst = [] p = Process(target=func, args=(dic,)) p.start() p.join() print('主进程:',dic) 1234567891011121314151617181920212223242526def func(dic,lock): lock.acquire() dic['count'] -= 1 lock.release() # print(dic)if __name__ == '__main__': m = Manager() lock = Lock() # 不加锁而操作共享的数据,肯定会出现数据错乱 # print(m) # &lt;multiprocessing.managers.SyncManager object at 0x0000000001D7A3C8&gt; dic = m.dict(&#123;'count':100&#125;) # dic会变成数据共享的字典 p_lst = [] for i in range(50): p = Process(target=func, args=(dic,lock)) p.start() p_lst.append(p) [ i.join() for i in p_lst ] # 等待所以子进程都结束 print('主进程:',dic)# 总结# 进程同步控制：锁、信号量、事件 -- 控制进程怎么执行，能不能一起执行，几个一起执行，什么时候一起执行 -- 控制# 进程间通信：队列和管道 -- 通信# 进程间数据共享: Manager -- 共享# 以后真正会用到的只有，进程控制，通信方面只用队列,# 未来使用 -- kafak,rabbitmq memcache (消息中间件) kafak(大数据消息中间件,会保留数据)# 进程服务器(多台) --&gt; 服务器(memcache) 进程池 Poolmultiprocessing.Pool为什么要有进程池?进程池的概念。 创建进程需要消耗时间，销毁进程也需要消耗时间。不能无限制的根据任务开启或者结束进程。 进程池的概念:定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。 Pool([numprocess [,initializer [, initargs]]]):创建进程池1234# 参数介绍:# 1 numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值# 2 initializer：是每个工作进程启动时要执行的可调用对象，默认为None# 3 initargs：是要传给initializer的参数组 map()方法 进程池和进程效率测试1234567891011121314151617181920212223242526272829# 为什么会有进程池的概念 # 提高效率 # 1、每次开启进程，都需要创建一个新的属于这个进程的内存空间，耗时 # 寄存器 堆栈 都是存储代码和变量的 # 2、进程过多，造成操作系统调度，切换过程较多 # 进程不能无限制的开放，而是需要进程池# 进程池 # python:在还没有启动程序之前，先创建一个属于进程的池子 # 这个池子指定能存放多少个进程 # 先将这些进程创建好 # 有50个任务，池子里有5个进程，任务需要排队，按顺序先执行5个任务，结束后不消失回到进程池里接收新的任务，后面依次执行 # 现象：同一时间操作系统中，只执行了这5个进程，减少了进程开销，使5个进程的内存空间循环被利用 # 信号量，同一时间N个进程执行 ,有点像进程池,区别是信号量多个进程排队，在等着执行一段代码，实际上信号量有N个进程被创建了。 # 一个是进程排队，一个是任务排队。 # 进程池既减少了操作系统的调度,且减少了进程开销。# 高级进程池(弹性伸缩) # python中没有 # n,m 上限和下限 # 3 三个进程 # 用户量增多,+1进程，一直加到上线m 20个,最多到20个 # 当任务不断减少的时候，再减到3个进程 # 好处：有效的介绍操作系统负担，减少进程# 开启进程的个数 # CPU核数 + 1 = 进程开启个数 1234567891011121314151617181920212223242526272829303132333435# 使用进程池import timefrom multiprocessing import Pool,Process# Process 超过5个进程,需要使用进程池def func(n): for i in range(10): print(n + 1)def func2(n): print(n) # ('leo', 1) # rubinif __name__ == '__main__': start = time.time() pool = Pool(5) # 5个进程 # pool.map(func,range(100)) # 100个任务 （方法名,可迭代类型）map方法自带join() pool.map(func2,[('leo',1),'rubin']) # 第二个任务 t1 = time.time() - start # 启100个进程 start = time.time() p_lst = [] for i in range(100): p = Process(target=func,args=(i,)) p_lst.append(p) p.start() for i in p_lst:i.join() t2 = time.time() - start print(t1,t2) # 0.21701264381408691 3.6672096252441406 开启100个进程 并没有5个进程交替执行的快# 进程池提高了执行效率 进程池中的同步和异步调用1234567891011121314151617181920212223242526272829# 进程池的同步调用import timeimport randomimport osfrom multiprocessing import Pooldef func(n): print('start func %s' %n,os.getpid()) time.sleep(1) print('end func %s' %n,os.getpid())if __name__ == '__main__': pool = Pool(5) for i in range(10): # pool.apply(func,args=(i,)) # apply同步提交任务 (方法,参数) pool.apply_async(func,args=(i,)) # apply_async 异步提交任务 async在python就代表着异步 # 真异步，主进程执行完了，不等待子进程 pool.close() # 结束进程池接收任务 pool.join() # 感知进程池中的任务执行结束# start func 0 8572# start func 1 6000# start func 2 1208# start func 3 10492# start func 4 9232 # end func 0 8572# start func 5 8572# ... 123456789101112131415161718192021222324252627282930313233# 使用进程池创建socket_server# serverimport socketfrom multiprocessing import Pooldef func(conn): conn.send(b'hello') print(conn.recv(1024).decode('utf-8')) conn.close()if __name__ == '__main__': pool = Pool(5) sk = socket.socket() sk.bind(('127.0.0.1',8080)) sk.listen() while True: conn,addr = sk.accept() pool.apply_async(func,args=(conn,)) sk.close()# clientimport socketsk = socket.socket()sk.connect(('127.0.0.1',8080))ret =sk.recv(1024).decode('utf-8')print(ret)msg = input('&gt;&gt;&gt;').encode('utf-8')sk.send(msg)sk.close() 进程池的返回值12345678import requestsimport timefrom multiprocessing import Pool# p = Pool()# p.map(funcname,iterable) 默认异步的执行任务,且自带close和join# p.apply 同步调用# p.apply_async 异步调用 和 主进程 完全异步,主进程结束不会等待子进程,需要手动close和join 12345678910111213141516171819# 进程池的返回值# 进程池特有的# 使用队列实现def func(i): time.sleep(0.5) return i*iif __name__ == '__main__': p = Pool(5) res_l = [] for i in range(10): # res = p.apply(func,args=(i,)) # apply的结果就是func的返回值 # print(res) res = p.apply_async(func,args=(i,)) # 异步提交 # print(res.get()) # res进程的对象 get会阻塞等待结果,等着func的结算结果 res_l.append(res) for res in res_l:print(res.get()) # 一次获取5个结果 123456789101112131415# mapdef func(i): time.sleep(0.5) return i*iif __name__ == '__main__': p = Pool(5) ret = p.map(func,range(10)) # map自带join和close print(ret) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 任务都运行完毕后 返回一个列表# map 和 apply，apply_async的区别:# apply_async : 5个5个打印# apply : 一次返回# map : 任务计算完,返回一个列表# 任务很多 使用 apply_async更好 不用等都执行完，拿到结果更快 回调函数 callback123456789101112131415161718192021222324252627import osfrom multiprocessing import Pooldef func1(n): print('in func1',os.getpid()) return n*ndef func2(nn): print('in func2',os.getpid()) print(nn)if __name__ == '__main__': p = Pool(5) print('主进程pid: ',os.getpid()) for i in range(10): p.apply_async(func1,args=(10,),callback=func2) p.close() p.join()# in func1# in func2# 100# 1、执行func1 他的返回值 作为回调函数的参数# 2、执行回调函数 func2# 3、回调函数不传参数,他的参数只能是func1的返回值# 4、回调函数在主进程中执行 回调函数 – 爬虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import requestsfrom multiprocessing import Pool# response = requests.get('https://maoyan.com/board/4')# print(response) # 网页结果对象# # print(response.__dict__)# print(response.status_code) # 200# print(response.text)# 爬虫# 耗时最长 网络延迟# 1、访问网址# 2、将数据从网址上下载下来 urllib * 耗时最长 发送请求，拿到代码，接收代码# 3、数据就是bytes 转成 字符串# 4、处理字符串# 5个进程,任务是200个（访问200个）# 同时跑5个进程,一起享受网络延迟,如果在这个时候处理字符串，那么195个进程都在排队# 如果处理交给主进程来做，这5个进程的处理字符串,那么可以省出5个进程继续下载网页# - 下载网页1# - 下载网页2# - 下载网页3# - 下载网页4# - 下载网页5# ----- 处理字符串# 一般情况下,爬虫的时候，容易用到回调函数# 访问网页，爬取网页的过程用爬虫# 处理数据，使用回调函数# 流程:# 多进程去访问页面，拿到结果,返回url和页面内容# 回调函数打印url和网页内容长度# 使用进程池下载页面# 子进程处理下载页面def get_page(url): res = requests.get(url) if res.status_code == 200 : return url,res.text# 回调函数，接收网页内容# 打印页面内容长度def call_back(args): url,content = args print(url,len(content))if __name__ == '__main__': url_lst = [ 'https://www.baidu.com', 'https://www.sogou.com', 'http://www.sohu.com/', 'https://maoyan.com/board/4', ] p = Pool(5) for url in url_lst: p.apply_async(get_page,args=(url,),callback=call_back) p.close() p.join()# https://www.sogou.com 23447# https://www.baidu.com 2443# http://www.sohu.com/ 180835# https://maoyan.com/board/4 20754]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix自定义脚本监控redis]]></title>
    <url>%2F2019%2F04%2F02%2Fpro2%2F</url>
    <content type="text"><![CDATA[编写监控redis qps 脚本结合zabbix展示之前公司的redis info显示执行了6亿次命令，造成cpu过高问题，现写下shell采集redis执行命令次数和ops然后通过zabbix做监控 监控脚本123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bashREDISCLI="/usr/local/bin/redis-cli"HOST="127.0.0.1"PORT=7007PASS="redis_pwd"if [[ $# == 1 ]];then case $1 in version) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info server | grep -w "redis_version" | awk -F':' '&#123;print $2&#125;'` echo $result ;; connected_clients) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info clients | grep -w "connected_clients" | awk -F':' '&#123;print $2&#125;'` echo $result ;; instantaneous_ops_per_sec) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info Stats | grep -w "instantaneous_ops_per_sec" | awk -F':' '&#123;print $2&#125;'` echo $result ;; total_commands_processed) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info Stats | grep -w "total_commands_processed" | awk -F':' '&#123;print $2&#125;'` echo $result ;; *) echo -e "\033[33mUsage: $0 &#123;version&#125;\033[0m" ;; esacelif [[ $# == 2 ]];then case $2 in keys) result=`$REDISCLI -h $HOST -a $PASS -p $PORT info | grep -w "$1" | grep -w "keys" | awk -F'=|,' '&#123;print $2&#125;'` echo $result ;; *) echo -e "33[33mUsage: $0 &#123;db0 keys|db0 expires|db0 avg_ttl&#125;33[0m" ;; esacfi 在本地做测试1234[work@scripts]$ sh /data/backup/zabbix/scripts/redis_status_7007.sh total_commands_processed11958[work@scripts]$ sh /data/backup/zabbix/scripts/redis_status_7007.sh instantaneous_ops_per_sec0 修改zabbix_agent配置文件1234567vim /etc/zabbix/zabbix_agentd.confInclude=/etc/zabbix/zabbix_agentd.d/ # 简易脚本的执行目录...# 自定义脚本执行UserParameter=Redis_7007.Info[*],/data/backup/zabbix/scripts/redis_status_7007.sh $1 $2UserParameter=Redis_7010.Info[*],/data/backup/zabbix/scripts/redis_status_7010.sh $1 $2 重启zabbix agent服务1sudo /etc/init.d/zabbix-agent restart 在zabbix server端通过get测试12[work@scripts]$ zabbix_get -s 内网监控IP -p 10050 -k "Redis_7007.Info[total_commands_processed]"12051 12[work@scripts]$ zabbix_get -s 内网监控IP -p 10050 -k "Redis_7007.Info[instantaneous_ops_per_sec]"0 在zabbix平台配置监控项和触发器]]></content>
      <categories>
        <category>Linux运维</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看java进程占用cpu过高]]></title>
    <url>%2F2019%2F04%2F01%2Fpro1%2F</url>
    <content type="text"><![CDATA[查看java进程占用cpu过高之前平台出现过一次java进程占用cpu 100%的问题，发现后排查的几率如下: 使用top查找哪个继承占用cpu过高 记录下进程如:14492 把进程的栈dump到文件里，以便后面的分析 1jstack 14492 &gt; cpu0401.log 看看这个进程里面哪些线程在占用cpu 1top -p 14492 -H # 选择占用最高的 PID=5159 接着要看刚才dump出来的cpu日志了，里面会有14492这个进程下面每个线程的栈信息，但是是十六进制显示的，所以先把5159转换成16进制 1printf %0x 5159 # 1427 在cpu日志里找PID=1427的线程 1vim cpu0401.log]]></content>
      <categories>
        <category>Linux运维</category>
      </categories>
      <tags>
        <tag>进程占用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket 网络编程]]></title>
    <url>%2F2019%2F03%2F26%2Fsocket-server%2F</url>
    <content type="text"><![CDATA[tcp协议 和 udp协议TCP（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；电子邮件、文件传输程序。 UDP（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。 socket的基本使用TCP 的socket — 基础对话版12345678910111213141516171819# server端import socketsk = socket.socket() # 创建套接字sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) # 避免重用ip和端口sk.bind(('127.0.0.1',8090)) # 绑定端口sk.listen() # 监听链接conn,addr = sk.accept() # 接收客户端链接ret = conn.recv(1024) # 接收客户端消息print(ret) # 打印客户端消息conn.send(b'hello') # 向客户端发送消息 在网络上传输的只有二进制1010,所以必须是bytes类型ret = conn.recv(1024).decode('utf-8')print(ret)conn.send('吃面条吧'.encode('utf-8'))conn.close() # 关闭客户端链接sk.close() # 关闭服务端 123456789101112131415# client端import socketsk = socket.socket() # 创建客户端套接字sk.connect(('127.0.0.1',8090)) # 链接服务端# 接收|发送消息sk.send(b'hey') # 发送消息ret = sk.recv(1024) # 接收消息print(ret)sk.send('中午吃什么'.encode('utf-8'))ret = sk.recv(1024).decode('utf-8')print(ret)sk.close() 循环对话版12345678910111213141516171819202122232425262728# server端import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端开始监听...')conn,addr = sk.accept() # 获取到一个客户端的链接，已经完成了三次握手建立了一个连接 # 阻塞print('有新的链接进入&#123;&#125;'.format(addr))# 对话while 1: ret = conn.recv(1024).decode('utf-8') # 阻塞，直到收到客户端发来的消息 print(ret) if ret == 'bye': conn.send('bye'.encode('utf-8')) break msg = input('server:&gt;&gt;&gt;') if msg == 'bye': conn.send('bye'.encode('utf-8')) break conn.send(msg.encode('utf-8'))conn.close()sk.close() 1234567891011121314151617# client端import socketsk = socket.socket()sk.connect(('127.0.0.1',8090))while True: msg = input('client:&gt;&gt;&gt;') if msg == 'bye': sk.send('bye'.encode('utf-8')) break sk.send(msg.encode('utf-8')) ret = sk.recv(1024).decode('utf-8') if ret == 'bye': break print(ret)sk.close() 时间戳转换1234567891011121314151617181920212223242526272829303132ip_port = ('127.0.0.1',8090)# server端# server 接收时间戳时间，转化成格式化时间# client 每10秒time.time() 吧时间戳时间发给serverimport sysimport ossys.path.insert(0,os.path.dirname(os.getcwd()))import socketimport timefrom conf import settingssk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(settings.ip_port)sk.listen()print('服务端开始监听...')conn,addr = sk.accept()print('有新的链接进入&#123;&#125;'.format(addr))# 收发消息while 1: res = conn.recv(1024).decode('utf-8') if res == '': break print('client:%s' %res) msg = time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(float(res))) print(type(msg),msg) conn.send(('server:%s' %msg).encode('utf-8'))conn.close()sk.close() 12345678910111213141516171819202122# client端import timeimport socket# msg = time.time()# print(type(msg),msg) # float类型sk = socket.socket()sk.connect(('127.0.0.1',8090))count = 1while 1: if count &gt; 3: break now_time = str(time.time()) print(now_time) sk.send(now_time.encode('utf-8')) ret = sk.recv(1024).decode('utf-8') print(ret) time.sleep(3) count += 1sk.close() UDP 的socket — 基础对话版1234567891011# server import socketsk = socket.socket(type=socket.SOCK_DGRAM) # 创建一个服务器的套接字sk.bind(('127.0.0.1',8090)) # 绑定服务器套接字# 对话(接收与发送)msg,addr = sk.recvfrom(1024)print(msg.decode('utf-8'))sk.sendto(b'bye',addr) # 发送消息要带着地址sk.close() # 关闭服务器套接字 1234567891011# clientimport socketip_port = ('127.0.0.1',8090)sk = socket.socket(type=socket.SOCK_DGRAM)# 对话(接收与发送)sk.sendto(b'hello',ip_port) # 发送消息要带着地址ret,addr = sk.recvfrom(1024)print(ret.decode('utf-8'))sk.close() 在udp的消息通信的时候: 不需要进行监听 (listen) 不需要建立链接 (accept) 在启动服务之后，只能被动的等到客户端发送消息过来 客户端发送消息的同时，还会带着地址信息过来 服务端进行消息服务的时候，不仅需要发送消息，还需要带着对方的地址回去 UDP 实现简易QQ1234567891011121314151617# server import socketudp_sk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)udp_sk.bind(ip_port)print('Bind UDP on 9999...')while True: # 接收数据: data,addr = udp_sk.recvfrom(1024) data = data.decode('utf-8') print(('Received from %s:%s') %(addr,data)) msg = input('server:&gt;&gt;&gt;') udp_sk.sendto(msg.encode('utf-8'),addr)udp_sk.close() 123456789101112131415# client import socketip_port = ('127.0.0.1',9999)udp_sk = socket.socket(type=socket.SOCK_DGRAM)while True: msg = input('client:&gt;&gt;&gt;') msg = '\033[32mform client1:%s\033[0m' %msg udp_sk.sendto(msg.encode('utf-8'),ip_port) data,addr = udp_sk.recvfrom(1024) data = data.decode('utf-8') print(('Received from %s:%s') %(addr,data))udp_sk.close() UDP 实现简易时间同步123456789101112131415161718192021222324# server # server端提供时间同步服务# 接收信息 时间的格式# 将server端时间 转换成 接收到的格式# 返回给clientimport socketimport timesk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)sk.bind(ip_port)print('Bind UDP on 9999...')while True: data,addr = sk.recvfrom(1024) data = data.decode('utf-8') # print(type(data),data) print('form %s:%s' %(addr,data)) # time_str = time.strftime(data,time.localtime(time.time())) time_str = time.strftime(data) print(type(time_str),time_str) sk.sendto(str(time_str).encode('utf-8'),addr)sk.close() 1234567891011121314151617# client import socketsk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)time_format = '%Y-%m-%d %H:%M:%S'sk.sendto(time_format.encode('utf-8'),ip_port)data,addr = sk.recvfrom(1024)data = data.decode('utf-8')print(data)sk.close()# 操作方式:# 1、操作系统定时任务 + python代码# 2、while True + time.sleep 黏包现象subprocess 远程执行命令12345678import subprocessres = subprocess.Popen('dir',shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)print('stdout:' + res.stdout.read().decode('gbk')) # windows默认控制台输出 gbkprint('stderr:' + res.stderr.read().decode('gbk')) # windows默认控制台输出 gbk# stdout=subprocess.PIPE 标准输出放入管道# stderr=subprocess.PIPE 错误输出放入管道# 结果的编码是以当前所在的系统为准的，如果是windows，那么res.stdout.read()读出的就是GBK编码的，在接收端需要用GBK解码 TCP的黏包现象12345678910111213141516171819202122232425# 在server端下发命令import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务器端口8090开始监听')conn,addr = sk.accept()print('有新的链接请求&#123;&#125;'.format(addr))while 1: cmd = input('cmd:&gt;&gt;&gt;') conn.send(cmd.encode('utf-8')) ret = conn.recv(1024).decode('utf-8') # windows控制台是GBK print(ret)conn.close()sk.close()# 执行的命令# 1. dir;ls# 2. ipconfig# 发生的问题:# 象数据没有接收完全 或者 接收多了 这种现象就是“黏包” 12345678910111213141516171819202122# 在client端接收命令并执行返回import socketimport subprocesssk = socket.socket()sk.connect(('127.0.0.1',8090))while True: cmd = sk.recv(1024).decode('gbk') res = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) # print('stdout:' + res.stdout.read().decode('gbk')) # windows默认控制台输出 gbk # print('stderr:' + res.stderr.read().decode('gbk')) # windows默认控制台输出 gbk # 这里的res得到的是gbk格式，需要解码整体转换成str std_out = 'stdout: ' + (res.stdout.read()).decode('gbk') std_err = 'stderr: ' + (res.stderr.read()).decode('gbk') print(type(std_out),std_out) print(type(std_err),std_err) sk.send(std_out.encode('utf-8')) sk.send(std_err.encode('utf-8'))sk.close() UDP的黏包现象12345678910111213141516171819202122232425262728293031# serverimport socketsk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)sk.bind(ip_port)print('Bind UDP on 9999...')data,addr = sk.recvfrom(1024)while 1: cmd = input('cmd:&gt;&gt;&gt;') if cmd == 'q': break sk.sendto(cmd.encode('utf-8'),addr) data,addr = sk.recvfrom(10240) print(data.decode('utf-8'))sk.close()# 操作：# 1. ipconfig# 2. dir# udp# udp不会黏包# udp会丢包# tcp# tcp会黏包# tcp不会丢包# 内部优化算法 让整个程序发送数据和接收数据没有边界 12345678910111213141516171819202122# clientimport socketimport subprocesssk = socket.socket(type=socket.SOCK_DGRAM)ip_port = ('127.0.0.1',9999)sk.sendto('吃了吗？'.encode('utf-8'),ip_port)while 1: cmd,addr = sk.recvfrom(1024) # bytes if cmd == 'q': break res = subprocess.Popen(cmd.decode('gbk'),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) std_out = 'std_out:' + res.stdout.read().decode('gbk') std_err = 'std_err:' + res.stderr.read().decode('gbk') print(std_out) print(std_err) sk.sendto(std_out.encode('utf-8'),addr) sk.sendto(std_err.encode('utf-8'),addr)sk.close() 触发黏包会发生黏包的两种情况 发送方的缓存机制发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据很小，会合到一起，产生粘包） 123456789101112131415161718# server# 1. server 先把数据给操作,操作系统再传给对面的操作系统# 2. client 操作系统把接收到的消息 给client程序# 3. 如果发送了10个数据 由于第一次服务端接收2个，还剩下8个# 4. tcp协议在接收端有缓存机制，直到下次接收再给# 5. 第一次没有全部接收，后面就全发给接收方import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,addr = sk.accept()ret = conn.recv(2)ret2 = conn.recv(10)print(ret) # b'he'print(ret2) # b'llo,egg' 1234567import socketsk = socket.socket()sk.connect(('127.0.0.1',8090))sk.send(b'hello,egg')sk.close() 接收方的缓存机制 1234567891011121314151617# server # 1. 优化算法，连续的小数据包会被合并# 2. windows系统上 客户端在结束的时候会发送一个空消息 低版本会报错# 3. 多个send 小的数据连在一起，会发生黏包现象，是Tcp协议内部的优化算法造成的# 4. 连续使用了send引起的import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,addr = sk.accept()ret = conn.recv(12)print(ret) # b'helloegg'ret2 = conn.recv(12)print(ret2) 1234567891011# clietn import socketimport timesk = socket.socket()sk.connect(('127.0.0.1',8090))sk.send(b'hello')# time.sleep(3)sk.send(b'egg')sk.close() 总结黏包现象黏包现象只发生在tcp协议中： 从表面上看，黏包问题主要是因为发送方和接收方的缓存机制、tcp协议面向流通信的特点。 实际上，主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。 解决黏包发送消息长度 黏包问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个循环接收完所有数据。 存在的问题:程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗。 12345678910111213141516171819202122232425262728# server# 黏包的本质问题 — 你不知道到底要接收多大的数据# 解决: # 首先发送,这个数据到底有多大# 再按照数据的长度,接收数据import socketsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,addr = sk.accept()print('有新的客户端链接&#123;&#125;'.format(addr))while True: cmd = input('server: ').encode('gbk') if cmd == 'q': break conn.send(cmd) num = conn.recv(4) # 接收消息的长度 # print('接收消息长度:%d' %(int(num))) print(num) conn.send(b'ok') # 发送消息应答 ret = conn.recv(int(num)).decode('gbk') # 1024修改成要接收的数据长度 print(ret)conn.close()sk.close() 1234567891011121314151617181920212223# clientimport socketimport subprocesssk = socket.socket()sk.connect(('127.0.0.1',8090))while True: cmd = sk.recv(1024).decode('gbk') res = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) std_out = res.stdout.read() std_err = res.stderr.read() # print(type(std_out)) # &lt;class 'bytes'&gt; # print(type(std_err)) print(str(len(std_out)+len(std_err)).encode('utf-8')) # 得到消息长度 b'455' sk.send(str(len(std_out)+len(std_err)).encode('utf-8')) # 发送消息长度 # 发送一次消息的长度 sk.recv(4096) # 接收应答 sk.send(std_out) sk.send(std_err)sk.close() 进阶方法—使用struct模块12345678910111213141516# struct模块作用:把一个类型，如数字，转成固定长度的bytes# 1、什么是固定长度的bytesimport structret = struct.pack('i',20491) # i 代表int,即将要把一个数字转换成固定长度的bytes类型print(len(ret),ret) # 4 b'\x01\x08\x00\x00' 太长的数据不够位数会有字母和符号代替，超过长度会报错# struct.pack('i',1111111111111)# truct.error: 'i' format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围num = struct.unpack('i',ret)print(type(num),num) # &lt;class 'tuple'&gt; (2049,)print(num[0]) # 2049# 2、为什么要转成固定长度的# 发送数据的时候# 客户端先发送长度，服务端先接收长度 123456789101112131415161718192021222324252627282930# serverimport socketimport structsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,addr = sk.accept()print('有新的客户端链接&#123;&#125;'.format(addr))while True: cmd = input('server:&gt;&gt;&gt;').encode('gbk') if cmd == 'q': conn.send(b'bye') break conn.send(cmd) # 接收消息长度 客户端使用struct固定传值4个bytes num = conn.recv(4) # 4 num = struct.unpack('i',num)[0] # 消息长度大小 print(num) ret = conn.recv(int(num)).decode('gbk') print(ret)conn.close()sk.close() 1234567891011121314151617181920212223242526# clientimport socketimport subprocessimport structsk = socket.socket()sk.connect(('127.0.0.1',8090))while True: cmd = sk.recv(1024).decode('gbk') if cmd == 'q': break res = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) std_out = res.stdout.read() std_err = res.stderr.read() len_num = len(std_out)+len(std_err) num_by = struct.pack('i',len_num) # print(type(num_by),num_by) # &lt;class 'bytes'&gt; b'\xc8\x01\x00\x00' sk.send(num_by) # 发送固定4个字节，消息长度 sk.send(std_out) sk.send(std_err)sk.close() 使用struct解决黏包借助struct模块，我们知道长度数字可以被转换成一个标准大小的4字节数字。因此可以利用这个特点来预先发送数据长度。 我们还可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了） 实现大文件上传和下载1234567891011121314151617181920212223242526272829303132333435363738394041424344# server 接收端import socketimport jsonimport structsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')buffer = 1024 # 按照服务器性能调整conn,addr = sk.accept()print('有新的客户端链接&#123;&#125;'.format(addr))# 1. 接收报头长度pack_head = conn.recv(4) # 接收报头len_head = struct.unpack('i',pack_head)[0] # 使用struct.unpack得到报头长度# print(len_head)# 2. 接收数据报头js_head = conn.recv(len_head).decode('utf-8') # 接收bytes类型的数据报文js_head = json.loads(js_head) # json报文转字典# print(js_head)# 3. 获取文件长度和文件名称file_size = js_head['file_size']file_name = js_head['file_name']# 4. 打开文件,接收数据with open(file_name,mode='wb') as f: while file_size: print(file_size) if file_size &gt;= buffer: context = conn.recv(buffer) f.write(context) file_size -= buffer else: context = conn.recv(buffer) f.write(context) breakconn.close()sk.close() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# client 发送端import socketimport osimport structimport jsonsk = socket.socket()sk.connect(('127.0.0.1',8090))# 发送文件 定制报头# 发送流程:# 1. 先发报头长度# 2. 再发by_head报头# 3. 发送报文# 1. 组织数据字典head = &#123; 'file_name': '01 软件简介 软件分类.avi', 'file_path': 'D:\\', 'file_size': None&#125;file_path = os.path.join(head['file_path'],head['file_name']) # 获取文件路径# print(file_path)file_size = os.path.getsize(file_path) # 获取文件大小head['file_size'] = file_sizehead['all_file_path'] = file_sizebuffer = 4096# 2. 数据报头长度js_head = json.dumps(head,ensure_ascii=False)# print(js_head)by_head = js_head.encode('utf-8')len_head = len(by_head)pack_head = struct.pack('i',len_head)# 3. 发送报头长度sk.send(pack_head)# 4. 发送数据报头sk.send(by_head)# 5. 打开文件发送文件with open(file_path,mode='rb') as f: while file_size: print(file_size) if file_size &gt;= buffer: context = f.read(buffer) sk.send(context) file_size -= buffer else: context = f.read(buffer) sk.send(context) breaksk.close() 自定制报头 发送数据12345678910111213141516171819202122232425262728293031323334# serverimport socketimport structimport jsonsk = socket.socket()sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sk.bind(('127.0.0.1',8090))sk.listen()print('服务端8090端口开始监听...')conn,adrr = sk.accept()print('有新的客户端链接&#123;&#125;'.format(adrr))while True: cmd = input('server:&gt;&gt;&gt;').encode('gbk') conn.send(cmd) if cmd == 'q': break len_head = conn.recv(4) len_head = struct.unpack('i',len_head)[0] print(int(len_head)) # 接收报头 by_head = conn.recv(int(len_head)).decode('utf-8') head = json.loads(by_head) print(head,type(head)) # 通过报头长度接收消息 res = conn.recv(head['info_size']).decode('gbk') print(res)conn.close()sk.close() 1234567891011121314151617181920212223242526272829303132333435363738394041# clientimport socketimport structimport jsonimport subprocess# 组织报头head = &#123; 'info_size':None&#125;sk = socket.socket()sk.connect(('127.0.0.1',8090))while True: cmd = sk.recv(1024).decode('gbk') if cmd == 'q': break res = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) std_out = res.stdout.read() std_err = res.stderr.read() # 先发报头长度 # 1. 将字典转成by类型 head['info_size'] = len(std_out)+len(std_err) js_head = json.dumps(head,ensure_ascii=False) by_head = js_head.encode('utf-8') # 2. 使用struct将报头长度转成固定字节 len_head = len(by_head) print(len_head) pack_len = struct.pack('i',len_head) # 3. 发送报头长度 sk.send(pack_len) # 4. 发送报头 sk.send(by_head) # 5. 发送信息 sk.send(std_out) sk.send(std_err)sk.close()]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lambda 匿名函数]]></title>
    <url>%2F2019%2F03%2F25%2Fanonymous%2F</url>
    <content type="text"><![CDATA[匿名函数基础语法匿名函数的作用: 为了解决那些功能很简单的需求而设计的一句话函数 语法：func(函数名) = lambda(关键字) 参数:返回值 参数可以有多个，用逗号隔开 匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值 返回值和正常的函数一样可以是任意数据类型 123456# 把以下函数变成匿名函数def add(x,y): return x+y add = lambda x,y:x+yprint(add(1,2)) # 3 匿名函数和其他功能函数合作lambda 常常和几个内置函数一起使用 max min sorted filter map 和max函数配合12345678910111213141516171819202122# 字典取最大值的key# 字典取最大值dic=&#123;'k1':10,'k2':100,'k3':30&#125;ret = max(dic,key=dic.get)print(dic[ret]) # 100# 字典取最大值的键dic2=&#123;'k1':10,'k2':100,'k3':30&#125;ret1 = max(dic2)print(ret1) # k3 key按照文本大小的最大值# 字典取最大值的键dic2=&#123;'k1':10,'k2':100,'k3':30&#125;def max_dict_key(key): return dic2[key]ret = max(dic2,key=max_dict_key)print(ret) # k2# lambda 匿名一句话函数ret = max(dic2,key=lambda key:dic2[key])print(ret) # k2 和filter函数配合123456789101112# filter 配合 lambda#取出数组中大于10的数据 [5,8,11,9,15]def func(x): return x &gt; 10ret = filter(func,[5,8,11,9,15])for i in ret: print(i) # 11 15# lambda 匿名一句话函数ret = filter(lambda x:x &gt; 10,[5,8,11,9,15])for i in ret: print(i) # 11 15 和map函数配合1234567891011121314ret = map(abs,[-1,2,-3,4])for i in ret: print(i) # 1,2,3,4def func_map(x): return x**2ret = map(func_map,[-1,2,-3,4])for i in ret: print('func_map:',i)# lambda 匿名一句话函数ret = map(lambda x:x**2,[-1,2,-3,4])for i in ret: print('func_map_lanbda:',i) 匿名函数面试题12345678# 1.下面程序的输出结果是：d = lambda p:p*2t = lambda p:p*3x = 2x = d(x) # 4x = t(x) # 12x = d(x) # 24print(x) # 24 1234567891011121314151617# 2.现有两元组(('a'),('b')),(('c'),('d')) ,请使用python中匿名函数生成列表[&#123;'a':'c'&#125;,&#123;'b':'d'&#125;]# lambda# zipret = zip((('a'),('b')),(('c'),('d')))# for i in ret:# print(i)# def func(tup):# return &#123;tup[0]:tup[1]&#125;# res = map(func,ret)# for i in res:# print(i)res = map(lambda tup:&#123;tup[0]:tup[1]&#125;,ret)print(list(res)) # [&#123;'a': 'c'&#125;, &#123;'b': 'd'&#125;]]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>匿名函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置函数]]></title>
    <url>%2F2019%2F03%2F19%2Ffunction%2F</url>
    <content type="text"><![CDATA[内置函数什么是内置函数? 就是python给你提供的. 拿来直接用的函数,比如print., input等等.截止 到python版本3.6.2 python一共提供了68个内置函数. 有一些我们已经用过了.有一些还没有用过. 还有一些需要学完了面向对象才能继续学习的. 作用域相关(2) locals() 和 globals() 基于字典的形式获取局部变量和全局变量12print(locals()) # 返回本地作用域中的所有名字print(globals()) # 返回全局作用域中的所有名字 迭代器/生成器相关(3) range(),next() 和 iter()Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。1234567# range# range(10)# range(1,11)# range(1,11,2) # 步长取值print('__iter__' in dir(range)) # True 可迭代的print('__next__' in dir(range)) # False 不是迭代器print('__next__' in dir(iter(range(1,11,2)))) # True next(迭代器),迭代器向下执行一次,内部实际上调用迭代器.__next__()方法iter(可迭代的),用来生成一个迭代器12345678910# next 和 iterl = [1,2,3,4,5]it = iter(l) # 转成迭代器 print(type(it)) # &lt;class 'list_iterator'&gt;while 1: try: print(next(it)) except StopIteration: # 遇到StopIteration就退出循环 break 其他(12) 查看内置属性(1) dir() 默认查看全局空间内的属性，也接受一个参数，查看这个参数内的方法或变量12print(dir()) # 获得当前模块的属性列表print(dir([])) # 查看列表的方法 调用相关(1) callable() callable 用来检查一个对象是否可被调用对于函数、方法、lambda 函式、 类以及实现了 __call__ 方法的类实例, 它都返回 True。123a = 1print(callable(a)) # Falseprint(callable(print)) # True 帮助(1) help() 用于查看函数或模块用途的详细说明在控制台执行help()进入帮助模式。可以随意输入变量或者变量的类型。输入q退出或者直接执行help(o)，o是参数，查看和变量o有关的操作。。。1help(str) 模块相关(1) import() 导入模块1import time 文件操作相关(1) open() 打开一个文件，返回一个文件操作符(文件句柄)操作文件的模式有r,w,a,r+,w+,a+ 共6种，每一种方式都可以用二进制的形式操作(rb,wb,ab,rb+,wb+,ab+)可以用encoding指定编码.123f = open('01 内置函数.py')print(f.writable()) # 判断当前文件是否可写print(f.readable()) # 判断当前文件是否可读 内存相关(2) id() id()函数用于获取对象的内存地址。123# id(o) o是参数，返回一个变量的内存地址a = 100print(id(a)) # 1497027344 hash() 用于获取取一个对象（字符串或者数值等）的哈希值。hash() 函数可以应用于数字、字符串和对象，不能直接应用于 list、set、dictionary。获取到对象的哈希值(int, str, bool, tuple) hash函数会根据一个内部的算法对当前可hash变量进行处理，返回一个int数字。 每一次执行程序，内容相同的变量hash值在这一次执行过程中不会发生改变。1234print(hash(12345)) # 12345print(hash('abcde')) # -5832084034581495945print(hash(('a','b'))) # -3079515087831999849# print(hash(['a',1,'b',2])) # 报错:TypeError: unhashable type: 'list' 不可哈希 输入输出(2) input() 获取用户输入12content = input('&gt;&gt;&gt;')print(type(content),content) # input得到的是字符串类型 print() 打印输出12345# 关键字传参 end默认为'\n'，指定不是回车即可# 这就是我们为什么使用print的时候会出现换行,end的值修改成了空字符串print('我们的祖国是花园\n',end='')print('我们的祖国是花园\n',end='')print('我们的祖国是花园\n') 123# sep 打印多个值之间的分隔符，默认为空格print(1,2,3,4,5) # 1 2 3 4 5 多个值之间空格隔开print(1,2,3,4,5,sep='|') # 1|2|3|4|5 指定分隔符 12345# file: 默认是输出到屏幕，如果设置为文件句柄，输出到文件# flush: 立即把内容输出到流文件，不作缓存f = open('file','w')print('aaa',file=f,flush=True)f.close() 字符串类型代码的执行(3) eval() eval() 将字符串类型的代码执行并返回结果1print(eval('1+2+3+4')) # 10 有返回值 ——有结果的简单计算 exec() exec() 将自字符串类型的代码执行12345print(exec('1+2+3+4')) # None 没有返回值 ——简单的流程控制# exec 和eval都可以执行 字符串类型的代码# 区别是eval有返回值，exec没有# eval只能用在明确知道要执行的代码 compile() 将字符串类型的代码编译。代码对象能够通过exec语句来执行或者eval()进行求值。1234#流程语句使用exec# code1 = 'for i in range(0,10): print (i)'# compile1 = compile(code1,'','exec')# exec (compile1) 1234#简单求值表达式用eval# code2 = '1 + 2 + 3 + 4'# compile2 = compile(code2,'','eval')# print(eval(compile2)) 12345#交互语句用singlecode3 = 'name = input("please input your name:")'compile3 = compile(code3,'','single')exec(compile3)# print(name) # leo 执行exec后就存在name 基础数据类型相关(38)和数字相关(14) bool() bool() 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。int –&gt; bool 非0为True，0为False1234n1 = 10print(bool(n1)) # Truen2 = 0print(bool(n2)) # False int() int() 函数用于将一个字符串或数字转换为整型。​int() 将给定的数据转换成int值. 如果不给值, 返回012345678# int# str 转换成 int 只能转换数字字符串str1 = '10'print(int(str1)) # 10# int 转换成 str 数字可以转换成任何字符串num = 5print(str(num)) float() ﬂoat() 将给定的数据转换成ﬂoat值. 也就是浮点数 浮点数包括: 有限循环小数 无线循环小数 小数包括: 有限循环小数 无线循环小数 无线不循环小数12345# 浮点数# 354.123 == 3.54123 * 10**2 == 35.4123 * 10 在这个过程中点是浮动的 所以才叫浮点数f = 1.78789787079889 # 当小数特别长的时候 就有可能不准了 二进制转小数会有问题就会不准print(float(1)) # 1.0print(float('123') ) # 转换字符串 123.0 complex() complex() 创建一个复数. 第一个参数为实部, 第二个参数为虚部. 或者第一个参数直接 用字符串来描述复数 实数: 有理数 ： 整数 有限循环小数 无线循环小数 无理数 ： 无线不循环小数 π 虚数: 虚无缥缈的数123# python里面的虚数 = 12j (j是单位)# 5 + 12j === 复合的数 == 复数 (复数之间是无法比较大小的)print(complex(1, 2)) # (1+2j) bin() 1print(bin(10)) # 十进制转二进制 # 0b1010 oct() 1print(oct(10)) # 十进制转十进制 # 0o12 hex() 1print(hex(10)) # 十进制转十六进制 # 0xa abs() abs() 函数返回数字的绝对值。123# abs求绝对值 负的转正的 正的还是正的print(abs(-5)) # 5print(abs(10)) # 10 divmod() 12345# divmod 接收两个参数 div 除法 mod 取余# 除余方法# 分页的时候 会用到print(divmod(7,2)) # (3, 1)print(divmod(9,5)) # (1, 4) round() round() 方法返回浮点数x的四舍五入值。1print(round(3.14159,2)) # 3.14 2代表保留两位 支持四舍五入 pow() 1234# pow 求幂运算print(pow(2,3)) # 8print(pow(3,2,1)) # 0 三个参数就是 == 3的2次幂 对 1取余 幂运算之后再取余print(pow(2,3,3)) # 2 sum() ​sum() 求和12345678# sum(iterable[, start])# start 从几开始相加# 列表计算总和后再加10ret = sum([1,2,3],10)print(ret) # 16ret = sum((1,2,3))print(ret) # 6 min() min()计算最小值12345# min(iterable,key,default)# min(*args,key,default)print(min([1,2,3])) # 1print(min(1,2,3)) # 1print(min((1,2,3,-4),key=abs)) # 1 key=abs 以绝对值的方法来计算 max() min()计算最大值12345# max(iterable,key,default)# max(*args,key,default)print(max([1,2,3])) # 3print(max(1,2,3)) # 3print(max((1,2,3,-4),key=abs)) # -4 key=abs 以绝对值的方法来计算 和数据结构相关(24) list() list() 用于将元组或字符串转换为列表。注：元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中。1234str1="Hello World"print(list(str1)) # ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']tup1 = (1,2,3,'leo')print(list(tup1)) # [1, 2, 3, 'leo'] tuple() tuple()函数将列表转换为元组。。12l1= ['Google', 'Taobao', 'Runoob', 'Baidu']print(tuple(l1)) # ('Google', 'Taobao', 'Runoob', 'Baidu') reversed() reversed() 返回一个反向的迭代器12345678910# list.reverse() # 列表的反转方法l2 = [1,2,3,4]l2.reverse()print(l2) # [4, 3, 2, 1] 原本的列表发生变化l3 = [1,2,3,4,5]iter_l = reversed(l3) # 保留原列表,返回一个反向的迭代器print(iter_l) # &lt;list_reverseiterator object at 0x000000000288CF98&gt; 迭代器for i in iter_l: print(i) slice() slice() 函数实现切片对象，主要用在切片操作函数里的参数传递。1234l = (1,2,23,213,5612,342,43)sli = slice(1,5,2) # 切片规则print(l[sli]) # (2, 213)print(l[1:5:2]) # (2, 213) str() str() 将数据转化成字符串1234l4 = [1,2,3]print(str(l4)) # [1, 2, 3]dict4 = &#123;'name':'leo'&#125;print(str(dict4)) # &#123;'name': 'leo'&#125; format() format() 字符串格式化1234567print("&#123;&#125;,&#123;&#125;".format('leo','lex')) # leo,lex 不设置指定位置，按默认顺序print("&#123;0&#125;,&#123;1&#125;,&#123;0&#125;".format('leo','lex')) # leo,lex,leo 设置指定位置print("名字:&#123;name&#125;,年龄&#123;age&#125;".format(name='leo',age='30')) # 名字:leo,年龄30# 通过字典设置参数info = &#123;'name':'leo',"age":29&#125;print("名字:&#123;name&#125;,年龄&#123;age&#125;".format(**info)) # 名字:leo,年龄29 bytes() bytes 将数据转换成bytes类型12345# 拿到的事gbk编码，想要转换成utf-8编码print(bytes('您好',encoding='GBK')) # b'\xc4\xfa\xba\xc3' unicode转成 GBKprint(bytes('您好',encoding='utf-8')) # b'\xe6\x82\xa8\xe5\xa5\xbd' unicode 转 utf-8# gbk -&gt; decode（解码） unicode -&gt; encode(编码) utf-8 bytearray() bytes类型的数组123b_array = bytearray('您好',encoding='utf-8')print(b_array) # bytearray(b'\xe6\x82\xa8\xe5\xa5\xbd')print(b_array[0]) # 230 memoryview() memoryview() 函数返回给定参数的内存查看对象(Momory view)。所谓内存查看对象，是指对支持缓冲区协议的数据进行包装，在不需要复制对象基础上允许Python代码访问。1234ret = memoryview(bytes('你好',encoding='utf-8'))print(len(ret))print(bytes(ret[:3]).decode('utf-8'))print(bytes(ret[3:]).decode('utf-8')) ord() 字符按照unicode转数字123print(ord('A')) # 65print(ord('a')) # 97print(ord('1')) # 49 chr() 数字按照unicode转字符12print(chr(65)) # Aprint(chr(49)) # 1 ascii() 只要是ascii码(字母、数字、符号、拉丁文)就显示，不是的话就打印\u类型12print(ascii('好')) # '\u597d'print(ascii('l')) # l repr() repr格式化,原形毕露12345name = 'egg'print('你好%s' %name) # 你好egg %s ==&gt; strprint('你好%r' %name) # 你好'egg' %r ==&gt; reprprint(repr('1')) # '1'print(repr(1)) # 1 dict() 创造字典12print(dict()) # &#123;&#125;print(dict(a=1,b=2,c=3)) # &#123;'a': 1, 'b': 2, 'c': 3&#125; set() set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等123456x = set('runoob')y = set('google')print((set(['b', 'r', 'u', 'o', 'n']), set(['e', 'o', 'g', 'l'])) ) # 重复的被删除print(x &amp; y) # 交集 &#123;'o'&#125;print(x | y ) # 并集 &#123;'r', 'o', 'l', 'n', 'e', 'u', 'b', 'g'&#125;print(x - y ) # 差集 &#123;'r', 'b', 'n', 'u'&#125; frozenset() 生成一个新的不可变集合,它可以作为字典的key12a = frozenset(range(10)) # 生成一个新的不可变集合b = frozenset('runoob') 重要的内置参数 len() 返回对象的长度或者元素个数1234test = 'abcde'list1 = [1,2,3]print(len(test)) # 5 字符串长度print(len(list1)) # 3 列表元素个数 enumerate() enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中enumerate(sequence, [start=0]) sequence – 一个序列、迭代器或其他支持迭代对象。 start – 下标起始位置。123456seasons = ['Spring', 'Summer', 'Fall', 'Winter']list2 = list(enumerate(seasons))print(list2) # [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]list3 = list(enumerate(seasons, start=1)) # 小标从 1 开始print(list3) # [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] all() 有任何一个空内容就是false123print(all(['a','',123])) # Falseprint(all(['a',123])) # Trueprint(all([0,123])) # False any() 有一个正确的就是True1print(any(['',True,0,[]])) # True zip() zip 拉链方法,如果少一个元素无法对应上，就不加入,以最小的数据类型为准12345678910l1 = [1,2,3]l2 = ['a','b','c','d']t3 = ('*','**',[1,2])d4 = &#123;'k1':'1','k2':'2'&#125;print(zip(l1,l2)) # &lt;zip object at 0x00000000028422C8&gt;for i in zip(l1,l2,t3,d4): print(i)# (1, 'a', '*', 'k1')# (2, 'b', '**', 'k2') filter() filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象,如果要转换为列表，可以使用 list() 来转换。filter() 函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。1234567891011121314151617# 过滤列表中的奇数def is_odd(x): return x % 2 == 1 # 奇数# 第一个参数 函数方法# 第二个参数 可迭代的# 可迭代的里面的每个数据都会传入前面的函数# 根据函数的结算结果筛选,为True的才会留下，最后返回一个迭代器ret = filter(is_odd,[1,3,5,8,10])print(ret) # &lt;filter object at 0x00000000027A8780&gt; 迭代器# for i in ret:# print(i) # 迭代器节省内存print(list(ret)) # [1, 3, 5]# 相当于列表推导式l2 = [i for i in [1,3,5,8,10] if i % 2 == 1]print(l2) # [1, 3, 5] 12345678# 名字有两个e的结果names = ['leo','leex','rubin','lee']def func(name): return name.count('e') &gt;= 2iter_names = filter(func,names)for i in iter_names: print(i) # leex,lee 12345678910# 只保留字符串l3 = [1,'leo',2,'rubin',3]def is_str(s):# if type(s) == str:# return True return type(s) == striter_names = filter(is_str,l3)for i in iter_names: print(i) # leo,rubin 123456789# 删除列表中的None和空字符串l4 = ['test', None, '', 'str', ' ', 'END']def is_none(s): if type(s) != int: return s and str(s).strip()iter_none = filter(is_none,l4)for i in iter_none: print(i) 12345678# 练习：请利用filter()过滤出1~100中平方根是整数的数，即结果应该是：from math import sqrt # 开平方print(sqrt(64)) # 8.0def init_sqrt(num): res = sqrt(num) return res % 1 == 0 # 除1余0就是整数iter_sqrt = filter(init_sqrt,range(1,101))print(list(iter_sqrt)) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] map() Python中的map函数应用于每一个可迭代的项，返回的是一个结果list。如果有其他的可迭代参数传进来，map函数则会把每一个参数都以相应的处理函数进行迭代处理。map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。1234567891011# map 有点像 [i for i in [1,2,3]]ret = map(abs,[-1,-2,3,-8])for i in ret: print(i) # 1,2,3,8# filter 执行了filter之后的记过集合 &lt;= 执行之前的个数 # filter只管筛选，不会改变原来的值# map 执行前后元素个数不变，值变了 # 值可能发生改变 # 要注意配合匿名函数 sorted() 对List、Dict进行排序，Python提供了两个方法对给定的List L进行排序，方法1.用List的成员函数sort进行排序，在本地进行排序，不返回副本方法2.用built-in函数sorted进行排序（从2.4开始），返回副本，原始输入不变1234567891011121314151617181920# sortl = [1,-4,6,5,-10]l.sort(key=abs) # 在原列表的基础上进行排序print(l) # [1, -4, 5, 6, -10]# sorted# 会生成一个新的数据,保留原来数据# 排序的过程中负载的算法不支持产生一个迭代器l = [1,-4,6,5,-10]print(sorted(l)) # [-10, -4, 1, 5, 6] # 生成一个新列表，不改变原列表 占内存print(l) # [1, -4, 6, 5, -10] # 源列表不变# reversed() 倒叙 返回一个反向的迭代器# sorted() 排序 返回listprint(sorted(l,key=abs)) # [1, -4, 5, 6, -10]# 列表按照每一个元素的len排序l = [[1,2],[3,4,5,6],(7,),'123']print(sorted(l,key=len)) # [(7,), [1, 2], '123', [3, 4, 5, 6]]]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器面试题]]></title>
    <url>%2F2019%2F03%2F18%2Fcase-generator%2F</url>
    <content type="text"><![CDATA[生成器面试题12345678910111213141516171819def demo(): # 生成器函数 for i in range(4): yield ig=demo() # 生成器# 生成器表达式g1=(i for i in g) # 没执行g2=(i for i in g1)# 数据类型强转print(list(g1)) # [0, 1, 2, 3] # 执行了,g1生成器找g取值print(list(g2)) # [] # g2找g1拿值，g1已经没有值了.所以是空,把g1注释掉,g2就有值了# 一个生成器里面的能用只能取一次,你不找他要，他也不会给你# g1=(i for i in g) 没干活，因为他返回了个 生成器#def g1():# for i in g:# yield i 123456789101112131415161718192021222324252627def add(n,i): return n+idef test(): for i in range(4): yield ig=test()for n in [1,10]: g=(add(n,i) for i in g) # 生成器表达式# 当遇见这种问题的时候 先将循拆开# for循环套生成器表达式# n = 1# g=(add(n,i) for i in g) # test()# n = 10# g=(add(n,i) for i in g) # (add(n,i) for i in g)# 2 带入方程# g=(add(n,i) for i in test())# g=(add(n,i) for i in (add(10,i) for i in test()))# n = 10# g=(add(n,i) for i in (add(10,(0,1,2,3))# n = 10# g=(add(10,i) for i in (10,11,12,13))# 20,21,22,23print(list(g)) # 开始执行 12345678910111213141516171819202122def add(n,i): return n+idef test(): for i in range(4): yield ig=test()for n in [1,10,5]: g=(add(n,i) for i in g) # 生成器表达式# n = 1# g=(add(n,i) for i in test())# n = 10# g=(add(n,i) for i in (add(n,i) for i in test()))# n = 5# g=(add(n,i) for i in (add(n,i) for i in (add(n,i) for i in test())))# g=(add(n,i) for i in (add(n,i) for i in (add(n,i) for i in (0,1,2,3))))# g=(add(n,i) for i in (add(n,i) for i in (5,6,7,8)))# g=(add(n,i) for i in (10,11,12,13)# 15,16,17,18print(list(g)) # 开始执行]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种推导式]]></title>
    <url>%2F2019%2F03%2F15%2Fcomprehensions%2F</url>
    <content type="text"><![CDATA[推导式的套路: 新的列表 = [ 每一个元素或者是和元素相关的操作 for 元素 in 可迭代数据类型 ] # 遍历之后挨个处理 新的列表 = [ 满足条件的元素相关的操作 for 元素 in 可迭代数据类型 if 元素相关的条件 ] # 筛选功能 列表推导式12345678910111213141516171819202122# 例一：30以内所有能被3整除的数l = [ i for i in range(30) if i % 3 == 0 ]print(l)# 例二：30以内所有能被3整除的数的平方l = [ i**2 for i in range(30) if i % 3 == 0 ]print(l)# 例三:找到嵌套列表中名字含有两个‘e’的所有名字names = [['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe'], ['Alice', 'Jill', 'Ana', 'Wendy', 'Jennifer', 'Sherry', 'Eva']]# 常规循环#for l in names:# for name in l:# if name.count('e') &gt;= 2:# print(name)# 二维列表# 注意遍历顺序，这是实现的关键l = [name for l in names for name in l if name.count('e') &gt;= 2]print(l) 字典推导式12345678910111213141516171819# 字典推导式# 例一：将一个字典的key和value对调mcase = &#123;'a': 10, 'b': 34&#125;# 常规循环# for k in mcase:# mcase[k] : k # v : k# print(mcase)mcase = &#123;mcase[k]:k for k in mcase&#125;print(mcase)# 例二：合并大小写对应的value值，将k统一成小写# 所有的推导式都从for开始看mcase = &#123;'a': 10, 'b': 34, 'A': 7, 'Z': 3&#125;# &#123;'a':10+7,'b':34,'z':3&#125;mcase_frequency = &#123;k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()&#125;# 拿到所有key# key值就是要小写k.lower():# mcase.get(k.lower(), 0)没有小写的就默认写一个0 + mcase.get(k.upper(), 0) 相当于小写+大写的值,没有就给0print(mcase_frequency) 集合推导式12345# 集合推导式 可以替重# &#123;&#125;# 例：计算列表中每个值的平方，自带去重功能squared = &#123;x**2 for x in [1, -1, 2]&#125;print(squared) # -1的平方和1的平方一样 所以去重之后2个结果，如果是列表就不会自动去重 总结各种推导式:生成器 列表 字典 集合 遍历 筛选 带if 优点 推导式能让你的代码更简洁， 可读性提高 惰性运算: 懒 不去找他要值不会执行，要一个执行一个 生成器(自己写的，可见)和迭代器（不可见的，python提供）特点 同一个迭代器,从头到尾取值只能取一次 不找他要值的时候不干活 练习1234567891011121314151617# 例1: 过滤掉长度小于3的字符串列表，并将剩下的转换成大写字母names = ['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe']new_l = [name.upper() for name in names if len(name) &gt; 3]print(new_l)# 例2: 求(x,y)其中x是0-5之间的偶数，y是0-5之间的奇数组成的元祖列表l1 = [(x,y) for x in range(5) if x%2==0 for y in range(5) if y %2==1]l2 = [(x,y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]print(l1)print(l2)# 求M中3,6,9组成的列表M = [[1,2,3],[4,5,6],[7,8,9]]# for i in M:# print(i[2])l3 = [row[2] for row in M]print(l3)]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>列表推导式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 装饰器]]></title>
    <url>%2F2019%2F03%2F13%2Fdecorator%2F</url>
    <content type="text"><![CDATA[简单的装饰器使用比如现在公司有一个需求，每个函数都要计算运行时间，我们可以调用time模块实现一个简单的计算执行时间的方法 1234567891011import time# 统计每个函数的执行时间 1def func(): start_time = time.time() print('func 1') time.sleep(3) now_time = time.time() return now_time - start_timeret = func() # func 1print(ret) # 3.000171661376953 那如果要是有200多个函数呢，难道要一个个加入，然后在一个个删除？我们想到计算时间可以单独写一个函数去调用。123456789101112# 调用统计时间函数def timmer(f): start_time = time.time() f() end_time = time.time() print(end_time - start_time)def func(): time.sleep(3) print('func 1')timmer(func) 这样以后的200个函数都要使用timmer去调用执行么？也是不合理的，应该是func方法来调用时间函数，比较合理。 装饰器的形成过程1234567891011121314151617181920# 我们想要做到的:# 1 不想修改函数的调用方式 但是还想再原来的函数前后添加功能# 2 timmer就是一个装饰器函数，只是对一个函数 有一些装饰作用def func(): time.sleep(3) print('func 1')# 调用统计时间函数# 闭包 内部函数inner,调用了外部变量f,f是传进来的def timmer(f): # 装饰器函数 def inner(): start_time = time.time() f() # 被装饰的函数 end_time = time.time() print(end_time - start_time) return innerfunc = timmer(func)func() 运行过程流程图: 原来的函数为func 最后我还是要调用func 中间增加的计时功能timmer 通过func = timmer(func) 和 闭包函数 来进行修饰 最终通过闭包函数来返回内部函数 交给 外部的func接收，接收的变量还是原本func的方法 最后执行外部的func()，他会自动去找装饰函数inner(),再去找到原本被装饰的函数func() 总结:装饰器的本质：一个闭包函数装饰器的功能：在不修改原函数及其调用方式的情况下对原函数功能进行扩展装饰器的意义： 装饰器既没有改变函数的调用方式，又在函数的前后增加了装饰功能 开放封闭原则开放: 对扩展是开放的,任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。 封闭: 对修改是封闭的,因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对其进行了修改，很有可能影响其他已经在使用该函数的用户。 装饰器完美的遵循了这个开放封闭原则 语法糖@装饰器函数 == 重新定义被装饰函数=装饰器函数（被装饰函数）12345678910111213141516171819import timedef timmer(f): # 装饰器函数 def inner(): start_time = time.time() f() # 被装饰的函数 end_time = time.time() print(end_time - start_time) return inner# 语法糖 @timmer 让代码更好看 更便捷# 在被装饰的函数上面贴着加上 @装饰器函数名 # 就相当于写了func = timmer(func)@timmerdef func(): time.sleep(3) print('func 1')# func = timmer(func)func() 装饰带返回值的函数的装饰器12345678910111213141516171819202122import timedef timmer(f): # 装饰器函数 def inner(): start_time = time.time() ret = f() # 被装饰的函数 带有返回值 end_time = time.time() print(end_time - start_time) return ret # 返回被装饰的函数的返回值 return inner@timmerdef func(): time.sleep(3) print('func 1') return '新年好' # 被装饰的函数的返回值# func = timmer(func)ret = func()print(ret)# 因为现在的func不是原来的func 而是inner ，所有要对inner中增加返回值# 现在的func就是inner,ret接收的事inner的返回值 装饰带一个参数的函数12345678910111213def wrapper(func): def inner(name): ret = func(name) return ret return inner@wrapper # func = wrapper(func)def func(name): return '新年好,%s'%nameret = func('leo')print(ret) 接收万能参数装饰器1234567891011121314151617def wrapper(func): def inner(*args,**kwargs): # print('函数被装饰之前要做的事') print(*args) # leo python print(kwargs) # &#123;'age': 30&#125; print(kwargs['age']) # 30 ret = func(*args,**kwargs) # print('函数被装饰之前要做的事') return ret return inner@wrapperdef func(name,course,age): return '大家好,我是%s,今年%d,现在正在学习%s'%(name,age,course)ret = func('leo','python',age=30)print(ret) # 大家好,我是leo,今年30,现在正在学习python 装饰器的固定格式123456789101112131415161718import time# 单纯就叫装饰器的时候 -- wrapperdef wrapper(f): # 装饰器函数,f是被装饰的函数,装饰器函数里面的参数永远是被装饰的函数 def inner(*args,**kwargs): # 内部函数inner,*args,**kwargs动态参数原封不动的传给被装饰的函数 # 被装饰函数执行之前要做的事 ret = f(*args,**kwargs) # 被装饰的函数,执行完成后，给外面返回值 # 被装饰函数执行之后要做的事 return ret return inner # 对应内部函数inner 不加括号执行@wrapper # func = timmer(func)def func(a,b): time.sleep(2) print('func1',a,b) return '新年好'ret = func(1,2)print(ret) 1234567891011def wrapper(func): # func = qqxing def inner(*args,**kwargs): ret = func(*args,**kwargs) # 被装饰的函数 qqxing return ret return inner@wrapper # qqxing = wrapper(qqxing)def qqxing(a,b): print(123)ret = qqxing(1,2) # 实际上执行的是inner() 装饰器的固定格式 - wraps首先先了解函数的name和doc方法:函数名.__name__ = 查看字符串格式的函数名函数名.__doc__ = 查看函数注释123456789def wahaha(): ''' 一个打印娃哈哈的函数 :return: ''' print('娃哈哈')print(wahaha.__name__) # 查看字符串格式的函数名print(wahaha.__doc__) # 查看函数注释 在执行使用装饰器之后，我们打印函数的name发现是装饰器的函数名称了，这个时候就需要使用wraps来解决。12345678910111213141516171819202122232425from functools import wrapsdef wrapper(func): # func = holiday @wraps(func) # 装饰inner函数 def inner(*args,**kwargs): print('在被装饰的函数执行前做的事') ret = func(*args,**kwargs) print('在被装饰的函数执行后做的事') return ret return inner@wrapper # holiday = wrapper(holiday)def holiday(day): ''' 这是一个放假通知 :param day: :return: ''' return '还有%s天放假'%dayprint(holiday.__name__) # inner...因为现在的holiday已经是inner了，由于之前说装饰器最好不要影响被装饰的函数，需要用wraps装饰inner函数,才可以正常显示回去print(holiday.__doc__)ret = holiday(3) # innerprint(ret)# wraps并不影响wrapper装饰器的使用 带参数的装饰器比如现在有500个函数,都使用装饰器，那么怎么一次性的去控制500个装饰器的增加和删除，怎么办？我们可以使用带参数的参数器，通过标志位参数去控制装饰器是否执行。带参数的装饰器，也就是三层装饰器，在外部多一次调用传入状态标记。123456789101112131415161718192021222324252627282930import timeFLAGE = True # 标识位，True执行，Fales不执行def timmer_out(flag): # 在原有装饰器之外再来一层 def timmer(func): def inner(*args,**kwargs): if flag: # 如果flag = True 那么我就走装饰器，否则我就只运行被装饰的函数 start_time = time.time() ret = func(*args,**kwargs) end_time = time.time() print(end_time - start_time) return ret else: ret = func(*args, **kwargs) return ret return inner return timmer# timmer = timmer_out(FLAGE)@timmer_out(FLAGE)def wahaha(): time.sleep(2) print('wahaha')@timmer_out(FLAGE)def qqxing(): time.sleep(1) print('qqxing')ret = wahaha()ret = qqxing() 多个装饰器装饰一个函数多个装饰器执行的过程有点像套娃，装饰器在后的先执行装饰1234567891011121314151617181920212223242526272829303132def wrapper1(func): # f def inner1(): print('wrapper1装饰器 start') # 3 func() # 执行f # 4 print('wrapper1装饰器 end') # 5 return inner1def wrapper2(func): # inner1 def inner2(): print('wrapper2装饰器 start') # 1 先执行他 func() # inner1() # 2 print('wrapper2装饰器 end') # 6 return inner2# 先看装饰器执行先后@wrapper2 # f = wrapper2(f)==&gt; f = inner1 ==&gt; inner1 = wrapper2(inner1) ==&gt; inner2 ，传进去的是inner1,最后返回得到的是inner2@wrapper1 # f = wrapper1(f) = inner1def f(): print('in f')f() # ==&gt; 调用开始现在是 inner2# wrapper2装饰器 start# wrapper1装饰器 start# in f# wrapper1装饰器 end# wrapper2装饰器 end# 1. 先看装饰器执行先后，wrapper2没有找到要被修饰的函数，所以现在wrapper1# 2. f = wrapper1(f) = inner1# 3. # f(下面赢变成inner1) ==&gt; inner1 = wrapper2(inner1) = inner2，但是传进去的是inner1, 有时候会遇见两个需求: 记录用户的登录情况 记录函数的执行时间仔细思考下先后执行顺序:先登录成功之后 才能开始执行程序记录函数的执行时间]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 迭代器]]></title>
    <url>%2F2019%2F03%2F11%2Fiterator%2F</url>
    <content type="text"><![CDATA[for循环是如何工作的当我们拥有一个列表 l = [1,2,3,4,5],想取列表中的内容，有几种方式？ 1234# 1 通过索引下标和切片取值l = [1,2,3,4,5]print(l[0]) # 1print(l[0:2]) # [1, 2] 123# 2 通过for循环取值for i in l: print(i) 他们的区别是，使用索引取值可以取到任意位置的值，前提是我知道这个值在什么位置，而for循环是取到每一个值，不需要关心这个值在什么位置，也不能跳过任何一个值去取其他位置的值，我们可以称作循环遍历。那么for循环到底是怎么工作的呢？ 都有哪些数据类型可以被for循环123456789101112131415for s in 'abcde': print(s) # 返回字符串中每一个字符 a b c d edic = &#123;'name':'leo','age':26&#125;for key in dic: print(key) # 默认返回字典中的键 name , agefor value in dic.values(): print(value) # 返回字典中的值 leo,26 for k,v in dic.items(): print(k,v) # 返回字典中的键值对 name leo age 26for i in 12345: print(i) # TypeError: 'int' object is not iterable 当我们循环数字类型的时候报错了，说int类型不是 iterable（可迭代的） 迭代和可迭代协议通过对数字类型的报错，不可被for循环的数据类型会报错 不是一个可迭代的，那么是不是说可迭代的数据类型就可以被for循环，如何判断数据类型是否可以被迭代？123456789101112131415161718from collections import Iterablel = [1,2,3,4]t = (1,2,3,4)d = &#123;1:2,3:4&#125;s = &#123;1,2,3,4&#125;num = 123money = 10.10print(isinstance(l,Iterable)) # Trueprint(isinstance(t,Iterable)) # Trueprint(isinstance(d,Iterable)) # Trueprint(isinstance(s,Iterable)) # Trueprint(isinstance(num,Iterable)) # Falseprint(isinstance(money,Iterable)) # False# 下面这三种也是可以被循环遍历# f = open() # range()# enumerate 枚举 可以将某个数据集内的数据“一个挨着一个的取出来”，就叫做迭代总结出一条规律来：能被for循环的就是“可迭代的”。但是如果正着想，for怎么知道谁是可迭代的呢？为什么能被for循环？ 123456789101112131415# 为什么能够被循环# dir 可以返回这个数据类型的拥有的所有方法# 查看列表、字典、字符串、和range的双下方法 有什么共同方法# 求交集ret = set(dir([]))&amp;set(dir(&#123;&#125;))&amp;set(dir(''))&amp;set(dir(range(10)))print(ret) # 我们找一个和iterable比较相似的方法， '__iter__',# 我们再来看看无法被迭代的数据类型 有没有__iter__方法print('__iter__' in dir(int)) # Falseprint('__iter__' in dir(bool)) # Falseprint('__iter__' in dir(list)) # Trueprint('__iter__' in dir(dict)) # Trueprint('__iter__' in dir(set)) # Trueprint('__iter__' in dir(tuple)) # Trueprint('__iter__' in dir(range(10))) # Trueprint('__iter__' in dir(enumerate([]))) # True 再总结出一条新的规律: 能被for循环的就是“可迭代的”,只要是能被for循环的数据类型，就一定拥有__iter__双下方法 双下方法__iter__做了什么123456789101112131415161718print([].__iter__()) # &lt;list_iterator object at 0x0000000002308940&gt; 迭代器 iterator# [].__iter__() 得到了一个list_iterator# 那么迭代器有什么作用呢？让我们来看看列表list和转换成列表_迭代器所有方法的差集print(set(dir([].__iter__()))- set(dir([])) ) # &#123;'__setstate__', '__length_hint__', '__next__'&#125;# 迭代器多出来的这三个方法的作用:#__length_hint__ 获取迭代器中元素的长度# print([1,2,3,4,5].__iter__().__length_hint__()) # 5 元素个数# __setstate__ 可以指定从其他位置取值# __next__ 一个一个的取值# 迭代器取值l = [1,2,3] # 列表iterator = l.__iter__() # iterator现在是一个迭代器,他内部有.__next__()方法print(iterator.__next__()) # 1print(iterator.__next__()) # 2print(iterator.__next__()) # 3print(iterator.__next__()) # 报错 StopIteration 通过上面的例子我们发现,当一个可迭代的对象调用了iter()方法会生成一个 iterator (迭代器) 迭代器中含有_next__()方法，他可以一个一个的取值,如果我们一直取next取到迭代器里已经没有元素了，就会抛出一个异常StopIteration，告诉我们，列表中已经没有有效的元素了 可迭代协议 与 迭代器协议根据上面的例子我们总结出以下概念： 能被for循环的数据类型都是 可迭代的 (iterable) 当这个数据类型调用.__iter__()方法会生成一个 迭代器(iterator) 迭代器.next()可以一个一个的取值 for循环其实就是在使用迭代器，只有是可迭代对象或者迭代器，才能用for循环 for循环的本质就是迭代器 12345for i in l: pass # 首先会去找l.__iter__() ==&gt; iterator = l.__iter__() # i = iterator.__next__() # 当没有值的时候 自动停止结束 也不会报错 12345# 模拟for循环l = [1,2,3,4,5]iterator = l.__iter__() # 变成一个迭代器while True: print(iterator.__next__()) 可迭代协议: 只要含有__iter__()方法的都是可迭代的迭代器协议: 内部含有__next__()方法和__iter__()方法的就是迭代器 可迭代的不一定就是迭代器 迭代器：内部有__iter__和__next__方法 ，所以他一定是可迭代的 可迭代的不一定是迭代器，要看有没有__next__方法12345678910from collections import Iterablefrom collections import Iteratorprint(isinstance([],Iterable)) # 可迭代的 # Trueprint(isinstance([],Iterator)) # 迭代器 # False ,list是可迭代的，但不是一个迭代器print('__iter__' in dir(range(12))) # Trueprint('__next__' in dir(range(12))) # Falseprint(isinstance(range(100000000),Iterable)) # Trueprint(isinstance(range(100000000),Iterator)) # False , range是可迭代器，但不是一个迭代器，因为它没有__next__()方法 迭代器的好处 迭代器会从容器类型中 一个一个的取值，会把所有的值都取到。 它可以节省内存空间,迭代器并不会在内存中再占用一大块内存，而是随着循环每次生成一个,或者每次next()每次给我一个12# print(range(10000000)) # 很快，但是并不会在内存中真正的生成数据# print(list(range(10000000))) # 强制转列表会导致崩溃,list是真正存在并存储在内存里 ，range是要一个给一个]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 生成器]]></title>
    <url>%2F2019%2F03%2F11%2Fgenerator%2F</url>
    <content type="text"><![CDATA[什么是生成器之前我们学习过迭代器，它的好处之一就是可以节省能存，在某些情况下，我们需要自己定义一个方法去实现迭代器功能，这个方法就是生成器。在Python中生成器又分成两类: 生成器函数 生成器表达式 生成器函数生成器Generator： 本质：迭代器(所以自带了iter方法和next方法，不需要我们去实现) 特点：惰性运算,开发者自定义 生成器函数：一个包含yield关键字的函数就是一个生成器函数。yield可以为我们从函数中返回值，但是yield又不同于return，return的执行意味着程序的结束，调用生成器函数不会得到返回的具体的值，而是得到一个可迭代的对象。每一次获取这个可迭代对象的值，就能推动函数的执行，获取新的返回值。直到函数执行结束。 1234567891011121314# 只要含有yield关键字的函数都是生成器函数# yield 必须写在函数里，且无法和return共用def generator(): a = 1 yield a b = 2 yield b g = generator() # 得到一个“生成器”作为返回值print(g) # &lt;generator object generator at 0x0000000001E9A308&gt; generator 生成器# g.__next__ # 生成器带有__next__方法和__iter__方法# g.__iter__ # 生成器是迭代器 用next方法取值print(g.__next__()) # 1print(g.__next__()) # 2 运行过程总结： 由于函数中有yield，所以现在内存中会有一个生成器函数 generator g = generator() 发生了函数调用，生成器函数的特点：函数中的代码不执行 g 得到了一个生成器 生成器里面即有iter方法也有next方法，说明它其实是一个迭代器 生成器就可以使用next方法取值,这时程序才第一次触发了生成器里面的代码 yield 不会结束函数，return会直接结束 生成器函数的使用生成器的最大好处就是不会在内存中一次性的生成所有数据1234567891011121314151617181920212223def factoy(): for i in range(100): yield '生成%s次'%ig = factoy()# __next__() ,一次一次的提取print(g.__next__())print(g.__next__())print(g.__next__())# for循环遍历提取for i in g: print(i)# 取50次g = factoy()count = 0for i in g: count += 1 print(i) if count &gt; 50: breakprint('*****',g.__next__()) # ***** 生成51次 可以继续从生成器中取值 列表为什么不能继续取值123456789101112131415161718192021# 列表是可迭代的,并不是一个迭代器,在两次for循环的时候会产生两个迭代器# for循环自动将可迭代的转换成迭代器l = [1,2,3,4,5]for i in l: print(i) # 1,2 if i == 2: breakfor i in l: print(i) # 1,2,3,4,5 # 获取两个生成器l = [1,2,3,4,5]def generator(): for i in l: yield i g = generator()g1 = generator()print(g,g1) # &lt;generator object generator at 0x0000000001F7A150&gt; &lt;generator object generator at 0x0000000001F7A200&gt;print(g.__next__()) # 1print(g1.__next__()) # 1 拿到两个生成器，自己执行自己的 监听文件的输入123456789101112def tail(filename): f = open(filename, encoding='utf-8') while True: line = f.readline() # 每次读一行 if line.strip(): # 不为空就打印 # print('****',line.strip('\n')) yield line.strip() # 返回这行g = tail('file') # 获取生成器for i in g: if 'python' in i: print('*****',i,'*****') # 可以对这个结果做任何操作了,用生成器实现就可以想要的结果 爬虫时的使用123456789101112131415161718192021222324252627def parse_one_page(html): rule = re.compile( '&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?' 'releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;' ,re.S) items = re.findall(rule, html) # 通过findall方法根据规则得到html文本 # print(items) for item in items: yield &#123; 'index':item[0], 'image':item[1], 'title':item[2].strip(), 'actor':item[3].strip(), 'time':item[4].strip(), 'score':item[5].strip() + item[6].strip() &#125; # 循环整个html文本列表,每一条数据都生成yield返回一个字典，里面拼接成想要的数据类型# 使用的时候传递一个页面进去，循环调用生成器，item里就是生成的每条数据def main(offset): url = 'https://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) # print(html) for item in parse_one_page(html): print(item) write_to_file(item) 生成器函数的进阶数据类型的强制转换 — 列表(生成器)1234567891011121314def generator(): for i in range(20): yield 'wahaha%s'%ig = generator()# list(g)# list是列表，代表将g生成器直接转换成列表，列表中的每一个值都是实际存在的# 一个一个从生成器里取出来，全部取完放入列表，列表会在内存中生成print(list(g))# ['wahaha0', 'wahaha1', 'wahaha2', 'wahaha3'...'wahaha19']# 从生成器取值的几个方法： # next # for # 数据类型的强制转换 (不推荐，占用内存) 123456789101112def generator(): print(123) yield 1 print(456) yield 2 print(789)g = generator() # 得到一个生成器ret = g.__next__()print('***',ret) # 先打印123，然后拿到yield返回的1print('***',ret)print('***',ret) # 执行了789,由于后面没有yield,会报错StopIteration 生成器函数 — send123456789101112131415161718192021222324def generator(): print(123) send_msg = yield 1 print('======',send_msg) yield 2g = generator()ret = g.__next__()print('***',ret)ret = g.send('send_hello')print('***',ret)# 123# *** 1# ====== send_hello# *** 2# send用法总结# 1. send的获取下一个值的效果与next基本一致# 2. 只是在获取下一个值的时候给上一个yield的位置,传递一个数据# 使用send的注意事项# 1. 第一次使用生成器的时候,必须使用next获取下一个值# 2. 最后一个yield 不能接收外部的值,但是可以在接收arg=yield 2...最后返回一个空yield send实例 — 计算移动平均值123456789101112131415161718192021# 接收一次值计算平均值# 移动平均值# num: 10 20 30# avg: 10 15 20# 公式: avg = num / countdef avg_generator(): sum = 0 count = 0 avg = 0 num = yield # 第一次返回空，为了后面send传值(num)进来,10 sum += num # 总数有更新 10 count += 1 # 次数更新 avg = sum / count yield avg # send执行到这avg_g = avg_generator()avg_g.__next__() # 使用send第一次必须next，得到空avg1 = avg_g.send(10) # 传值(num)10进去print(avg1) 那么如何多次计算呢，需要加上循环123456789101112131415161718192021222324252627# 移动平均值# num: 10 20 30# avg: 10 15 20# 公式: avg = num / countdef avg_generator(): sum = 0 count = 0 avg = 0 while 1: # num = yield # 第一次返回空，为了后面send传值(num)进来,10 num = yield avg # 第一次的avg = 0 ，num = 传值 sum += num # 总数有更新 10 count += 1 # 次数更新 avg = sum / countavg_g = avg_generator()avg_g.__next__() # 使用send第一次必须next，得到空avg = avg_g.send(10) # 传值(num)10进去avg = avg_g.send(20)avg = avg_g.send(30)print(avg)# 每次计算方法:# 如果我加上while循环,现在我有两个yield,第一次结束到yield avg,第二次执行什么？# 如果执行next num = yield 相当于 num = 0# 下面再用一次send 传值20 再返回打印 计算移动平均值(2)_预激协程的装饰器123456789101112131415161718192021222324252627# 计算移动平均值# 用装饰器 激活__next__()def init(func): def inner(*args,**kwargs): g = func(*args,**kwargs) # g = generator() 拿到装饰器 g.__next__() # 执行__next__() return g # 返回装饰器 return inner@init # avg_generator = init(avg_generator) ==&gt; innerdef avg_generator(): sum = 0 count = 0 avg = 0 while True: # num = yield num = yield avg # num = 10,20,30 sum += num # sum = 10,30,60 count += 1 # count = 1,2,3 avg = sum / count # avg = 10,15,20g = avg_generator() # inner() # 执行这里 得到一个执行过next的装饰器# g.__next__() # 我不在这调用 而是在装饰器里avg = g.send(10) # 开始向生成器里里传值avg = g.send(20)avg = g.send(30)print(avg) yield fromyield from : 从一个容器类型里取值,不需要一个个返回，而是集体返回接收123456789101112131415# python 3# 将结果按个返回def generator(): a = 'abcde' b = '12345' # 单个字符串返回 for i in a: yield i for i in b: yield ig = generator()# print(g.__next__())for i in g: print(i) 12345678910111213# yield from 将结果按个返回def generator(): a = 'abcde' l = [1,2,3,4,5] # 单个字符串返回 yield from a # 生成器函数语法 yield from lg = generator()for i in g: print(i)# yield from 从一个容器类型里取值,不需要一个个返回，而是集体返回接收 1234567# 将两个类型的数据list转化成同一个def generator(): yield from range(0,5) yield from 'abcde'l = list(generator())print(l) # [0, 1, 2, 3, 4, 'a', 'b', 'c', 'd', 'e'] 生成器表达式列表推导式我们先写一个获取鸡蛋的程序1234egg_list = []for i in range(10): egg_list.append('鸡蛋%s'%i)print(egg_list) 在这里循环获取得到一个鸡蛋筐(列表),里面存着10个鸡蛋,列表推导式的写法如下12345egg_list = ['鸡蛋%s' %i for i in range(10)]print(egg_list)# 1. for i in range(10) 循环# 2. 将想要的 放在for前面# 3. 用列表括起来 列表推导式可以做一些简单的循环工作,那么这个时候我们就想,列表生成后可是存在内存里的，那如果是大数据怎么办，很占用内存，占用内存我们就想到了 生成器 生成器推导式生成器表达式 与 列表表达式 的不同 括号不一样 返回的值不一样 列表推导式得到的还是一个列表，一次性得到所有的值，占用内存 生成器表达式几乎不占用内存，但是不能直接应用,需要遍历循环取值，程序应该更关心内存123456789101112131415161718192021# 生成器表达式g = (i for i in range(10))print(g) # &lt;generator object &lt;genexpr&gt; at 0x0000000001EB92B0&gt; 生成器for i in g: print(i)# 获取鸡蛋例子egg_g = ('鸡蛋%s'%i for i in range(10)) # 生成器表达式for i in egg_g: # 相当于老母鸡,然后下蛋 print(i) # 每个数字都取平方# g里面的代码一句话没执行，直到for循环取值__next__,for循环每走一次,上面的range10的循环才走一次g = (i*i for i in range(10))for i in g: print(i) #列表解析sum([i for i in range(100000000)])#内存占用大,机器容易卡死#生成器表达式sum(i for i in range(100000000))#几乎不占内存 迭代器与生成器总结可迭代对象: 拥有__iter__方法 特点：惰性运算 例如: range(), str, list, tuple, dict, set 迭代器Iterator： 拥有__iter__方法和__next__方法 例如: iter(range()), iter(str), iter(list), iter(tuple), iter(dict), iter(set), reversed(list_o), map(func,list_o), filter(func, list_o), file_o 生成器Generator：本质：迭代器，所以拥有__iter__方法和__next__方法特点：惰性运算, 开发者自定义 使用生成器的优点： 延迟计算，一次返回一个结果。也就是说，它不会一次生成所有的结果，这对于大数据量处理，将会非常有用。 提高代码可读性]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 包的使用]]></title>
    <url>%2F2019%2F03%2F05%2Fpackage%2F</url>
    <content type="text"><![CDATA[什么是包包就是把解决一类问题的模块放在同一个文件目录里，这个文件目录就叫做包包是一种通过使用‘.模块名’来组织python模块名称空间的方式。 包的导入方法 – import1234567891011121314151617soft/ ├── bin │ ├── __init__.py│ └── start.py ├── core │ ├── __init__.py│ └── Manage.py │ └── login() └── cook.py 最外层是soft软件工程目录 bin 和 core 是两个包 bin 下有着start.py 程序入口文件 core 下有着Manage模块,里面带有一个login( )方法 整个目录还有一个cook.py文件 在soft目录下 12345678910# 想要在start.py 使用 Manage的login()方法# 通过查看sys.path路径发现只能找到soft的bin目录,所以不能直接import core,需要从soft开始import sysprint(sys.path) # D:\\PycharmProjects\\Notes\\soft\\binimport soft.core.Managesoft.core.Manage.login() # login in Manageimport soft.core.Manage as MM.login() # login in Manage 关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如,soft.core.Manage但都必须遵循这个原则。 对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。 from … import …123456789import osimport sys# 把soft目录加入到sys.path里去，然后就可以直接找到coresys.path.append(os.path.dirname(os.getcwd()))print(sys.path) # 'D:\\PycharmProjects\\Notes\\soft'from core import ManageManage.login() # login in Manage 1234567891011# 在core包下的文件引入其他包中的方法或者配置# 记得由于我们执行开始是在start.py中执行,所以一定要在里面导入路径# settings 文件中加入 DB_PATH = 'D:\PycharmProjects\Notes\soft\db'# Manageimport osfrom conf import settingsdef login(): print('login in Manage') file_name = os.path.join(settings.DB_PATH,'info.log') with open(file_name,'w') as f: f.write('Hello') 需要注意的是from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误可以用import导入内置或者第三方模块（已经在sys.path中），但是要绝对避免使用import来导入自定义包的子模块(没有在sys.path中)，应该使用from… import …的绝对或者相对导入,且包的相对导入只能用from的形式。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 模块的使用]]></title>
    <url>%2F2019%2F03%2F04%2Fmodule%2F</url>
    <content type="text"><![CDATA[什么是模块在Python中，一个.py文件就被称之为一个模块 模块的调用模块一旦被调用，即相当于执行另外一个另外一个py文件中的代码，多次import导入同一个模块，只会执行一次。 模块的导入 – import1234# demo.pymoney = 100def read(): print('in read',money) 12345678# func.pyimport demodef read(): print('my read func')money = 200read() # 自己本地的print(demo.money) # 调用模块的demo.read() # 调用模块的 模块导入流程 先从sys.modules里查看是否已经被导入 如果没有被导入就依据sys.path路径去寻找模块 找到了就导入，没有找到就报错 创建这个模块的命名空间 执行文件,把文件中的名字都放到命名空间中 sys.modules会加入这个模块，当这个模块再被impoet时就不会被重复导入 123456import sysimport demo# sys.modules 是一个字典，内部包含模块名与模块对象的映射，该字典决定了导入模块时是否需要重新导入print(sys.modules.keys())# sys.path 是python的搜索模块的路径listprint(sys.path) 导入模块的顺序 内置模块 time,re 扩展模块 pip3安装的 django 自定义模块 demo 单独导入 – from…import…123from time import sleepsleep(1)print('hey') 123456from demo import read,moneymoney = 200def read(): print('my read',money)read() # my read 200print(money) # 200 查看结果1. 如果本地有read()方法则优先调用本地的。2. 即使导入了money这个变量也无法替代本地变量,会发生冲突。为什么要使用 from…import?1. import是导入了模块里面的所有名字 比较占用内存。2. 导入一个变量进来，占用的内容较少,只要不用重名即可。 1234# 导入多个名字from demo import money,readprint(money) # 100print(read) # &lt;function read at 0x0000000000B62620&gt; 1234567891011121314151617# 导入全部* 配合 __all__# 如果在模块中定义了__all__ 那么如果import * ，只有存在这个列表中的名字才能调用# import demo 不受这个约束# demo__all__ = ['money','read'] # 只和 from demo import * 能配合起来money = 100def read(): print('in read',money)def read2(): print('in read2',money)# funcfrom demo import *print(money) # 100read() # in read 100read2() # NameError: name 'read2' is not defined 把模块当做脚本执行我们可以通过模块的全局变量name来查看模块名：12345# demo2print(__name__) # __main__# funcimport demo2 # demo2 当我在文件中import demo2的时候,demo2中的print(__name__)执行返回的是demo2 当我在demo模块中print(__name__)的时候返回的是 __main__ 在哪个页面页面上点的run 在哪个页面上就是__main__ 如果不在本页面上执行,在其他页面上调用模块名导入执行,那么就返回模块名 if name == ‘main‘: 作用:用来控制.py文件在不同的应用场景下执行不同的逻辑123456789101112131415# demo2def login(): print('正在执行登录程序')if __name__ == '__main__': print('in demo2.py') # in demo2.py ret = login() # 正在执行登录程序 print(ret) # None # funcimport demo2ret = demo2.login() # 正在执行登录程序print(ret) # None# 这样就符合了：模块导入的时候什么都不执行,所有想做的都放在模块里面去,在执行程序的时候就不会受影响，也能调用模块中想要的名字]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Readme]]></title>
    <url>%2F2019%2F03%2F04%2FReadme%2F</url>
    <content type="text"></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
