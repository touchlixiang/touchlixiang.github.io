<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内置函数]]></title>
    <url>%2F2019%2F03%2F19%2Ffunction%2F</url>
    <content type="text"><![CDATA[内置函数什么是内置函数? 就是python给你提供的. 拿来直接用的函数,比如print., input等等.截止 到python版本3.6.2 python一共提供了68个内置函数. 有一些我们已经用过了.有一些还没有用过. 还有一些需要学完了面向对象才能继续学习的. 作用域相关(2) locals() 和 globals() 基于字典的形式获取局部变量和全局变量12print(locals()) # 返回本地作用域中的所有名字print(globals()) # 返回全局作用域中的所有名字 迭代器/生成器相关(3) range(),next() 和 iter()Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。1234567# range# range(10)# range(1,11)# range(1,11,2) # 步长取值print('__iter__' in dir(range)) # True 可迭代的print('__next__' in dir(range)) # False 不是迭代器print('__next__' in dir(iter(range(1,11,2)))) # True next(迭代器),迭代器向下执行一次,内部实际上调用迭代器.__next__()方法iter(可迭代的),用来生成一个迭代器12345678910# next 和 iterl = [1,2,3,4,5]it = iter(l) # 转成迭代器 print(type(it)) # &lt;class 'list_iterator'&gt;while 1: try: print(next(it)) except StopIteration: # 遇到StopIteration就退出循环 break 其他(12) 查看内置属性(1) dir() 默认查看全局空间内的属性，也接受一个参数，查看这个参数内的方法或变量12print(dir()) # 获得当前模块的属性列表print(dir([])) # 查看列表的方法 调用相关(1) callable() callable 用来检查一个对象是否可被调用对于函数、方法、lambda 函式、 类以及实现了 __call__ 方法的类实例, 它都返回 True。123a = 1print(callable(a)) # Falseprint(callable(print)) # True 帮助(1) help() 用于查看函数或模块用途的详细说明在控制台执行help()进入帮助模式。可以随意输入变量或者变量的类型。输入q退出或者直接执行help(o)，o是参数，查看和变量o有关的操作。。。1help(str) 模块相关(1) import() 导入模块1import time 文件操作相关(1) open() 打开一个文件，返回一个文件操作符(文件句柄)操作文件的模式有r,w,a,r+,w+,a+ 共6种，每一种方式都可以用二进制的形式操作(rb,wb,ab,rb+,wb+,ab+)可以用encoding指定编码.123f = open('01 内置函数.py')print(f.writable()) # 判断当前文件是否可写print(f.readable()) # 判断当前文件是否可读 内存相关(2) id() id()函数用于获取对象的内存地址。123# id(o) o是参数，返回一个变量的内存地址a = 100print(id(a)) # 1497027344 hash() 用于获取取一个对象（字符串或者数值等）的哈希值。hash() 函数可以应用于数字、字符串和对象，不能直接应用于 list、set、dictionary。获取到对象的哈希值(int, str, bool, tuple) hash函数会根据一个内部的算法对当前可hash变量进行处理，返回一个int数字。 每一次执行程序，内容相同的变量hash值在这一次执行过程中不会发生改变。1234print(hash(12345)) # 12345print(hash('abcde')) # -5832084034581495945print(hash(('a','b'))) # -3079515087831999849# print(hash(['a',1,'b',2])) # 报错:TypeError: unhashable type: 'list' 不可哈希 输入输出(2) input() 获取用户输入12content = input('&gt;&gt;&gt;')print(type(content),content) # input得到的是字符串类型 print() 打印输出12345# 关键字传参 end默认为'\n'，指定不是回车即可# 这就是我们为什么使用print的时候会出现换行,end的值修改成了空字符串print('我们的祖国是花园\n',end='')print('我们的祖国是花园\n',end='')print('我们的祖国是花园\n') 123# sep 打印多个值之间的分隔符，默认为空格print(1,2,3,4,5) # 1 2 3 4 5 多个值之间空格隔开print(1,2,3,4,5,sep='|') # 1|2|3|4|5 指定分隔符 12345# file: 默认是输出到屏幕，如果设置为文件句柄，输出到文件# flush: 立即把内容输出到流文件，不作缓存f = open('file','w')print('aaa',file=f,flush=True)f.close() 字符串类型代码的执行(3) eval() eval() 将字符串类型的代码执行并返回结果1print(eval('1+2+3+4')) # 10 有返回值 ——有结果的简单计算 exec() exec() 将自字符串类型的代码执行12345print(exec('1+2+3+4')) # None 没有返回值 ——简单的流程控制# exec 和eval都可以执行 字符串类型的代码# 区别是eval有返回值，exec没有# eval只能用在明确知道要执行的代码 compile() 将字符串类型的代码编译。代码对象能够通过exec语句来执行或者eval()进行求值。1234#流程语句使用exec# code1 = 'for i in range(0,10): print (i)'# compile1 = compile(code1,'','exec')# exec (compile1) 1234#简单求值表达式用eval# code2 = '1 + 2 + 3 + 4'# compile2 = compile(code2,'','eval')# print(eval(compile2)) 12345#交互语句用singlecode3 = 'name = input("please input your name:")'compile3 = compile(code3,'','single')exec(compile3)# print(name) # leo 执行exec后就存在name]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器面试题]]></title>
    <url>%2F2019%2F03%2F18%2Fcase-generator%2F</url>
    <content type="text"><![CDATA[生成器面试题12345678910111213141516171819def demo(): # 生成器函数 for i in range(4): yield ig=demo() # 生成器# 生成器表达式g1=(i for i in g) # 没执行g2=(i for i in g1)# 数据类型强转print(list(g1)) # [0, 1, 2, 3] # 执行了,g1生成器找g取值print(list(g2)) # [] # g2找g1拿值，g1已经没有值了.所以是空,把g1注释掉,g2就有值了# 一个生成器里面的能用只能取一次,你不找他要，他也不会给你# g1=(i for i in g) 没干活，因为他返回了个 生成器#def g1():# for i in g:# yield i 123456789101112131415161718192021222324252627def add(n,i): return n+idef test(): for i in range(4): yield ig=test()for n in [1,10]: g=(add(n,i) for i in g) # 生成器表达式# 当遇见这种问题的时候 先将循拆开# for循环套生成器表达式# n = 1# g=(add(n,i) for i in g) # test()# n = 10# g=(add(n,i) for i in g) # (add(n,i) for i in g)# 2 带入方程# g=(add(n,i) for i in test())# g=(add(n,i) for i in (add(10,i) for i in test()))# n = 10# g=(add(n,i) for i in (add(10,(0,1,2,3))# n = 10# g=(add(10,i) for i in (10,11,12,13))# 20,21,22,23print(list(g)) # 开始执行 12345678910111213141516171819202122def add(n,i): return n+idef test(): for i in range(4): yield ig=test()for n in [1,10,5]: g=(add(n,i) for i in g) # 生成器表达式# n = 1# g=(add(n,i) for i in test())# n = 10# g=(add(n,i) for i in (add(n,i) for i in test()))# n = 5# g=(add(n,i) for i in (add(n,i) for i in (add(n,i) for i in test())))# g=(add(n,i) for i in (add(n,i) for i in (add(n,i) for i in (0,1,2,3))))# g=(add(n,i) for i in (add(n,i) for i in (5,6,7,8)))# g=(add(n,i) for i in (10,11,12,13)# 15,16,17,18print(list(g)) # 开始执行]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种推导式]]></title>
    <url>%2F2019%2F03%2F15%2Fcomprehensions%2F</url>
    <content type="text"><![CDATA[推导式的套路: 新的列表 = [ 每一个元素或者是和元素相关的操作 for 元素 in 可迭代数据类型 ] # 遍历之后挨个处理 新的列表 = [ 满足条件的元素相关的操作 for 元素 in 可迭代数据类型 if 元素相关的条件 ] # 筛选功能 列表推导式12345678910111213141516171819202122# 例一：30以内所有能被3整除的数l = [ i for i in range(30) if i % 3 == 0 ]print(l)# 例二：30以内所有能被3整除的数的平方l = [ i**2 for i in range(30) if i % 3 == 0 ]print(l)# 例三:找到嵌套列表中名字含有两个‘e’的所有名字names = [['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe'], ['Alice', 'Jill', 'Ana', 'Wendy', 'Jennifer', 'Sherry', 'Eva']]# 常规循环#for l in names:# for name in l:# if name.count('e') &gt;= 2:# print(name)# 二维列表# 注意遍历顺序，这是实现的关键l = [name for l in names for name in l if name.count('e') &gt;= 2]print(l) 字典推导式12345678910111213141516171819# 字典推导式# 例一：将一个字典的key和value对调mcase = &#123;'a': 10, 'b': 34&#125;# 常规循环# for k in mcase:# mcase[k] : k # v : k# print(mcase)mcase = &#123;mcase[k]:k for k in mcase&#125;print(mcase)# 例二：合并大小写对应的value值，将k统一成小写# 所有的推导式都从for开始看mcase = &#123;'a': 10, 'b': 34, 'A': 7, 'Z': 3&#125;# &#123;'a':10+7,'b':34,'z':3&#125;mcase_frequency = &#123;k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()&#125;# 拿到所有key# key值就是要小写k.lower():# mcase.get(k.lower(), 0)没有小写的就默认写一个0 + mcase.get(k.upper(), 0) 相当于小写+大写的值,没有就给0print(mcase_frequency) 集合推导式12345# 集合推导式 可以替重# &#123;&#125;# 例：计算列表中每个值的平方，自带去重功能squared = &#123;x**2 for x in [1, -1, 2]&#125;print(squared) # -1的平方和1的平方一样 所以去重之后2个结果，如果是列表就不会自动去重 总结各种推导式:生成器 列表 字典 集合 遍历 筛选 带if 优点 推导式能让你的代码更简洁， 可读性提高 惰性运算: 懒 不去找他要值不会执行，要一个执行一个 生成器(自己写的，可见)和迭代器（不可见的，python提供）特点 同一个迭代器,从头到尾取值只能取一次 不找他要值的时候不干活 练习1234567891011121314151617# 例1: 过滤掉长度小于3的字符串列表，并将剩下的转换成大写字母names = ['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe']new_l = [name.upper() for name in names if len(name) &gt; 3]print(new_l)# 例2: 求(x,y)其中x是0-5之间的偶数，y是0-5之间的奇数组成的元祖列表l1 = [(x,y) for x in range(5) if x%2==0 for y in range(5) if y %2==1]l2 = [(x,y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]print(l1)print(l2)# 求M中3,6,9组成的列表M = [[1,2,3],[4,5,6],[7,8,9]]# for i in M:# print(i[2])l3 = [row[2] for row in M]print(l3)]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>列表推导式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 装饰器]]></title>
    <url>%2F2019%2F03%2F13%2Fdecorator%2F</url>
    <content type="text"><![CDATA[简单的装饰器使用比如现在公司有一个需求，每个函数都要计算运行时间，我们可以调用time模块实现一个简单的计算执行时间的方法 1234567891011import time# 统计每个函数的执行时间 1def func(): start_time = time.time() print('func 1') time.sleep(3) now_time = time.time() return now_time - start_timeret = func() # func 1print(ret) # 3.000171661376953 那如果要是有200多个函数呢，难道要一个个加入，然后在一个个删除？我们想到计算时间可以单独写一个函数去调用。123456789101112# 调用统计时间函数def timmer(f): start_time = time.time() f() end_time = time.time() print(end_time - start_time)def func(): time.sleep(3) print('func 1')timmer(func) 这样以后的200个函数都要使用timmer去调用执行么？也是不合理的，应该是func方法来调用时间函数，比较合理。 装饰器的形成过程1234567891011121314151617181920# 我们想要做到的:# 1 不想修改函数的调用方式 但是还想再原来的函数前后添加功能# 2 timmer就是一个装饰器函数，只是对一个函数 有一些装饰作用def func(): time.sleep(3) print('func 1')# 调用统计时间函数# 闭包 内部函数inner,调用了外部变量f,f是传进来的def timmer(f): # 装饰器函数 def inner(): start_time = time.time() f() # 被装饰的函数 end_time = time.time() print(end_time - start_time) return innerfunc = timmer(func)func() 运行过程流程图: 原来的函数为func 最后我还是要调用func 中间增加的计时功能timmer 通过func = timmer(func) 和 闭包函数 来进行修饰 最终通过闭包函数来返回内部函数 交给 外部的func接收，接收的变量还是原本func的方法 最后执行外部的func()，他会自动去找装饰函数inner(),再去找到原本被装饰的函数func() 总结:装饰器的本质：一个闭包函数装饰器的功能：在不修改原函数及其调用方式的情况下对原函数功能进行扩展装饰器的意义： 装饰器既没有改变函数的调用方式，又在函数的前后增加了装饰功能 开放封闭原则开放: 对扩展是开放的,任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。 封闭: 对修改是封闭的,因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对其进行了修改，很有可能影响其他已经在使用该函数的用户。 装饰器完美的遵循了这个开放封闭原则 语法糖@装饰器函数 == 重新定义被装饰函数=装饰器函数（被装饰函数）12345678910111213141516171819import timedef timmer(f): # 装饰器函数 def inner(): start_time = time.time() f() # 被装饰的函数 end_time = time.time() print(end_time - start_time) return inner# 语法糖 @timmer 让代码更好看 更便捷# 在被装饰的函数上面贴着加上 @装饰器函数名 # 就相当于写了func = timmer(func)@timmerdef func(): time.sleep(3) print('func 1')# func = timmer(func)func() 装饰带返回值的函数的装饰器12345678910111213141516171819202122import timedef timmer(f): # 装饰器函数 def inner(): start_time = time.time() ret = f() # 被装饰的函数 带有返回值 end_time = time.time() print(end_time - start_time) return ret # 返回被装饰的函数的返回值 return inner@timmerdef func(): time.sleep(3) print('func 1') return '新年好' # 被装饰的函数的返回值# func = timmer(func)ret = func()print(ret)# 因为现在的func不是原来的func 而是inner ，所有要对inner中增加返回值# 现在的func就是inner,ret接收的事inner的返回值 装饰带一个参数的函数12345678910111213def wrapper(func): def inner(name): ret = func(name) return ret return inner@wrapper # func = wrapper(func)def func(name): return '新年好,%s'%nameret = func('leo')print(ret) 接收万能参数装饰器1234567891011121314151617def wrapper(func): def inner(*args,**kwargs): # print('函数被装饰之前要做的事') print(*args) # leo python print(kwargs) # &#123;'age': 30&#125; print(kwargs['age']) # 30 ret = func(*args,**kwargs) # print('函数被装饰之前要做的事') return ret return inner@wrapperdef func(name,course,age): return '大家好,我是%s,今年%d,现在正在学习%s'%(name,age,course)ret = func('leo','python',age=30)print(ret) # 大家好,我是leo,今年30,现在正在学习python 装饰器的固定格式123456789101112131415161718import time# 单纯就叫装饰器的时候 -- wrapperdef wrapper(f): # 装饰器函数,f是被装饰的函数,装饰器函数里面的参数永远是被装饰的函数 def inner(*args,**kwargs): # 内部函数inner,*args,**kwargs动态参数原封不动的传给被装饰的函数 # 被装饰函数执行之前要做的事 ret = f(*args,**kwargs) # 被装饰的函数,执行完成后，给外面返回值 # 被装饰函数执行之后要做的事 return ret return inner # 对应内部函数inner 不加括号执行@wrapper # func = timmer(func)def func(a,b): time.sleep(2) print('func1',a,b) return '新年好'ret = func(1,2)print(ret) 1234567891011def wrapper(func): # func = qqxing def inner(*args,**kwargs): ret = func(*args,**kwargs) # 被装饰的函数 qqxing return ret return inner@wrapper # qqxing = wrapper(qqxing)def qqxing(a,b): print(123)ret = qqxing(1,2) # 实际上执行的是inner() 装饰器的固定格式 - wraps首先先了解函数的name和doc方法:函数名.__name__ = 查看字符串格式的函数名函数名.__doc__ = 查看函数注释123456789def wahaha(): ''' 一个打印娃哈哈的函数 :return: ''' print('娃哈哈')print(wahaha.__name__) # 查看字符串格式的函数名print(wahaha.__doc__) # 查看函数注释 在执行使用装饰器之后，我们打印函数的name发现是装饰器的函数名称了，这个时候就需要使用wraps来解决。12345678910111213141516171819202122232425from functools import wrapsdef wrapper(func): # func = holiday @wraps(func) # 装饰inner函数 def inner(*args,**kwargs): print('在被装饰的函数执行前做的事') ret = func(*args,**kwargs) print('在被装饰的函数执行后做的事') return ret return inner@wrapper # holiday = wrapper(holiday)def holiday(day): ''' 这是一个放假通知 :param day: :return: ''' return '还有%s天放假'%dayprint(holiday.__name__) # inner...因为现在的holiday已经是inner了，由于之前说装饰器最好不要影响被装饰的函数，需要用wraps装饰inner函数,才可以正常显示回去print(holiday.__doc__)ret = holiday(3) # innerprint(ret)# wraps并不影响wrapper装饰器的使用 带参数的装饰器比如现在有500个函数,都使用装饰器，那么怎么一次性的去控制500个装饰器的增加和删除，怎么办？我们可以使用带参数的参数器，通过标志位参数去控制装饰器是否执行。带参数的装饰器，也就是三层装饰器，在外部多一次调用传入状态标记。123456789101112131415161718192021222324252627282930import timeFLAGE = True # 标识位，True执行，Fales不执行def timmer_out(flag): # 在原有装饰器之外再来一层 def timmer(func): def inner(*args,**kwargs): if flag: # 如果flag = True 那么我就走装饰器，否则我就只运行被装饰的函数 start_time = time.time() ret = func(*args,**kwargs) end_time = time.time() print(end_time - start_time) return ret else: ret = func(*args, **kwargs) return ret return inner return timmer# timmer = timmer_out(FLAGE)@timmer_out(FLAGE)def wahaha(): time.sleep(2) print('wahaha')@timmer_out(FLAGE)def qqxing(): time.sleep(1) print('qqxing')ret = wahaha()ret = qqxing() 多个装饰器装饰一个函数多个装饰器执行的过程有点像套娃，装饰器在后的先执行装饰1234567891011121314151617181920212223242526272829303132def wrapper1(func): # f def inner1(): print('wrapper1装饰器 start') # 3 func() # 执行f # 4 print('wrapper1装饰器 end') # 5 return inner1def wrapper2(func): # inner1 def inner2(): print('wrapper2装饰器 start') # 1 先执行他 func() # inner1() # 2 print('wrapper2装饰器 end') # 6 return inner2# 先看装饰器执行先后@wrapper2 # f = wrapper2(f)==&gt; f = inner1 ==&gt; inner1 = wrapper2(inner1) ==&gt; inner2 ，传进去的是inner1,最后返回得到的是inner2@wrapper1 # f = wrapper1(f) = inner1def f(): print('in f')f() # ==&gt; 调用开始现在是 inner2# wrapper2装饰器 start# wrapper1装饰器 start# in f# wrapper1装饰器 end# wrapper2装饰器 end# 1. 先看装饰器执行先后，wrapper2没有找到要被修饰的函数，所以现在wrapper1# 2. f = wrapper1(f) = inner1# 3. # f(下面赢变成inner1) ==&gt; inner1 = wrapper2(inner1) = inner2，但是传进去的是inner1, 有时候会遇见两个需求: 记录用户的登录情况 记录函数的执行时间仔细思考下先后执行顺序:先登录成功之后 才能开始执行程序记录函数的执行时间]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 迭代器]]></title>
    <url>%2F2019%2F03%2F11%2Fiterator%2F</url>
    <content type="text"><![CDATA[for循环是如何工作的当我们拥有一个列表 l = [1,2,3,4,5],想取列表中的内容，有几种方式？ 1234# 1 通过索引下标和切片取值l = [1,2,3,4,5]print(l[0]) # 1print(l[0:2]) # [1, 2] 123# 2 通过for循环取值for i in l: print(i) 他们的区别是，使用索引取值可以取到任意位置的值，前提是我知道这个值在什么位置，而for循环是取到每一个值，不需要关心这个值在什么位置，也不能跳过任何一个值去取其他位置的值，我们可以称作循环遍历。那么for循环到底是怎么工作的呢？ 都有哪些数据类型可以被for循环123456789101112131415for s in 'abcde': print(s) # 返回字符串中每一个字符 a b c d edic = &#123;'name':'leo','age':26&#125;for key in dic: print(key) # 默认返回字典中的键 name , agefor value in dic.values(): print(value) # 返回字典中的值 leo,26 for k,v in dic.items(): print(k,v) # 返回字典中的键值对 name leo age 26for i in 12345: print(i) # TypeError: 'int' object is not iterable 当我们循环数字类型的时候报错了，说int类型不是 iterable（可迭代的） 迭代和可迭代协议通过对数字类型的报错，不可被for循环的数据类型会报错 不是一个可迭代的，那么是不是说可迭代的数据类型就可以被for循环，如何判断数据类型是否可以被迭代？123456789101112131415161718from collections import Iterablel = [1,2,3,4]t = (1,2,3,4)d = &#123;1:2,3:4&#125;s = &#123;1,2,3,4&#125;num = 123money = 10.10print(isinstance(l,Iterable)) # Trueprint(isinstance(t,Iterable)) # Trueprint(isinstance(d,Iterable)) # Trueprint(isinstance(s,Iterable)) # Trueprint(isinstance(num,Iterable)) # Falseprint(isinstance(money,Iterable)) # False# 下面这三种也是可以被循环遍历# f = open() # range()# enumerate 枚举 可以将某个数据集内的数据“一个挨着一个的取出来”，就叫做迭代总结出一条规律来：能被for循环的就是“可迭代的”。但是如果正着想，for怎么知道谁是可迭代的呢？为什么能被for循环？ 123456789101112131415# 为什么能够被循环# dir 可以返回这个数据类型的拥有的所有方法# 查看列表、字典、字符串、和range的双下方法 有什么共同方法# 求交集ret = set(dir([]))&amp;set(dir(&#123;&#125;))&amp;set(dir(''))&amp;set(dir(range(10)))print(ret) # 我们找一个和iterable比较相似的方法， '__iter__',# 我们再来看看无法被迭代的数据类型 有没有__iter__方法print('__iter__' in dir(int)) # Falseprint('__iter__' in dir(bool)) # Falseprint('__iter__' in dir(list)) # Trueprint('__iter__' in dir(dict)) # Trueprint('__iter__' in dir(set)) # Trueprint('__iter__' in dir(tuple)) # Trueprint('__iter__' in dir(range(10))) # Trueprint('__iter__' in dir(enumerate([]))) # True 再总结出一条新的规律: 能被for循环的就是“可迭代的”,只要是能被for循环的数据类型，就一定拥有__iter__双下方法 双下方法__iter__做了什么123456789101112131415161718print([].__iter__()) # &lt;list_iterator object at 0x0000000002308940&gt; 迭代器 iterator# [].__iter__() 得到了一个list_iterator# 那么迭代器有什么作用呢？让我们来看看列表list和转换成列表_迭代器所有方法的差集print(set(dir([].__iter__()))- set(dir([])) ) # &#123;'__setstate__', '__length_hint__', '__next__'&#125;# 迭代器多出来的这三个方法的作用:#__length_hint__ 获取迭代器中元素的长度# print([1,2,3,4,5].__iter__().__length_hint__()) # 5 元素个数# __setstate__ 可以指定从其他位置取值# __next__ 一个一个的取值# 迭代器取值l = [1,2,3] # 列表iterator = l.__iter__() # iterator现在是一个迭代器,他内部有.__next__()方法print(iterator.__next__()) # 1print(iterator.__next__()) # 2print(iterator.__next__()) # 3print(iterator.__next__()) # 报错 StopIteration 通过上面的例子我们发现,当一个可迭代的对象调用了iter()方法会生成一个 iterator (迭代器) 迭代器中含有_next__()方法，他可以一个一个的取值,如果我们一直取next取到迭代器里已经没有元素了，就会抛出一个异常StopIteration，告诉我们，列表中已经没有有效的元素了 可迭代协议 与 迭代器协议根据上面的例子我们总结出以下概念： 能被for循环的数据类型都是 可迭代的 (iterable) 当这个数据类型调用.__iter__()方法会生成一个 迭代器(iterator) 迭代器.next()可以一个一个的取值 for循环其实就是在使用迭代器，只有是可迭代对象或者迭代器，才能用for循环 for循环的本质就是迭代器 12345for i in l: pass # 首先会去找l.__iter__() ==&gt; iterator = l.__iter__() # i = iterator.__next__() # 当没有值的时候 自动停止结束 也不会报错 12345# 模拟for循环l = [1,2,3,4,5]iterator = l.__iter__() # 变成一个迭代器while True: print(iterator.__next__()) 可迭代协议: 只要含有__iter__()方法的都是可迭代的迭代器协议: 内部含有__next__()方法和__iter__()方法的就是迭代器 可迭代的不一定就是迭代器 迭代器：内部有__iter__和__next__方法 ，所以他一定是可迭代的 可迭代的不一定是迭代器，要看有没有__next__方法12345678910from collections import Iterablefrom collections import Iteratorprint(isinstance([],Iterable)) # 可迭代的 # Trueprint(isinstance([],Iterator)) # 迭代器 # False ,list是可迭代的，但不是一个迭代器print('__iter__' in dir(range(12))) # Trueprint('__next__' in dir(range(12))) # Falseprint(isinstance(range(100000000),Iterable)) # Trueprint(isinstance(range(100000000),Iterator)) # False , range是可迭代器，但不是一个迭代器，因为它没有__next__()方法 迭代器的好处 迭代器会从容器类型中 一个一个的取值，会把所有的值都取到。 它可以节省内存空间,迭代器并不会在内存中再占用一大块内存，而是随着循环每次生成一个,或者每次next()每次给我一个12# print(range(10000000)) # 很快，但是并不会在内存中真正的生成数据# print(list(range(10000000))) # 强制转列表会导致崩溃,list是真正存在并存储在内存里 ，range是要一个给一个]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python三大利器 — 生成器]]></title>
    <url>%2F2019%2F03%2F11%2Fgenerator%2F</url>
    <content type="text"><![CDATA[什么是生成器之前我们学习过迭代器，它的好处之一就是可以节省能存，在某些情况下，我们需要自己定义一个方法去实现迭代器功能，这个方法就是生成器。在Python中生成器又分成两类: 生成器函数 生成器表达式 生成器函数生成器Generator： 本质：迭代器(所以自带了iter方法和next方法，不需要我们去实现) 特点：惰性运算,开发者自定义 生成器函数：一个包含yield关键字的函数就是一个生成器函数。yield可以为我们从函数中返回值，但是yield又不同于return，return的执行意味着程序的结束，调用生成器函数不会得到返回的具体的值，而是得到一个可迭代的对象。每一次获取这个可迭代对象的值，就能推动函数的执行，获取新的返回值。直到函数执行结束。 1234567891011121314# 只要含有yield关键字的函数都是生成器函数# yield 必须写在函数里，且无法和return共用def generator(): a = 1 yield a b = 2 yield b g = generator() # 得到一个“生成器”作为返回值print(g) # &lt;generator object generator at 0x0000000001E9A308&gt; generator 生成器# g.__next__ # 生成器带有__next__方法和__iter__方法# g.__iter__ # 生成器是迭代器 用next方法取值print(g.__next__()) # 1print(g.__next__()) # 2 运行过程总结： 由于函数中有yield，所以现在内存中会有一个生成器函数 generator g = generator() 发生了函数调用，生成器函数的特点：函数中的代码不执行 g 得到了一个生成器 生成器里面即有iter方法也有next方法，说明它其实是一个迭代器 生成器就可以使用next方法取值,这时程序才第一次触发了生成器里面的代码 yield 不会结束函数，return会直接结束 生成器函数的使用生成器的最大好处就是不会在内存中一次性的生成所有数据1234567891011121314151617181920212223def factoy(): for i in range(100): yield '生成%s次'%ig = factoy()# __next__() ,一次一次的提取print(g.__next__())print(g.__next__())print(g.__next__())# for循环遍历提取for i in g: print(i)# 取50次g = factoy()count = 0for i in g: count += 1 print(i) if count &gt; 50: breakprint('*****',g.__next__()) # ***** 生成51次 可以继续从生成器中取值 列表为什么不能继续取值123456789101112131415161718192021# 列表是可迭代的,并不是一个迭代器,在两次for循环的时候会产生两个迭代器# for循环自动将可迭代的转换成迭代器l = [1,2,3,4,5]for i in l: print(i) # 1,2 if i == 2: breakfor i in l: print(i) # 1,2,3,4,5 # 获取两个生成器l = [1,2,3,4,5]def generator(): for i in l: yield i g = generator()g1 = generator()print(g,g1) # &lt;generator object generator at 0x0000000001F7A150&gt; &lt;generator object generator at 0x0000000001F7A200&gt;print(g.__next__()) # 1print(g1.__next__()) # 1 拿到两个生成器，自己执行自己的 监听文件的输入123456789101112def tail(filename): f = open(filename, encoding='utf-8') while True: line = f.readline() # 每次读一行 if line.strip(): # 不为空就打印 # print('****',line.strip('\n')) yield line.strip() # 返回这行g = tail('file') # 获取生成器for i in g: if 'python' in i: print('*****',i,'*****') # 可以对这个结果做任何操作了,用生成器实现就可以想要的结果 爬虫时的使用123456789101112131415161718192021222324252627def parse_one_page(html): rule = re.compile( '&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?' 'releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;' ,re.S) items = re.findall(rule, html) # 通过findall方法根据规则得到html文本 # print(items) for item in items: yield &#123; 'index':item[0], 'image':item[1], 'title':item[2].strip(), 'actor':item[3].strip(), 'time':item[4].strip(), 'score':item[5].strip() + item[6].strip() &#125; # 循环整个html文本列表,每一条数据都生成yield返回一个字典，里面拼接成想要的数据类型# 使用的时候传递一个页面进去，循环调用生成器，item里就是生成的每条数据def main(offset): url = 'https://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) # print(html) for item in parse_one_page(html): print(item) write_to_file(item) 生成器函数的进阶数据类型的强制转换 — 列表(生成器)1234567891011121314def generator(): for i in range(20): yield 'wahaha%s'%ig = generator()# list(g)# list是列表，代表将g生成器直接转换成列表，列表中的每一个值都是实际存在的# 一个一个从生成器里取出来，全部取完放入列表，列表会在内存中生成print(list(g))# ['wahaha0', 'wahaha1', 'wahaha2', 'wahaha3'...'wahaha19']# 从生成器取值的几个方法： # next # for # 数据类型的强制转换 (不推荐，占用内存) 123456789101112def generator(): print(123) yield 1 print(456) yield 2 print(789)g = generator() # 得到一个生成器ret = g.__next__()print('***',ret) # 先打印123，然后拿到yield返回的1print('***',ret)print('***',ret) # 执行了789,由于后面没有yield,会报错StopIteration 生成器函数 — send123456789101112131415161718192021222324def generator(): print(123) send_msg = yield 1 print('======',send_msg) yield 2g = generator()ret = g.__next__()print('***',ret)ret = g.send('send_hello')print('***',ret)# 123# *** 1# ====== send_hello# *** 2# send用法总结# 1. send的获取下一个值的效果与next基本一致# 2. 只是在获取下一个值的时候给上一个yield的位置,传递一个数据# 使用send的注意事项# 1. 第一次使用生成器的时候,必须使用next获取下一个值# 2. 最后一个yield 不能接收外部的值,但是可以在接收arg=yield 2...最后返回一个空yield send实例 — 计算移动平均值123456789101112131415161718192021# 接收一次值计算平均值# 移动平均值# num: 10 20 30# avg: 10 15 20# 公式: avg = num / countdef avg_generator(): sum = 0 count = 0 avg = 0 num = yield # 第一次返回空，为了后面send传值(num)进来,10 sum += num # 总数有更新 10 count += 1 # 次数更新 avg = sum / count yield avg # send执行到这avg_g = avg_generator()avg_g.__next__() # 使用send第一次必须next，得到空avg1 = avg_g.send(10) # 传值(num)10进去print(avg1) 那么如何多次计算呢，需要加上循环123456789101112131415161718192021222324252627# 移动平均值# num: 10 20 30# avg: 10 15 20# 公式: avg = num / countdef avg_generator(): sum = 0 count = 0 avg = 0 while 1: # num = yield # 第一次返回空，为了后面send传值(num)进来,10 num = yield avg # 第一次的avg = 0 ，num = 传值 sum += num # 总数有更新 10 count += 1 # 次数更新 avg = sum / countavg_g = avg_generator()avg_g.__next__() # 使用send第一次必须next，得到空avg = avg_g.send(10) # 传值(num)10进去avg = avg_g.send(20)avg = avg_g.send(30)print(avg)# 每次计算方法:# 如果我加上while循环,现在我有两个yield,第一次结束到yield avg,第二次执行什么？# 如果执行next num = yield 相当于 num = 0# 下面再用一次send 传值20 再返回打印 计算移动平均值(2)_预激协程的装饰器123456789101112131415161718192021222324252627# 计算移动平均值# 用装饰器 激活__next__()def init(func): def inner(*args,**kwargs): g = func(*args,**kwargs) # g = generator() 拿到装饰器 g.__next__() # 执行__next__() return g # 返回装饰器 return inner@init # avg_generator = init(avg_generator) ==&gt; innerdef avg_generator(): sum = 0 count = 0 avg = 0 while True: # num = yield num = yield avg # num = 10,20,30 sum += num # sum = 10,30,60 count += 1 # count = 1,2,3 avg = sum / count # avg = 10,15,20g = avg_generator() # inner() # 执行这里 得到一个执行过next的装饰器# g.__next__() # 我不在这调用 而是在装饰器里avg = g.send(10) # 开始向生成器里里传值avg = g.send(20)avg = g.send(30)print(avg) yield fromyield from : 从一个容器类型里取值,不需要一个个返回，而是集体返回接收123456789101112131415# python 3# 将结果按个返回def generator(): a = 'abcde' b = '12345' # 单个字符串返回 for i in a: yield i for i in b: yield ig = generator()# print(g.__next__())for i in g: print(i) 12345678910111213# yield from 将结果按个返回def generator(): a = 'abcde' l = [1,2,3,4,5] # 单个字符串返回 yield from a # 生成器函数语法 yield from lg = generator()for i in g: print(i)# yield from 从一个容器类型里取值,不需要一个个返回，而是集体返回接收 1234567# 将两个类型的数据list转化成同一个def generator(): yield from range(0,5) yield from 'abcde'l = list(generator())print(l) # [0, 1, 2, 3, 4, 'a', 'b', 'c', 'd', 'e'] 生成器表达式列表推导式我们先写一个获取鸡蛋的程序1234egg_list = []for i in range(10): egg_list.append('鸡蛋%s'%i)print(egg_list) 在这里循环获取得到一个鸡蛋筐(列表),里面存着10个鸡蛋,列表推导式的写法如下12345egg_list = ['鸡蛋%s' %i for i in range(10)]print(egg_list)# 1. for i in range(10) 循环# 2. 将想要的 放在for前面# 3. 用列表括起来 列表推导式可以做一些简单的循环工作,那么这个时候我们就想,列表生成后可是存在内存里的，那如果是大数据怎么办，很占用内存，占用内存我们就想到了 生成器 生成器推导式生成器表达式 与 列表表达式 的不同 括号不一样 返回的值不一样 列表推导式得到的还是一个列表，一次性得到所有的值，占用内存 生成器表达式几乎不占用内存，但是不能直接应用,需要遍历循环取值，程序应该更关心内存123456789101112131415161718192021# 生成器表达式g = (i for i in range(10))print(g) # &lt;generator object &lt;genexpr&gt; at 0x0000000001EB92B0&gt; 生成器for i in g: print(i)# 获取鸡蛋例子egg_g = ('鸡蛋%s'%i for i in range(10)) # 生成器表达式for i in egg_g: # 相当于老母鸡,然后下蛋 print(i) # 每个数字都取平方# g里面的代码一句话没执行，直到for循环取值__next__,for循环每走一次,上面的range10的循环才走一次g = (i*i for i in range(10))for i in g: print(i) #列表解析sum([i for i in range(100000000)])#内存占用大,机器容易卡死#生成器表达式sum(i for i in range(100000000))#几乎不占内存 迭代器与生成器总结可迭代对象: 拥有__iter__方法 特点：惰性运算 例如: range(), str, list, tuple, dict, set 迭代器Iterator： 拥有__iter__方法和__next__方法 例如: iter(range()), iter(str), iter(list), iter(tuple), iter(dict), iter(set), reversed(list_o), map(func,list_o), filter(func, list_o), file_o 生成器Generator：本质：迭代器，所以拥有__iter__方法和__next__方法特点：惰性运算, 开发者自定义 使用生成器的优点： 延迟计算，一次返回一个结果。也就是说，它不会一次生成所有的结果，这对于大数据量处理，将会非常有用。 提高代码可读性]]></content>
      <categories>
        <category>Python三大利器</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 包的使用]]></title>
    <url>%2F2019%2F03%2F05%2Fpackage%2F</url>
    <content type="text"><![CDATA[什么是包包就是把解决一类问题的模块放在同一个文件目录里，这个文件目录就叫做包包是一种通过使用‘.模块名’来组织python模块名称空间的方式。 包的导入方法 – import1234567891011121314151617soft/ ├── bin │ ├── __init__.py│ └── start.py ├── core │ ├── __init__.py│ └── Manage.py │ └── login() └── cook.py 最外层是soft软件工程目录 bin 和 core 是两个包 bin 下有着start.py 程序入口文件 core 下有着Manage模块,里面带有一个login( )方法 整个目录还有一个cook.py文件 在soft目录下 12345678910# 想要在start.py 使用 Manage的login()方法# 通过查看sys.path路径发现只能找到soft的bin目录,所以不能直接import core,需要从soft开始import sysprint(sys.path) # D:\\PycharmProjects\\Notes\\soft\\binimport soft.core.Managesoft.core.Manage.login() # login in Manageimport soft.core.Manage as MM.login() # login in Manage 关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如,soft.core.Manage但都必须遵循这个原则。 对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。 from … import …123456789import osimport sys# 把soft目录加入到sys.path里去，然后就可以直接找到coresys.path.append(os.path.dirname(os.getcwd()))print(sys.path) # 'D:\\PycharmProjects\\Notes\\soft'from core import ManageManage.login() # login in Manage 1234567891011# 在core包下的文件引入其他包中的方法或者配置# 记得由于我们执行开始是在start.py中执行,所以一定要在里面导入路径# settings 文件中加入 DB_PATH = 'D:\PycharmProjects\Notes\soft\db'# Manageimport osfrom conf import settingsdef login(): print('login in Manage') file_name = os.path.join(settings.DB_PATH,'info.log') with open(file_name,'w') as f: f.write('Hello') 需要注意的是from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误可以用import导入内置或者第三方模块（已经在sys.path中），但是要绝对避免使用import来导入自定义包的子模块(没有在sys.path中)，应该使用from… import …的绝对或者相对导入,且包的相对导入只能用from的形式。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 模块的使用]]></title>
    <url>%2F2019%2F03%2F04%2Fmodule%2F</url>
    <content type="text"><![CDATA[什么是模块在Python中，一个.py文件就被称之为一个模块 模块的调用模块一旦被调用，即相当于执行另外一个另外一个py文件中的代码，多次import导入同一个模块，只会执行一次。 模块的导入 – import1234# demo.pymoney = 100def read(): print('in read',money) 12345678# func.pyimport demodef read(): print('my read func')money = 200read() # 自己本地的print(demo.money) # 调用模块的demo.read() # 调用模块的 模块导入流程 先从sys.modules里查看是否已经被导入 如果没有被导入就依据sys.path路径去寻找模块 找到了就导入，没有找到就报错 创建这个模块的命名空间 执行文件,把文件中的名字都放到命名空间中 sys.modules会加入这个模块，当这个模块再被impoet时就不会被重复导入 123456import sysimport demo# sys.modules 是一个字典，内部包含模块名与模块对象的映射，该字典决定了导入模块时是否需要重新导入print(sys.modules.keys())# sys.path 是python的搜索模块的路径listprint(sys.path) 导入模块的顺序 内置模块 time,re 扩展模块 pip3安装的 django 自定义模块 demo 单独导入 – from…import…123from time import sleepsleep(1)print('hey') 123456from demo import read,moneymoney = 200def read(): print('my read',money)read() # my read 200print(money) # 200 查看结果1. 如果本地有read()方法则优先调用本地的。2. 即使导入了money这个变量也无法替代本地变量,会发生冲突。为什么要使用 from…import?1. import是导入了模块里面的所有名字 比较占用内存。2. 导入一个变量进来，占用的内容较少,只要不用重名即可。 1234# 导入多个名字from demo import money,readprint(money) # 100print(read) # &lt;function read at 0x0000000000B62620&gt; 1234567891011121314151617# 导入全部* 配合 __all__# 如果在模块中定义了__all__ 那么如果import * ，只有存在这个列表中的名字才能调用# import demo 不受这个约束# demo__all__ = ['money','read'] # 只和 from demo import * 能配合起来money = 100def read(): print('in read',money)def read2(): print('in read2',money)# funcfrom demo import *print(money) # 100read() # in read 100read2() # NameError: name 'read2' is not defined 把模块当做脚本执行我们可以通过模块的全局变量name来查看模块名：12345# demo2print(__name__) # __main__# funcimport demo2 # demo2 当我在文件中import demo2的时候,demo2中的print(__name__)执行返回的是demo2 当我在demo模块中print(__name__)的时候返回的是 __main__ 在哪个页面页面上点的run 在哪个页面上就是__main__ 如果不在本页面上执行,在其他页面上调用模块名导入执行,那么就返回模块名 if name == ‘main‘: 作用:用来控制.py文件在不同的应用场景下执行不同的逻辑123456789101112131415# demo2def login(): print('正在执行登录程序')if __name__ == '__main__': print('in demo2.py') # in demo2.py ret = login() # 正在执行登录程序 print(ret) # None # funcimport demo2ret = demo2.login() # 正在执行登录程序print(ret) # None# 这样就符合了：模块导入的时候什么都不执行,所有想做的都放在模块里面去,在执行程序的时候就不会受影响，也能调用模块中想要的名字]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Readme]]></title>
    <url>%2F2019%2F03%2F04%2FReadme%2F</url>
    <content type="text"></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
